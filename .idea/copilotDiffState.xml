<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/example/pyCTools/hwrng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/pyCTools/hwrng.md" />
              <option name="updatedContent" value="# Python Hardware Random Number Generator (hwrng)&#10;&#10;## Overview&#10;&#10;The `pyCTools.hwrng` module provides Python bindings to the high-security hardware random number generation capabilities of the `hRng` library. This module allows Python applications to access cryptographically secure random numbers generated from multiple entropy sources including hardware RNG instructions when available.&#10;&#10;## Features&#10;&#10;- Cryptographically secure random number generation&#10;- Thread-safe operation&#10;- Support for high-intensity entropy gathering&#10;- Self-test capabilities&#10;- Automatic architecture detection (x86/x64)&#10;- Simple Python API with proper error handling&#10;&#10;## Installation&#10;&#10;The `pyCTools` package includes precompiled binaries for both x86 and x64 Windows platforms. No additional installation steps are needed beyond installing the package:&#10;&#10;```bash&#10;pip install pyCTools&#10;```&#10;&#10;## API Reference&#10;&#10;### Functions&#10;&#10;#### `get_hardware_random_bytes(size: int) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the standard MaxRNG algorithm.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;&#10;# Generate 32 random bytes&#10;random_data = get_hardware_random_bytes(32)&#10;print(&quot;Random bytes:&quot;, random_data.hex())&#10;```&#10;&#10;#### `get_hardware_random_bytes_threadsafe(size: int) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the thread-safe version of MaxRNG. This function is safe to call from multiple threads simultaneously.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;import threading&#10;from pyCTools.hwrng import get_hardware_random_bytes_threadsafe&#10;&#10;def worker():&#10;    # Generate 16 random bytes in each thread&#10;    data = get_hardware_random_bytes_threadsafe(16)&#10;    print(f&quot;Thread {threading.current_thread().name}: {data.hex()}&quot;)&#10;&#10;# Create and start 5 threads&#10;threads = []&#10;for i in range(5):&#10;    t = threading.Thread(target=worker, name=f&quot;RNG-{i}&quot;)&#10;    threads.append(t)&#10;    t.start()&#10;&#10;# Wait for all threads to complete&#10;for t in threads:&#10;    t.join()&#10;```&#10;&#10;#### `get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the extended MaxRNG algorithm with configurable entropy gathering intensity.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;- `intensive_level` (int, optional): Entropy gathering intensity level (must be &gt;= 1). Default is 2.&#10;  - Level 1: Standard MaxRNG operation&#10;  - Level 2: Additional CPU jitter entropy&#10;  - Level 3+: Maximum entropy gathering from all available sources&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive or intensive_level is less than 1&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes_extended&#10;&#10;# Generate 64 random bytes with maximum entropy gathering&#10;random_data = get_hardware_random_bytes_extended(64, intensive_level=5)&#10;print(&quot;High-security random bytes:&quot;, random_data.hex())&#10;```&#10;&#10;#### `hardware_rng_selftest() -&gt; bool`&#10;&#10;Runs the built-in self-test for the RNG to verify proper operation.&#10;&#10;**Returns:**&#10;- `bool`: True if the self-test passes, False otherwise&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import hardware_rng_selftest&#10;&#10;if hardware_rng_selftest():&#10;    print(&quot;RNG self-test passed&quot;)&#10;else:&#10;    print(&quot;RNG self-test failed&quot;)&#10;```&#10;&#10;### Exceptions&#10;&#10;#### `HardwareRNGError`&#10;&#10;Raised when a hardware RNG operation fails or when the DLL cannot be loaded.&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes, HardwareRNGError&#10;&#10;try:&#10;    random_data = get_hardware_random_bytes(32)&#10;    print(&quot;Random bytes:&quot;, random_data.hex())&#10;except HardwareRNGError as e:&#10;    print(f&quot;RNG operation failed: {e}&quot;)&#10;```&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;&#10;# Generate a random 256-bit key (32 bytes)&#10;key = get_hardware_random_bytes(32)&#10;print(f&quot;Random 256-bit key: {key.hex()}&quot;)&#10;```&#10;&#10;### Using as a Source for cryptography Library&#10;&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;from cryptography.hazmat.primitives.asymmetric import rsa&#10;import os&#10;&#10;class HardwareRandomGenerator:&#10;    def __init__(self):&#10;        pass&#10;        &#10;    def read(self, size):&#10;        return get_hardware_random_bytes(size)&#10;&#10;# Use our hardware RNG as a source for RSA key generation&#10;os.environ[&quot;PYTHONHASHSEED&quot;] = &quot;0&quot;  # Fix seed for reproducible example&#10;rng = HardwareRandomGenerator()&#10;private_key = rsa.generate_private_key(&#10;    public_exponent=65537,&#10;    key_size=2048,&#10;    backend=default_backend(),&#10;    random_number_generator=rng&#10;)&#10;&#10;print(&quot;Generated RSA key with hardware entropy&quot;)&#10;```&#10;&#10;### High-Security Random Token Generation&#10;&#10;```python&#10;import base64&#10;from pyCTools.hwrng import get_hardware_random_bytes_extended&#10;&#10;def generate_secure_token(length=32):&#10;    &quot;&quot;&quot;Generate a URL-safe, base64 encoded token with maximum entropy.&quot;&quot;&quot;&#10;    random_bytes = get_hardware_random_bytes_extended(length, intensive_level=5)&#10;    return base64.urlsafe_b64encode(random_bytes).decode('utf-8')&#10;&#10;# Generate a secure session token&#10;session_token = generate_secure_token(48)&#10;print(f&quot;Secure session token: {session_token}&quot;)&#10;```&#10;&#10;### Thread Safety Demonstration&#10;&#10;```python&#10;import threading&#10;import time&#10;from pyCTools.hwrng import get_hardware_random_bytes_threadsafe&#10;&#10;def intensive_rng_task(thread_id):&#10;    &quot;&quot;&quot;Generate multiple random values in a thread.&quot;&quot;&quot;&#10;    for i in range(5):&#10;        data = get_hardware_random_bytes_threadsafe(16)&#10;        hex_data = data.hex()&#10;        print(f&quot;Thread {thread_id}, iteration {i}: {hex_data}&quot;)&#10;        time.sleep(0.01)  # Small delay to better visualize concurrent execution&#10;&#10;# Create and start 10 threads&#10;threads = []&#10;for i in range(10):&#10;    t = threading.Thread(target=intensive_rng_task, args=(i,))&#10;    threads.append(t)&#10;    t.start()&#10;&#10;# Wait for all threads to complete&#10;for t in threads:&#10;    t.join()&#10;```&#10;&#10;## Technical Details&#10;&#10;### DLL Loading&#10;&#10;The module automatically locates and loads the appropriate version (x86 or x64) of the `hRng` DLL from the distribution directory. The DLL is loaded only once when the module is first imported.&#10;&#10;### Error Handling&#10;&#10;All RNG operations include proper error checking. If an operation fails, a `HardwareRNGError` exception is raised with an informative error message.&#10;&#10;### Thread Safety&#10;&#10;The `get_hardware_random_bytes_threadsafe` function uses the thread-safe version of the RNG which employs proper synchronization mechanisms to ensure safe concurrent access from multiple threads.&#10;&#10;### Performance Considerations&#10;&#10;- The standard `get_hardware_random_bytes` function provides the best balance of security and performance for most applications.&#10;- The `get_hardware_random_bytes_extended` function with higher intensity levels will be slower but provides additional entropy gathering.&#10;- For applications requiring many random numbers in performance-sensitive contexts, consider generating larger batches less frequently.&#10;&#10;## Security Recommendations&#10;&#10;1. Use `get_hardware_random_bytes_extended` with a high intensity level (4 or 5) for generating cryptographic keys and other highly sensitive values.&#10;2. Use `get_hardware_random_bytes_threadsafe` in multi-threaded applications to ensure thread safety.&#10;3. Consider running `hardware_rng_selftest()` at application startup to verify RNG functionality.&#10;4. For cryptographic applications, combine this RNG with proper key derivation functions (KDFs) such as PBKDF2 or Argon2.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/pyCTools/hwrng.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/pyCTools/hwrng.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;hwrng.py&#10;&#10;Hardware Random Number Generator interface for Python using ctypes and the new hRng.dll.&#10;&quot;&quot;&quot;&#10;&#10;import ctypes&#10;import os&#10;import platform&#10;&#10;__all__ = [&#10;    &quot;get_hardware_random_bytes&quot;,&#10;    &quot;get_hardware_random_bytes_extended&quot;,&#10;    &quot;get_thread_safe_random_bytes&quot;,&#10;    &quot;hardware_rng_selftest&quot;,&#10;    &quot;is_thread_safe_available&quot;,&#10;    &quot;HardwareRNGError&quot;&#10;]&#10;&#10;&#10;class HardwareRNGError(RuntimeError):&#10;    &quot;&quot;&quot;Raised when hardware RNG fails or DLL cannot be loaded.&quot;&quot;&quot;&#10;    def __init__(self, message=&quot;Hardware RNG error occurred&quot;):&#10;        super().__init__(message)&#10;&#10;&#10;def _load_rng_functions():&#10;    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'&#10;    dll_name = f'hRng_{arch}.dll'&#10;    base_dir = os.path.dirname(__file__)&#10;    possible_dist_paths = [&#10;        os.path.join(base_dir, 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', '..', 'dist', arch, dll_name),&#10;    ]&#10;&#10;    dll_path = None&#10;    for path in possible_dist_paths:&#10;        abs_path = os.path.abspath(path)&#10;        if os.path.exists(abs_path):&#10;            dll_path = abs_path&#10;            break&#10;&#10;    if dll_path is None:&#10;        dll_path = os.path.abspath(possible_dist_paths[0])  # fallback for error message&#10;&#10;    dll = ctypes.CDLL(dll_path)&#10;&#10;    # Setup function signatures&#10;    MaxRNG = dll.MaxRNG&#10;    MaxRNG.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int]&#10;    MaxRNG.restype = ctypes.c_int&#10;&#10;    MaxRNG_Extended = dll.MaxRNG_Extended&#10;    MaxRNG_Extended.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int, ctypes.c_int]&#10;    MaxRNG_Extended.restype = ctypes.c_int&#10;&#10;    RNG_SelfTest = dll.RNG_SelfTest&#10;    RNG_SelfTest.argtypes = []&#10;    RNG_SelfTest.restype = ctypes.c_int&#10;&#10;    # Thread safety check function&#10;    IsRNGThreadSafe = dll.IsRNGThreadSafe&#10;    IsRNGThreadSafe.argtypes = []&#10;    IsRNGThreadSafe.restype = ctypes.c_int&#10;&#10;    return MaxRNG, MaxRNG_Extended, RNG_SelfTest, IsRNGThreadSafe&#10;&#10;&#10;# Load the functions only once&#10;_MaxRNG, _MaxRNG_Extended, _RNG_SelfTest, _IsRNGThreadSafe = _load_rng_functions()&#10;&#10;&#10;def get_hardware_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def get_thread_safe_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG with thread safety.&#10;&#10;    This function uses the thread-safe implementation of MaxRNG that properly&#10;    synchronizes access across multiple threads.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails or thread safety is not available.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    if not is_thread_safe_available():&#10;        raise HardwareRNGError(&quot;Thread-safe RNG implementation not available&quot;)&#10;&#10;    # Uses the same MaxRNG function which is internally thread-safe&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;Thread-safe MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def is_thread_safe_available() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if the thread-safe RNG implementation is available.&#10;&#10;    Returns:&#10;        bool: True if thread safety is available, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_IsRNGThreadSafe())&#10;&#10;&#10;# TODO Benchmark all with proper graphs and tests&#10;def get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve random bytes using MaxRNG_Extended.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;        intensive_level (int): Entropy gathering intensity (&gt;=1).&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size or intensive_level is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;    if intensive_level &lt; 1:&#10;        raise ValueError(&quot;intensive_level must be &gt;= 1&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG_Extended(buffer, size, intensive_level)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG_Extended failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def hardware_rng_selftest() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Run the RNG self-test.&#10;&#10;    Returns:&#10;        bool: True if self-test passes, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_RNG_SelfTest())&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;hwrng.py&#10;&#10;Hardware Random Number Generator interface for Python using ctypes and the new hRng.dll.&#10;&quot;&quot;&quot;&#10;&#10;import ctypes&#10;import os&#10;import platform&#10;import threading&#10;&#10;__all__ = [&#10;    &quot;get_hardware_random_bytes&quot;,&#10;    &quot;get_thread_safe_random_bytes&quot;,&#10;    &quot;get_hardware_random_bytes_extended&quot;,&#10;    &quot;hardware_rng_selftest&quot;,&#10;    &quot;is_thread_safe_available&quot;,&#10;    &quot;HardwareRNGError&quot;&#10;]&#10;&#10;&#10;class HardwareRNGError(RuntimeError):&#10;    &quot;&quot;&quot;Raised when hardware RNG fails or DLL cannot be loaded.&quot;&quot;&quot;&#10;    def __init__(self, message=&quot;Hardware RNG error occurred&quot;):&#10;        super().__init__(message)&#10;&#10;&#10;# Global lock for Python-level thread safety&#10;_py_lock = threading.Lock()&#10;&#10;def _load_rng_functions():&#10;    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'&#10;    dll_name = f'hRng_{arch}.dll'&#10;    base_dir = os.path.dirname(__file__)&#10;    possible_dist_paths = [&#10;        os.path.join(base_dir, 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', '..', 'dist', arch, dll_name),&#10;    ]&#10;&#10;    dll_path = None&#10;    for path in possible_dist_paths:&#10;        abs_path = os.path.abspath(path)&#10;        if os.path.exists(abs_path):&#10;            dll_path = abs_path&#10;            break&#10;&#10;    if dll_path is None:&#10;        # Try looking for the DLL in the current directory as a fallback&#10;        current_dir = os.path.abspath(os.getcwd())&#10;        fallback_path = os.path.join(current_dir, dll_name)&#10;        if os.path.exists(fallback_path):&#10;            dll_path = fallback_path&#10;        else:&#10;            dll_path = os.path.abspath(possible_dist_paths[0])  # fallback for error message&#10;            raise HardwareRNGError(f&quot;Could not find {dll_name}. Searched in {', '.join(possible_dist_paths)}&quot;)&#10;&#10;    try:&#10;        dll = ctypes.CDLL(dll_path)&#10;    except Exception as e:&#10;        raise HardwareRNGError(f&quot;Failed to load {dll_path}: {str(e)}&quot;)&#10;&#10;    # Setup function signatures&#10;    MaxRNG = dll.MaxRNG&#10;    MaxRNG.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int]&#10;    MaxRNG.restype = ctypes.c_int&#10;&#10;    MaxRNG_Extended = dll.MaxRNG_Extended&#10;    MaxRNG_Extended.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int, ctypes.c_int]&#10;    MaxRNG_Extended.restype = ctypes.c_int&#10;&#10;    RNG_SelfTest = dll.RNG_SelfTest&#10;    RNG_SelfTest.argtypes = []&#10;    RNG_SelfTest.restype = ctypes.c_int&#10;&#10;    # Thread safety check function&#10;    IsRNGThreadSafe = dll.IsRNGThreadSafe&#10;    IsRNGThreadSafe.argtypes = []&#10;    IsRNGThreadSafe.restype = ctypes.c_int&#10;&#10;    return MaxRNG, MaxRNG_Extended, RNG_SelfTest, IsRNGThreadSafe&#10;&#10;&#10;# Load the functions only once in a thread-safe way&#10;try:&#10;    _MaxRNG, _MaxRNG_Extended, _RNG_SelfTest, _IsRNGThreadSafe = _load_rng_functions()&#10;except HardwareRNGError as e:&#10;    # Provide stubs for functions in case the DLL couldn't be loaded&#10;    def _error_stub(*args, **kwargs):&#10;        raise HardwareRNGError(&quot;RNG functions unavailable - DLL could not be loaded&quot;)&#10;    &#10;    _MaxRNG = _MaxRNG_Extended = _RNG_SelfTest = _IsRNGThreadSafe = _error_stub&#10;    print(f&quot;WARNING: Failed to load RNG DLL: {str(e)}&quot;)&#10;&#10;&#10;def get_hardware_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    # Add Python-level thread safety as a backup&#10;    with _py_lock:&#10;        buffer = (ctypes.c_ubyte * size)()&#10;        success = _MaxRNG(buffer, size)&#10;        if not success:&#10;            raise HardwareRNGError(&quot;MaxRNG failed.&quot;)&#10;        &#10;        # Make a copy to ensure buffer is fully processed before releasing the lock&#10;        return bytes(buffer)&#10;&#10;&#10;def get_thread_safe_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG with thread safety.&#10;&#10;    This function uses the thread-safe implementation of MaxRNG that properly&#10;    synchronizes access across multiple threads.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails or thread safety is not available.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    if not is_thread_safe_available():&#10;        # Fall back to Python-level locking if C-level thread safety is not available&#10;        return get_hardware_random_bytes(size)&#10;&#10;    # Uses the same MaxRNG function which is internally thread-safe&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;Thread-safe MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def is_thread_safe_available() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if the thread-safe RNG implementation is available.&#10;&#10;    Returns:&#10;        bool: True if thread safety is available, False otherwise.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return bool(_IsRNGThreadSafe())&#10;    except Exception:&#10;        return False&#10;&#10;&#10;# TODO Benchmark all with proper graphs and tests&#10;def get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve random bytes using MaxRNG_Extended.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;        intensive_level (int): Entropy gathering intensity (&gt;=1).&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size or intensive_level is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;    if intensive_level &lt; 1:&#10;        raise ValueError(&quot;intensive_level must be &gt;= 1&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG_Extended(buffer, size, intensive_level)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG_Extended failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def hardware_rng_selftest() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Run the RNG self-test.&#10;&#10;    Returns:&#10;        bool: True if self-test passes, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_RNG_SelfTest())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/t.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/t.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Example demonstrating thread-safe random number generation using PyCTools hwrng module.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import threading&#10;from pyCTools.hwrng import (&#10;    get_hardware_random_bytes,&#10;    get_thread_safe_random_bytes,&#10;    is_thread_safe_available,&#10;    HardwareRNGError&#10;)&#10;&#10;&#10;def thread_safe_example():&#10;    &quot;&quot;&quot;&#10;    Demonstrates the usage of thread-safe RNG functionality.&#10;    Compares standard and thread-safe implementations under high contention.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Thread-Safe RNG Example&quot;)&#10;    print(&quot;-----------------------&quot;)&#10;&#10;    # Check if thread safety is available&#10;    thread_safe_available = is_thread_safe_available()&#10;    print(f&quot;Thread-safe RNG implementation available: {thread_safe_available}&quot;)&#10;&#10;    if not thread_safe_available:&#10;        print(&quot;WARNING: Thread-safe implementation not available. Test will use standard RNG.&quot;)&#10;&#10;    # Number of threads to create&#10;    num_threads = 20&#10;    iterations_per_thread = 30&#10;    bytes_per_request = 16&#10;&#10;    # Results storage&#10;    standard_failures = 0&#10;    threadsafe_failures = 0&#10;&#10;    # Function for thread to run&#10;    def worker_thread(thread_id, use_thread_safe, results_list):&#10;        method = &quot;thread_safe&quot; if use_thread_safe else &quot;standard&quot;&#10;        rng_func = get_thread_safe_random_bytes if use_thread_safe else get_hardware_random_bytes&#10;&#10;        for i_ in range(iterations_per_thread):&#10;            try:&#10;                start_time_ = time.time()&#10;                random_data = rng_func(bytes_per_request)&#10;                elapsed = time.time() - start_time_&#10;&#10;                results_list.append({&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'data': random_data.hex()[:8] + '...',  # Show first 4 bytes only&#10;                    'time': elapsed&#10;                })&#10;&#10;                # Add a tiny sleep to allow thread switching&#10;                time.sleep(0.001)&#10;&#10;            except HardwareRNGError as e:&#10;                results_list.append({&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'error': str(e)&#10;                })&#10;                if use_thread_safe:&#10;                    nonlocal threadsafe_failures&#10;                    threadsafe_failures += 1&#10;                else:&#10;                    nonlocal standard_failures&#10;                    standard_failures += 1&#10;                break&#10;&#10;    # Test standard implementation&#10;    print(&quot;\nRunning standard RNG with multiple threads...&quot;)&#10;    standard_results = []&#10;    standard_threads = []&#10;&#10;    start_time = time.time()&#10;    for i in range(num_threads):&#10;        t = threading.Thread(&#10;            target=worker_thread,&#10;            args=(i, False, standard_results)&#10;        )&#10;        standard_threads.append(t)&#10;        t.start()&#10;&#10;    for t in standard_threads:&#10;        t.join()&#10;&#10;    standard_time = time.time() - start_time&#10;&#10;    # Test thread-safe implementation if available&#10;    threadsafe_time = 0&#10;    threadsafe_results = []&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nRunning thread-safe RNG with multiple threads...&quot;)&#10;        threadsafe_threads = []&#10;&#10;        start_time = time.time()&#10;        for i in range(num_threads):&#10;            t = threading.Thread(&#10;                target=worker_thread,&#10;                args=(i, True, threadsafe_results)&#10;            )&#10;            threadsafe_threads.append(t)&#10;            t.start()&#10;&#10;        for t in threadsafe_threads:&#10;            t.join()&#10;&#10;        threadsafe_time = time.time() - start_time&#10;&#10;    # Print results summary&#10;    print(&quot;\nResults Summary:&quot;)&#10;    print(&quot;--------------&quot;)&#10;    print(f&quot;Standard RNG: {len(standard_results)} operations in {standard_time:.3f}s&quot;)&#10;    print(f&quot;  - Success rate: {(len(standard_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;    print(f&quot;  - Failures: {standard_failures}&quot;)&#10;    print(f&quot;  - Avg time per operation: {standard_time / len(standard_results):.6f}s&quot;)&#10;&#10;    if thread_safe_available:&#10;        print(f&quot;\nThread-safe RNG: {len(threadsafe_results)} operations in {threadsafe_time:.3f}s&quot;)&#10;        print(f&quot;  - Success rate: {(len(threadsafe_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;        print(f&quot;  - Failures: {threadsafe_failures}&quot;)&#10;        print(f&quot;  - Avg time per operation: {threadsafe_time / len(threadsafe_results):.6f}s&quot;)&#10;&#10;        # Performance comparison&#10;        if standard_time &gt; 0 and threadsafe_time &gt; 0:&#10;            relative_perf = standard_time / threadsafe_time&#10;            if relative_perf &gt; 1:&#10;                print(f&quot;\nThread-safe implementation is {relative_perf:.2f}x faster than standard&quot;)&#10;            else:&#10;                print(f&quot;\nStandard implementation is {1/relative_perf:.2f}x faster than thread-safe&quot;)&#10;&#10;    # Show a sample of random values from each&#10;    print(&quot;\nSample Standard RNG values:&quot;)&#10;    for i, result in enumerate(standard_results[:5]):&#10;        if 'error' in result:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;        else:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nSample Thread-safe RNG values:&quot;)&#10;        for i, result in enumerate(threadsafe_results[:5]):&#10;            if 'error' in result:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;            else:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    thread_safe_example()&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Example demonstrating thread-safe random number generation using PyCTools hwrng module.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import threading&#10;from pyCTools.hwrng import (&#10;    get_hardware_random_bytes,&#10;    get_thread_safe_random_bytes,&#10;    is_thread_safe_available,&#10;    HardwareRNGError&#10;)&#10;&#10;&#10;def thread_safe_example():&#10;    &quot;&quot;&quot;&#10;    Demonstrates the usage of thread-safe RNG functionality.&#10;    Compares standard and thread-safe implementations under high contention.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Thread-Safe RNG Example&quot;)&#10;    print(&quot;-----------------------&quot;)&#10;&#10;    # Check if thread safety is available&#10;    thread_safe_available = is_thread_safe_available()&#10;    print(f&quot;Thread-safe RNG implementation available: {thread_safe_available}&quot;)&#10;&#10;    if not thread_safe_available:&#10;        print(&quot;WARNING: Thread-safe implementation not available. Test will use standard RNG.&quot;)&#10;&#10;    # Number of threads to create - reduce count to avoid overloading&#10;    num_threads = 10&#10;    iterations_per_thread = 10&#10;    bytes_per_request = 16&#10;&#10;    # Results storage&#10;    standard_failures = 0&#10;    threadsafe_failures = 0&#10;&#10;    # Function for thread to run with proper exception handling&#10;    def worker_thread(thread_id, use_thread_safe, results_list):&#10;        method = &quot;thread_safe&quot; if use_thread_safe else &quot;standard&quot;&#10;        rng_func = get_thread_safe_random_bytes if use_thread_safe else get_hardware_random_bytes&#10;&#10;        for i_ in range(iterations_per_thread):&#10;            try:&#10;                start_time_ = time.time()&#10;                random_data = rng_func(bytes_per_request)&#10;                elapsed = time.time() - start_time_&#10;                &#10;                # Store result safely&#10;                result_entry = {&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'data': random_data.hex()[:8] + '...',  # Show first 4 bytes only&#10;                    'time': elapsed&#10;                }&#10;                &#10;                # Use thread lock for updating shared data&#10;                with threading.Lock():&#10;                    results_list.append(result_entry)&#10;&#10;                # Add a tiny sleep to allow thread switching&#10;                time.sleep(0.005)  # Slightly longer sleep to reduce contention&#10;&#10;            except Exception as e:&#10;                error_entry = {&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'error': str(e)&#10;                }&#10;                &#10;                with threading.Lock():&#10;                    results_list.append(error_entry)&#10;                    if use_thread_safe:&#10;                        nonlocal threadsafe_failures&#10;                        threadsafe_failures += 1&#10;                    else:&#10;                        nonlocal standard_failures&#10;                        standard_failures += 1&#10;                &#10;                # Don't break - let thread continue trying other iterations&#10;                time.sleep(0.01)  # Sleep a bit after error&#10;&#10;    # Test standard implementation&#10;    print(&quot;\nRunning standard RNG with multiple threads...&quot;)&#10;    standard_results = []&#10;    standard_threads = []&#10;&#10;    start_time = time.time()&#10;    &#10;    # Create threads with proper error handling&#10;    try:&#10;        for i in range(num_threads):&#10;            t = threading.Thread(&#10;                target=worker_thread,&#10;                args=(i, False, standard_results),&#10;                name=f&quot;Std-Thread-{i}&quot;&#10;            )&#10;            standard_threads.append(t)&#10;            t.start()&#10;            # Brief sleep between thread starts&#10;            time.sleep(0.01)&#10;            &#10;        print(f&quot;Started {len(standard_threads)} standard threads&quot;)&#10;            &#10;        # Join with timeout to prevent hanging&#10;        for t in standard_threads:&#10;            t.join(timeout=10.0)  # 10 second timeout per thread&#10;            if t.is_alive():&#10;                print(f&quot;Warning: Thread {t.name} did not complete in time&quot;)&#10;                &#10;    except Exception as e:&#10;        print(f&quot;Error during standard thread execution: {str(e)}&quot;)&#10;&#10;    standard_time = time.time() - start_time&#10;    print(f&quot;Standard thread test completed in {standard_time:.2f} seconds&quot;)&#10;&#10;    # Test thread-safe implementation if available&#10;    threadsafe_time = 0&#10;    threadsafe_results = []&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nRunning thread-safe RNG with multiple threads...&quot;)&#10;        threadsafe_threads = []&#10;&#10;        start_time = time.time()&#10;        &#10;        try:&#10;            for i in range(num_threads):&#10;                t = threading.Thread(&#10;                    target=worker_thread,&#10;                    args=(i, True, threadsafe_results),&#10;                    name=f&quot;Safe-Thread-{i}&quot;&#10;                )&#10;                threadsafe_threads.append(t)&#10;                t.start()&#10;                # Brief sleep between thread starts&#10;                time.sleep(0.01)&#10;                &#10;            print(f&quot;Started {len(threadsafe_threads)} thread-safe threads&quot;)&#10;                &#10;            # Join with timeout to prevent hanging&#10;            for t in threadsafe_threads:&#10;                t.join(timeout=10.0)&#10;                if t.is_alive():&#10;                    print(f&quot;Warning: Thread {t.name} did not complete in time&quot;)&#10;                    &#10;        except Exception as e:&#10;            print(f&quot;Error during thread-safe thread execution: {str(e)}&quot;)&#10;&#10;        threadsafe_time = time.time() - start_time&#10;        print(f&quot;Thread-safe test completed in {threadsafe_time:.2f} seconds&quot;)&#10;&#10;    # Print results summary - only if we have any results&#10;    if standard_results:&#10;        print(&quot;\nResults Summary:&quot;)&#10;        print(&quot;--------------&quot;)&#10;        print(f&quot;Standard RNG: {len(standard_results)} operations in {standard_time:.3f}s&quot;)&#10;        print(f&quot;  - Success rate: {(len(standard_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;        print(f&quot;  - Failures: {standard_failures}&quot;)&#10;        if standard_results:&#10;            print(f&quot;  - Avg time per operation: {standard_time / max(len(standard_results), 1):.6f}s&quot;)&#10;&#10;        if thread_safe_available and threadsafe_results:&#10;            print(f&quot;\nThread-safe RNG: {len(threadsafe_results)} operations in {threadsafe_time:.3f}s&quot;)&#10;            print(f&quot;  - Success rate: {(len(threadsafe_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;            print(f&quot;  - Failures: {threadsafe_failures}&quot;)&#10;            print(f&quot;  - Avg time per operation: {threadsafe_time / max(len(threadsafe_results), 1):.6f}s&quot;)&#10;&#10;            # Performance comparison&#10;            if standard_time &gt; 0 and threadsafe_time &gt; 0 and len(standard_results) &gt; 0 and len(threadsafe_results) &gt; 0:&#10;                relative_perf = standard_time / threadsafe_time&#10;                if relative_perf &gt; 1:&#10;                    print(f&quot;\nThread-safe implementation is {relative_perf:.2f}x faster than standard&quot;)&#10;                else:&#10;                    print(f&quot;\nStandard implementation is {1/relative_perf:.2f}x faster than thread-safe&quot;)&#10;    else:&#10;        print(&quot;\nNo results collected! Test failed to run properly.&quot;)&#10;&#10;    # Show a sample of random values from each&#10;    print(&quot;\nSample Standard RNG values:&quot;)&#10;    for i, result in enumerate(standard_results[:5]):&#10;        if 'error' in result:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;        else:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;    if thread_safe_available and threadsafe_results:&#10;        print(&quot;\nSample Thread-safe RNG values:&quot;)&#10;        for i, result in enumerate(threadsafe_results[:5]):&#10;            if 'error' in result:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;            else:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    thread_safe_example()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyCTools/Overview.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyCTools/Overview.md" />
              <option name="originalContent" value="# PyCTools Library Documentation&#10;&#10;## Overview&#10;&#10;PyCTools is a high-performance Python library that provides native C-backed functionality for system-level operations that require maximum performance and direct hardware access. The library bridges Python's ease of use with C's raw performance through carefully designed wrapper classes.&#10;&#10;## Components&#10;&#10;The library currently consists of two main modules:&#10;&#10;1. **hwrng** - Hardware-based Random Number Generator that interfaces with CPU hardware to generate cryptographically secure random numbers at maximum performance.&#10;&#10;2. **processInspect** - Advanced process metrics collection system for detailed system and process monitoring with minimal overhead.&#10;&#10;## Key Strengths&#10;&#10;- **Native Performance**: Direct access to hardware and system resources via compiled C/C++ code&#10;- **Cross-Architecture Support**: Works on both x86 and x64 Windows environments&#10;- **Thread Safety**: Designed for concurrent operation in multithreaded environments&#10;- **Comprehensive Metrics**: Detailed process and system statistics beyond what's available in standard Python libraries&#10;- **Hardware RNG**: True random number generation using CPU hardware features&#10;- **Minimal Overhead**: Engineered to add negligible performance impact while monitoring&#10;&#10;## Usage Domains&#10;&#10;- Performance monitoring and diagnostics&#10;- Security applications requiring cryptographically secure random numbers&#10;- System administration and monitoring tools&#10;- Performance-critical scientific or financial applications&#10;&#10;Each module is documented in detail in its dedicated documentation file.&#10;&#10;" />
              <option name="updatedContent" value="# PyCTools Library Documentation&#10;&#10;## Overview&#10;&#10;PyCTools is a high-performance Python library that provides native C-backed functionality for system-level operations that require maximum performance and direct hardware access. The library bridges Python's ease of use with C's raw performance through carefully designed wrapper classes that interface with compiled native code.&#10;&#10;## Components&#10;&#10;The library currently consists of two main modules:&#10;&#10;1. **hwrng** - Hardware-based Random Number Generator that interfaces with CPU hardware to generate cryptographically secure random numbers at maximum performance. It utilizes the CPU's RDRAND instruction (where available) for true hardware randomness.&#10;&#10;2. **processInspect** - Advanced process metrics collection system for detailed system and process monitoring with minimal overhead. Provides comprehensive performance data for Windows processes beyond standard Python libraries.&#10;&#10;## Architecture&#10;&#10;PyCTools employs a hybrid architecture:&#10;&#10;- **Python Layer**: Clean, Pythonic wrapper classes providing a user-friendly API&#10;- **Native Layer**: High-performance C/C++ code compiled to architecture-specific DLLs&#10;- **Dynamic Loading**: Intelligent DLL loader that automatically selects the correct binary for the host architecture&#10;&#10;The library uses a centralized DLL loading mechanism through the `_loadDLL` module, which implements sophisticated path resolution and error handling to ensure reliable operation across different environments.&#10;&#10;## Key Strengths&#10;&#10;- **Native Performance**: Direct access to hardware and system resources via compiled C/C++ code&#10;- **Cross-Architecture Support**: Works seamlessly on both x86 and x64 Windows environments&#10;- **Thread Safety**: Designed for concurrent operation in multithreaded environments&#10;- **Comprehensive Metrics**: Detailed process and system statistics beyond what's available in standard Python libraries&#10;- **Hardware RNG**: True random number generation using CPU hardware features&#10;- **Minimal Overhead**: Engineered to add negligible performance impact while monitoring&#10;- **Robust DLL Management**: Intelligent DLL discovery and loading with clear error reporting&#10;- **Consistent API**: Uniform interface pattern across different modules for ease of use&#10;- **Detailed Documentation**: Comprehensive documentation with examples and best practices&#10;&#10;## Usage Domains&#10;&#10;- Performance monitoring and diagnostics&#10;- Security applications requiring cryptographically secure random numbers&#10;- System administration and monitoring tools&#10;- Performance-critical scientific or financial applications&#10;- Resource usage tracking and optimization&#10;- Application performance benchmarking&#10;&#10;Each module is documented in detail in its dedicated documentation file." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyCTools/hwrng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyCTools/hwrng.md" />
              <option name="originalContent" value="# Hardware Random Number Generator (hwrng) Module&#10;&#10;The OSS `/dev/urandom` of Windows.&#10;&#10;---&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hwrng.py&lt;/summary&gt;&#10;&#10;## hwrng.py&#10;&#10;&gt; This is not comprehensive at all&#10;&#10;### Features&#10;- Get cryptographically secure random bytes from hardware RNG (RDRAND).&#10;- Raises `HardwareRNGError` if not supported or DLL missing.&#10;&#10;### Usage&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;rb = get_hardware_random_bytes(32)&#10;print(rb.hex())&#10;```&#10;&#10;&lt;/details&gt;&#10;&#10;---&#10;&#10;&#10;## Module Overview&#10;&#10;The `hwrng` module provides a Python interface to hardware-based random number generation capabilities through the `MaxRNG` class. This class wraps a native C library that accesses CPU hardware random number generation features to produce high-quality random data with superior entropy compared to software-based PRNGs.&#10;&#10;## MaxRNG Class&#10;&#10;### Class Description&#10;`MaxRNG` is a wrapper class for hardware-based random number generation that interfaces with a native DLL (`hRng_x64.dll` or `hRng_x86.dll` depending on architecture). It automatically detects the system architecture and loads the appropriate binary.&#10;&#10;### Initialization&#10;```python&#10;rng = MaxRNG()&#10;```&#10;When instantiating the class, it performs the following operations:&#10;- Determines system architecture (x86/x64)&#10;- Searches for the appropriate DLL in multiple possible paths&#10;- Loads the DLL using ctypes&#10;- Sets up function prototypes and return types&#10;&#10;### Constants&#10;The class does not expose any constants directly.&#10;&#10;### Methods&#10;&#10;#### `test_rng_available() -&gt; bool`&#10;&#10;Checks if the hardware random number generator is available on the current system.&#10;&#10;**Returns:**&#10;- `True` if hardware RNG is available&#10;- `False` otherwise&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_rng_available():&#10;    print(&quot;Hardware RNG is available&quot;)&#10;else:&#10;    print(&quot;Hardware RNG is not available&quot;)&#10;```&#10;&#10;#### `test_threading_available() -&gt; bool`&#10;&#10;Checks if the thread-safe version of the RNG is available.&#10;&#10;**Returns:**&#10;- `True` if thread-safe RNG is available&#10;- `False` otherwise&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    print(&quot;Thread-safe RNG is available&quot;)&#10;else:&#10;    print(&quot;Thread-safe RNG is not available&quot;)&#10;```&#10;&#10;#### `maxrng(size: int) -&gt; bytes`&#10;&#10;Generates random bytes using the hardware RNG.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng(32)  # Generate 32 random bytes&#10;```&#10;&#10;#### `maxrng_ultra(size: int, complexity: int) -&gt; bytes`&#10;&#10;Generates random bytes with additional complexity for enhanced security.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;- `complexity` (int): Level of additional entropy mixing (higher values provide potentially better randomness but slower performance)&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng_ultra(32, 3)  # Generate 32 random bytes with complexity level 3&#10;```&#10;&#10;#### `maxrng_threadsafe(size: int) -&gt; bytes`&#10;&#10;Thread-safe version of the random number generator.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If threading is not available or if the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    random_data = rng.maxrng_threadsafe(32)  # Generate 32 random bytes in thread-safe mode&#10;```&#10;&#10;### Implementation Details&#10;&#10;#### DLL Loading&#10;The class implements a sophisticated DLL search mechanism that looks in multiple relative paths:&#10;- `./dist/{arch}/hRng_{arch}.dll`&#10;- `../dist/{arch}/hRng_{arch}.dll`&#10;- `../../dist/{arch}/hRng_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;#### Error Handling&#10;All methods perform proper error checking of the underlying C functions and raise appropriate exceptions with detailed error messages when operations fail.&#10;&#10;#### Memory Management&#10;The class handles all memory allocation and deallocation for the buffer used to store random data, ensuring no memory leaks occur during operation.&#10;&#10;## Usage Best Practices&#10;&#10;1. **Always check availability before use:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_rng_available():&#10;       # Proceed with RNG operations&#10;   ```&#10;&#10;2. **For thread-safe operations:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_threading_available():&#10;       # Proceed with thread-safe RNG operations&#10;   ```&#10;&#10;3. **Handle potential exceptions:**&#10;   ```python&#10;   try:&#10;       random_data = rng.maxrng(32)&#10;   except RuntimeError as e:&#10;       # Handle failure&#10;   ```&#10;&#10;4. **Choose the appropriate method:**&#10;   - `maxrng()` for standard random number generation&#10;   - `maxrng_ultra()` for higher security requirements&#10;   - `maxrng_threadsafe()` for multithreaded applications&#10;&#10;" />
              <option name="updatedContent" value="# Hardware Random Number Generator (hwrng) Module&#10;&#10;The OSS `/dev/urandom` of Windows.&#10;&#10;---&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hwrng.py&lt;/summary&gt;&#10;&#10;## hwrng.py&#10;&#10;&gt; This is not comprehensive at all&#10;&#10;### Features&#10;- Get cryptographically secure random bytes from hardware RNG (RDRAND).&#10;- Raises `HardwareRNGError` if not supported or DLL missing.&#10;&#10;### Usage&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;rb = get_hardware_random_bytes(32)&#10;print(rb.hex())&#10;```&#10;&#10;&lt;/details&gt;&#10;&#10;---&#10;&#10;## Module Overview&#10;&#10;The `hwrng` module provides a Python interface to hardware-based random number generation capabilities through the `MaxRNG` class. This class wraps a native C library that accesses CPU hardware random number generation features (like Intel's RDRAND instruction) to produce high-quality random data with superior entropy compared to software-based PRNGs.&#10;&#10;## MaxRNG Class&#10;&#10;### Class Description&#10;`MaxRNG` is a wrapper class for hardware-based random number generation that interfaces with a native DLL (`hRng_x64.dll` or `hRng_x86.dll` depending on architecture). It automatically detects the system architecture and loads the appropriate binary through the centralized `_loadDLL` module.&#10;&#10;### Initialization&#10;```python&#10;rng = MaxRNG()&#10;```&#10;&#10;When instantiating the class, it performs the following operations:&#10;- Loads the appropriate DLL using the `load_dll` helper function:&#10;  - Determines system architecture (x86/x64) automatically&#10;  - Searches for the appropriate DLL in the standard distribution paths&#10;  - Configures the loader to use `ctypes.WinDLL` specifically for this module&#10;- Sets up ctypes function prototypes and return types for type safety:&#10;  - Defines appropriate argument types for all DLL functions&#10;  - Defines appropriate return types for all DLL functions&#10;&#10;### DLL Loading Details&#10;&#10;The `MaxRNG` class uses the centralized `load_dll` function with these parameters:&#10;- `dll_prefix_name=&quot;hRng&quot;`: Loads either `hRng_x64.dll` or `hRng_x86.dll` based on architecture&#10;- `dll_load_func=ctypes.WinDLL`: Uses WinDLL loader specifically for the Windows API functions used in this module&#10;&#10;The DLL search mechanism looks in these locations by default:&#10;- `./dist/{arch}/hRng_{arch}.dll`&#10;- `../dist/{arch}/hRng_{arch}.dll`&#10;- `../../dist/{arch}/hRng_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;### Methods&#10;&#10;#### `test_rng_available() -&gt; bool`&#10;&#10;Checks if the hardware random number generator is available on the current system.&#10;&#10;**Returns:**&#10;- `True` if hardware RNG is available&#10;- `False` otherwise&#10;&#10;**Implementation Details:**&#10;- Calls the C function `test_rng_available()` in the DLL&#10;- Returns `True` if the function returns `1`, `False` otherwise&#10;- Does not throw exceptions, making it safe to use for feature detection&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_rng_available():&#10;    print(&quot;Hardware RNG is available&quot;)&#10;else:&#10;    print(&quot;Hardware RNG is not available&quot;)&#10;```&#10;&#10;#### `test_threading_available() -&gt; bool`&#10;&#10;Checks if the thread-safe version of the RNG is available.&#10;&#10;**Returns:**&#10;- `True` if thread-safe RNG is available&#10;- `False` otherwise&#10;&#10;**Implementation Details:**&#10;- Calls the C function `test_threading_available()` in the DLL&#10;- Returns `True` if the function returns `1`, `False` otherwise&#10;- Does not throw exceptions, making it safe to use for feature detection&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    print(&quot;Thread-safe RNG is available&quot;)&#10;else:&#10;    print(&quot;Thread-safe RNG is not available&quot;)&#10;```&#10;&#10;#### `maxrng(size: int) -&gt; bytes`&#10;&#10;Generates random bytes using the hardware RNG.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Implementation Details:**&#10;- Allocates a buffer of specified size using `ctypes.c_ubyte * size`&#10;- Calls the C function `maxrng` with the buffer and size&#10;- Checks the return value for success (non-zero)&#10;- Converts the ctypes buffer to Python bytes before returning&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng(32)  # Generate 32 random bytes&#10;```&#10;&#10;#### `maxrng_ultra(size: int, complexity: int) -&gt; bytes`&#10;&#10;Generates random bytes with additional complexity for enhanced security.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;- `complexity` (int): Level of additional entropy mixing (higher values provide potentially better randomness but slower performance)&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Implementation Details:**&#10;- Allocates a buffer of specified size using `ctypes.c_ubyte * size`&#10;- Calls the C function `maxrng_ultra` with the buffer, size, and complexity level&#10;- Checks the return value for success (non-zero)&#10;- Converts the ctypes buffer to Python bytes before returning&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng_ultra(32, 3)  # Generate 32 random bytes with complexity level 3&#10;```&#10;&#10;#### `maxrng_threadsafe(size: int) -&gt; bytes`&#10;&#10;Thread-safe version of the random number generator.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If threading is not available or if the RNG operation fails&#10;&#10;**Implementation Details:**&#10;- First checks if threading is available by calling `test_threading_available()`&#10;- If not available, raises a detailed RuntimeError with best practices advice&#10;- Allocates a buffer of specified size using `ctypes.c_ubyte * size`&#10;- Calls the C function `maxrng_threadsafe` with the buffer and size&#10;- Checks the return value for success (non-zero)&#10;- Converts the ctypes buffer to Python bytes before returning&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    random_data = rng.maxrng_threadsafe(32)  # Generate 32 random bytes in thread-safe mode&#10;```&#10;&#10;### Error Handling&#10;&#10;The class implements comprehensive error handling:&#10;&#10;- **Feature Detection**: Non-throwing methods `test_rng_available()` and `test_threading_available()` for safely detecting capabilities&#10;- **Operation Validation**: All generator methods check return values and raise descriptive exceptions&#10;- **Threading Safety Check**: The `maxrng_threadsafe()` method validates threading availability before attempting operations&#10;- **Detailed Error Messages**: Clear error messages when operations fail, including best practices advice&#10;&#10;### Memory Management&#10;&#10;The class handles all memory allocation and deallocation for the buffer used to store random data, ensuring no memory leaks occur during operation:&#10;&#10;- Uses properly sized ctypes buffers for each operation&#10;- Converts C buffers to Python bytes objects which are managed by Python's garbage collector&#10;- Ensures C memory is properly released after each operation&#10;&#10;## Usage Best Practices&#10;&#10;1. **Always check availability before use:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_rng_available():&#10;       # Proceed with RNG operations&#10;   ```&#10;&#10;2. **For thread-safe operations:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_threading_available():&#10;       # Proceed with thread-safe RNG operations&#10;   ```&#10;&#10;3. **Handle potential exceptions:**&#10;   ```python&#10;   try:&#10;       random_data = rng.maxrng(32)&#10;   except RuntimeError as e:&#10;       # Handle failure&#10;   ```&#10;&#10;4. **Choose the appropriate method:**&#10;   - `maxrng()` for standard random number generation&#10;   - `maxrng_ultra()` for higher security requirements&#10;   - `maxrng_threadsafe()` for multithreaded applications&#10;&#10;5. **Performance considerations:**&#10;   - `maxrng()` is the fastest method with basic hardware randomness&#10;   - `maxrng_ultra()` provides enhanced security at the cost of performance&#10;   - Lower complexity values in `maxrng_ultra()` offer better performance with reasonable security&#10;&#10;6. **Reuse the MaxRNG instance:**&#10;   ```python&#10;   # Create once, reuse multiple times&#10;   rng = MaxRNG()&#10;   &#10;   # Use in multiple places&#10;   data1 = rng.maxrng(32)&#10;   data2 = rng.maxrng(64)&#10;   ```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyCTools/pI.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyCTools/pI.md" />
              <option name="originalContent" value="# Process Inspection (processInspect) Module&#10;&#10;## Module Overview&#10;&#10;The `processInspect` module provides comprehensive process and system metrics collection capabilities through the `ProcessMetrics` class. This class interfaces with a native DLL to collect detailed metrics about Windows processes with minimal performance overhead, offering insights beyond what's available through standard Python libraries.&#10;&#10;## ProcessMetrics Class&#10;&#10;### Class Description&#10;`ProcessMetrics` is a wrapper class that interfaces with the native `processInspect` DLL to collect various system and process metrics on Windows systems. It supports both instant snapshots and time-span measurements for comprehensive performance analysis.&#10;&#10;### Initialization&#10;```python&#10;metrics = ProcessMetrics()&#10;```&#10;When instantiating the class, it:&#10;- Determines system architecture (x86/x64)&#10;- Searches for the appropriate DLL in multiple possible paths&#10;- Loads the DLL using ctypes&#10;- Sets up function prototypes and return types&#10;- Raises `FileNotFoundError` if the DLL cannot be found&#10;&#10;### Constants&#10;&#10;The class provides constants for selecting which metrics to collect:&#10;&#10;| Constant | Value | Description |&#10;|----------|-------|-------------|&#10;| `METRIC_WORKING_SET` | 0x01 | Memory currently in RAM (working set) |&#10;| `METRIC_PRIVATE_BYTES` | 0x02 | Memory exclusively allocated to the process |&#10;| `METRIC_PAGEFILE` | 0x04 | Memory usage in the pagefile |&#10;| `METRIC_HANDLES` | 0x08 | Number of handles open by the process |&#10;| `METRIC_THREADS` | 0x10 | Number of threads in the process |&#10;| `METRIC_CPU_USAGE` | 0x20 | CPU usage percentage |&#10;| `METRIC_IO` | 0x40 | I/O statistics (reads, writes) |&#10;| `METRIC_NET` | 0x80 | Network statistics |&#10;&#10;These constants can be combined using bitwise OR (`|`) to select multiple metrics.&#10;&#10;### Methods&#10;&#10;#### `start_session(pid: int, metrics: int) -&gt; bool`&#10;&#10;Starts a metrics collection session for a specific process.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to monitor&#10;- `metrics` (int): Bitmask of metrics to collect, using class constants&#10;&#10;**Returns:**&#10;- `bool`: `True` if session started successfully, `False` otherwise&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;success = pm.start_session(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;)&#10;```&#10;&#10;#### `end_session(pid: int, metrics: int) -&gt; dict`&#10;&#10;Ends a previously started metrics collection session and retrieves results.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID of the session to end&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Metrics collected during the session, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;# Start session first&#10;pm.start_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;# ... do some work ...&#10;# End session and get results&#10;results = pm.end_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;```&#10;&#10;#### `get_snapshot(pid: int, metrics: int) -&gt; dict`&#10;&#10;Retrieves an instant snapshot of metrics for a process without starting a session.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to query&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Current metrics snapshot, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;snapshot = pm.get_snapshot(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | &#10;    ProcessMetrics.METRIC_WORKING_SET | &#10;    ProcessMetrics.METRIC_HANDLES&#10;)&#10;```&#10;&#10;### Return Value Structure&#10;&#10;All methods that return metrics provide a dictionary with the following structure (keys present depend on requested metrics):&#10;&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,                    // Process ID&#10;  &quot;name&quot;: &quot;example.exe&quot;,          // Process name&#10;  &quot;timestamp&quot;: 1629384756,        // Unix timestamp&#10;  &quot;duration&quot;: 5.23,               // Duration in seconds (for session metrics)&#10;  &quot;cpu_usage&quot;: {                  // If METRIC_CPU_USAGE requested&#10;    &quot;percent&quot;: 14.5,              // CPU usage percentage&#10;    &quot;kernel_time&quot;: 0.234,         // Time spent in kernel mode (seconds)&#10;    &quot;user_time&quot;: 1.456            // Time spent in user mode (seconds)&#10;  },&#10;  &quot;memory&quot;: {                     // Memory metrics&#10;    &quot;working_set&quot;: 123456789,     // If METRIC_WORKING_SET requested (bytes)&#10;    &quot;private_bytes&quot;: 98765432,    // If METRIC_PRIVATE_BYTES requested (bytes)&#10;    &quot;pagefile&quot;: 45678912          // If METRIC_PAGEFILE requested (bytes)&#10;  },&#10;  &quot;handles&quot;: 345,                 // If METRIC_HANDLES requested&#10;  &quot;threads&quot;: 12,                  // If METRIC_THREADS requested&#10;  &quot;io&quot;: {                         // If METRIC_IO requested&#10;    &quot;reads&quot;: 1234,                // Number of read operations&#10;    &quot;writes&quot;: 5678,               // Number of write operations&#10;    &quot;bytes_read&quot;: 12345678,       // Total bytes read&#10;    &quot;bytes_written&quot;: 87654321     // Total bytes written&#10;  },&#10;  &quot;network&quot;: {                    // If METRIC_NET requested&#10;    &quot;bytes_sent&quot;: 123456,         // Total bytes sent&#10;    &quot;bytes_received&quot;: 654321      // Total bytes received&#10;  }&#10;}&#10;```&#10;&#10;### Implementation Details&#10;&#10;#### DLL Loading&#10;The class implements a DLL search mechanism that looks in multiple relative paths:&#10;- `./dist/{arch}/processInspect_{arch}.dll`&#10;- `../dist/{arch}/processInspect_{arch}.dll`&#10;- `../../dist/{arch}/processInspect_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;#### Internal Helper Methods&#10;`_json_call(func, pid, metrics)`: Internal helper method that calls DLL functions returning JSON data, handles the buffer, parses the JSON, and returns the result as a Python dictionary.&#10;&#10;#### Error Handling&#10;All methods perform proper error checking and raise appropriate exceptions with detailed error messages when operations fail.&#10;&#10;## Usage Best Practices&#10;&#10;### Selecting the Right Method&#10;&#10;- **For a single point-in-time measurement:**&#10;  ```python&#10;  snapshot = metrics.get_snapshot(pid, metrics_flags)&#10;  ```&#10;&#10;- **For measuring performance over time:**&#10;  ```python&#10;  metrics.start_session(pid, metrics_flags)&#10;  # ... time passes ...&#10;  results = metrics.end_session(pid, metrics_flags)&#10;  ```&#10;&#10;### Efficient Metric Collection&#10;&#10;Combine only the metrics you need to minimize overhead:&#10;&#10;```python&#10;# Only collect CPU and memory metrics&#10;flags = ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;```&#10;&#10;### Error Handling&#10;&#10;Always handle potential errors:&#10;&#10;```python&#10;try:&#10;    results = metrics.get_snapshot(pid, metrics_flags)&#10;except (RuntimeError, FileNotFoundError) as e:&#10;    print(f&quot;Error collecting metrics: {e}&quot;)&#10;```&#10;&#10;### Performance Monitoring Example&#10;&#10;```python&#10;import time&#10;from pyCTools import ProcessMetrics&#10;&#10;def monitor_process(pid, duration_seconds=60, interval_seconds=5):&#10;    metrics = ProcessMetrics()&#10;    flags = (ProcessMetrics.METRIC_CPU_USAGE | &#10;             ProcessMetrics.METRIC_WORKING_SET | &#10;             ProcessMetrics.METRIC_PRIVATE_BYTES)&#10;    &#10;    end_time = time.time() + duration_seconds&#10;    &#10;    while time.time() &lt; end_time:&#10;        try:&#10;            snapshot = metrics.get_snapshot(pid, flags)&#10;            print(f&quot;CPU: {snapshot['cpu_usage']['percent']}%, &quot;&#10;                  f&quot;Memory: {snapshot['memory']['working_set'] / (1024*1024):.2f} MB&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error: {e}&quot;)&#10;        &#10;        time.sleep(interval_seconds)&#10;```&#10;&#10;" />
              <option name="updatedContent" value="# Process Inspection (processInspect) Module&#10;&#10;## Module Overview&#10;&#10;The `processInspect` module provides comprehensive process and system metrics collection capabilities through the `ProcessMetrics` class. This class interfaces with a native DLL to collect detailed metrics about Windows processes with minimal performance overhead, offering insights beyond what's available through standard Python libraries.&#10;&#10;## ProcessMetrics Class&#10;&#10;### Class Description&#10;`ProcessMetrics` is a wrapper class that interfaces with the native `processInspect` DLL to collect various system and process metrics on Windows systems. It supports both instant snapshots and time-span measurements for comprehensive performance analysis.&#10;&#10;### Initialization&#10;```python&#10;metrics = ProcessMetrics()&#10;```&#10;&#10;When instantiating the class, it:&#10;- Loads the appropriate DLL using the `load_dll` helper function:&#10;  - Determines system architecture (x86/x64) automatically&#10;  - Searches for the appropriate DLL in the standard distribution paths&#10;  - Configures the loader to use `ctypes.CDLL` for this module's functions&#10;- Sets up ctypes function prototypes and return types for type safety:&#10;  - Defines appropriate argument types for all DLL functions&#10;  - Defines appropriate return types for all DLL functions&#10;&#10;### DLL Loading Details&#10;&#10;The `ProcessMetrics` class uses the centralized `load_dll` function with these parameters:&#10;- `dll_prefix_name=&quot;processInspect&quot;`: Loads either `processInspect_x64.dll` or `processInspect_x86.dll` based on architecture&#10;- `dll_load_func=ctypes.CDLL`: Uses standard CDLL loader for this module's C functions&#10;&#10;The DLL search mechanism looks in these locations by default:&#10;- `./dist/{arch}/processInspect_{arch}.dll`&#10;- `../dist/{arch}/processInspect_{arch}.dll`&#10;- `../../dist/{arch}/processInspect_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;### Constants&#10;&#10;The class provides constants for selecting which metrics to collect:&#10;&#10;| Constant | Value | Description |&#10;|----------|-------|-------------|&#10;| `METRIC_WORKING_SET` | 0x01 | Memory currently in RAM (working set) |&#10;| `METRIC_PRIVATE_BYTES` | 0x02 | Memory exclusively allocated to the process |&#10;| `METRIC_PAGEFILE` | 0x04 | Memory usage in the pagefile |&#10;| `METRIC_HANDLES` | 0x08 | Number of handles open by the process |&#10;| `METRIC_THREADS` | 0x10 | Number of threads in the process |&#10;| `METRIC_CPU_USAGE` | 0x20 | CPU usage percentage |&#10;| `METRIC_IO` | 0x40 | I/O statistics (reads, writes) |&#10;| `METRIC_NET` | 0x80 | Network statistics |&#10;&#10;These constants can be combined using bitwise OR (`|`) to select multiple metrics:&#10;&#10;```python&#10;# Select both CPU usage and working set metrics&#10;metrics_flags = ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;```&#10;&#10;### Methods&#10;&#10;#### `_json_call(func, pid: int, metrics: int, _buffer_size: int = 4096) -&gt; dict`&#10;&#10;Internal helper method that calls a DLL function that returns JSON data in a buffer, parses it, and returns it as a Python dictionary.&#10;&#10;**Parameters:**&#10;- `func` (callable): DLL function to call, which fills a buffer with JSON&#10;- `pid` (int): Process ID to query&#10;- `metrics` (int): Bitmask of metrics flags to request&#10;- `_buffer_size` (int): Size of the buffer to hold JSON data (default 4096 bytes)&#10;&#10;**Returns:**&#10;- `dict`: Parsed JSON metrics&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the DLL function call returns failure&#10;&#10;**Implementation Details:**&#10;- Creates a string buffer of specified size (4KB default)&#10;- Calls the provided DLL function with pid, metrics flags, buffer pointer, and buffer size&#10;- Checks for successful return value&#10;- Decodes the buffer content from UTF-8 to a string&#10;- Parses the JSON string into a Python dictionary&#10;- Returns the parsed dictionary or raises an exception on failure&#10;&#10;#### `start_session(pid: int, metrics: int) -&gt; bool`&#10;&#10;Starts a metrics collection session for a specific process.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to monitor&#10;- `metrics` (int): Bitmask of metrics to collect, using class constants&#10;&#10;**Returns:**&#10;- `bool`: `True` if session started successfully, `False` otherwise&#10;&#10;**Implementation Details:**&#10;- Directly calls the native DLL's `start_metrics_collection` function&#10;- Returns a boolean indicating success or failure&#10;- Does not raise exceptions for failure, allowing for graceful handling by caller&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;success = pm.start_session(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;)&#10;```&#10;&#10;#### `end_session(pid: int, metrics: int) -&gt; dict`&#10;&#10;Ends a previously started metrics collection session and retrieves results.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID of the session to end&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Metrics collected during the session, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Implementation Details:**&#10;- Uses the internal `_json_call` helper to call the `end_metrics_collection` DLL function&#10;- Provides a detailed exception if the operation fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;# Start session first&#10;pm.start_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;# ... do some work ...&#10;# End session and get results&#10;results = pm.end_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;```&#10;&#10;#### `get_snapshot(pid: int, metrics: int) -&gt; dict`&#10;&#10;Retrieves an instant snapshot of metrics for a process without starting a session.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to query&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Current metrics snapshot, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Implementation Details:**&#10;- Uses the internal `_json_call` helper to call the `get_metrics_json` DLL function&#10;- Provides a detailed exception if the operation fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;snapshot = pm.get_snapshot(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | &#10;    ProcessMetrics.METRIC_WORKING_SET | &#10;    ProcessMetrics.METRIC_HANDLES&#10;)&#10;```&#10;&#10;### Return Value Structure&#10;&#10;All methods that return metrics provide a dictionary with the following structure (keys present depend on requested metrics):&#10;&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,                    // Process ID&#10;  &quot;name&quot;: &quot;example.exe&quot;,          // Process name&#10;  &quot;timestamp&quot;: 1629384756,        // Unix timestamp&#10;  &quot;duration&quot;: 5.23,               // Duration in seconds (for session metrics)&#10;  &quot;cpu_usage&quot;: {                  // If METRIC_CPU_USAGE requested&#10;    &quot;percent&quot;: 14.5,              // CPU usage percentage&#10;    &quot;kernel_time&quot;: 0.234,         // Time spent in kernel mode (seconds)&#10;    &quot;user_time&quot;: 1.456            // Time spent in user mode (seconds)&#10;  },&#10;  &quot;memory&quot;: {                     // Memory metrics&#10;    &quot;working_set&quot;: 123456789,     // If METRIC_WORKING_SET requested (bytes)&#10;    &quot;private_bytes&quot;: 98765432,    // If METRIC_PRIVATE_BYTES requested (bytes)&#10;    &quot;pagefile&quot;: 45678912          // If METRIC_PAGEFILE requested (bytes)&#10;  },&#10;  &quot;handles&quot;: 345,                 // If METRIC_HANDLES requested&#10;  &quot;threads&quot;: 12,                  // If METRIC_THREADS requested&#10;  &quot;io&quot;: {                         // If METRIC_IO requested&#10;    &quot;reads&quot;: 1234,                // Number of read operations&#10;    &quot;writes&quot;: 5678,               // Number of write operations&#10;    &quot;bytes_read&quot;: 12345678,       // Total bytes read&#10;    &quot;bytes_written&quot;: 87654321     // Total bytes written&#10;  },&#10;  &quot;network&quot;: {                    // If METRIC_NET requested&#10;    &quot;bytes_sent&quot;: 123456,         // Total bytes sent&#10;    &quot;bytes_received&quot;: 654321      // Total bytes received&#10;  }&#10;}&#10;```&#10;&#10;### Error Handling&#10;&#10;The class implements robust error handling:&#10;&#10;- **Buffer Allocation**: Creates appropriately sized buffers for JSON responses&#10;- **Return Value Checking**: Verifies all DLL function calls succeed&#10;- **Exception Handling**: Raises descriptive RuntimeError with process ID on failure&#10;- **JSON Parsing**: Safely decodes and parses JSON data from the native DLL&#10;&#10;## Usage Best Practices&#10;&#10;### Selecting the Right Method&#10;&#10;- **For a single point-in-time measurement:**&#10;  ```python&#10;  snapshot = metrics.get_snapshot(pid, metrics_flags)&#10;  ```&#10;&#10;- **For measuring performance over time:**&#10;  ```python&#10;  metrics.start_session(pid, metrics_flags)&#10;  # ... time passes ...&#10;  results = metrics.end_session(pid, metrics_flags)&#10;  ```&#10;&#10;### Efficient Metric Collection&#10;&#10;Combine only the metrics you need to minimize overhead:&#10;&#10;```python&#10;# Only collect CPU and memory metrics&#10;flags = ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;```&#10;&#10;### Error Handling&#10;&#10;Always handle potential errors:&#10;&#10;```python&#10;try:&#10;    results = metrics.get_snapshot(pid, metrics_flags)&#10;except (RuntimeError, FileNotFoundError) as e:&#10;    print(f&quot;Error collecting metrics: {e}&quot;)&#10;```&#10;&#10;### Reuse ProcessMetrics Instance&#10;&#10;For efficiency, create a single instance and reuse it:&#10;&#10;```python&#10;# Create once&#10;metrics = ProcessMetrics()&#10;&#10;# Use for multiple operations&#10;metrics.start_session(pid1, flags)&#10;snapshot = metrics.get_snapshot(pid2, flags)&#10;results = metrics.end_session(pid1, flags)&#10;```&#10;&#10;### Performance Monitoring Example&#10;&#10;```python&#10;import time&#10;from pyCTools import ProcessMetrics&#10;&#10;def monitor_process(pid, duration_seconds=60, interval_seconds=5):&#10;    metrics = ProcessMetrics()&#10;    flags = (ProcessMetrics.METRIC_CPU_USAGE | &#10;             ProcessMetrics.METRIC_WORKING_SET | &#10;             ProcessMetrics.METRIC_PRIVATE_BYTES)&#10;    &#10;    end_time = time.time() + duration_seconds&#10;    &#10;    while time.time() &lt; end_time:&#10;        try:&#10;            snapshot = metrics.get_snapshot(pid, flags)&#10;            print(f&quot;CPU: {snapshot['cpu_usage']['percent']}%, &quot;&#10;                  f&quot;Memory: {snapshot['memory']['working_set'] / (1024*1024):.2f} MB&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error: {e}&quot;)&#10;        &#10;        time.sleep(interval_seconds)&#10;```&#10;&#10;### Working with Multiple Processes&#10;&#10;```python&#10;import time&#10;from pyCTools import ProcessMetrics&#10;&#10;def compare_processes(pids, metrics_flags):&#10;    pm = ProcessMetrics()&#10;    results = {}&#10;    &#10;    # Start sessions for all processes&#10;    for pid in pids:&#10;        pm.start_session(pid, metrics_flags)&#10;    &#10;    # Wait for some time&#10;    time.sleep(30)&#10;    &#10;    # End sessions and collect results&#10;    for pid in pids:&#10;        try:&#10;            results[pid] = pm.end_session(pid, metrics_flags)&#10;        except RuntimeError as e:&#10;            results[pid] = f&quot;Error: {e}&quot;&#10;    &#10;    return results&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.h" />
              <option name="updatedContent" value="#ifndef PYCTOOLS_HRNG_H&#10;#define PYCTOOLS_HRNG_H&#10;&#10;#ifdef __cplusplus&#10;extern &quot;C&quot; {&#10;#endif&#10;&#10;/**&#10; * Checks if the CPU supports the RDRAND instruction&#10; * &#10; * @return 1 if supported, 0 if not&#10; */&#10;int has_rdrand(void);&#10;&#10;/**&#10; * Fills a buffer with random bytes using hardware RNG (RDRAND if available)&#10; * &#10; * @param buffer Pointer to buffer to fill with random bytes&#10; * @param size Size of the buffer in bytes&#10; * @return 1 on success, 0 on failure&#10; */&#10;__declspec(dllexport)&#10;int read_hwrng(unsigned char* buffer, int size);&#10;&#10;/**&#10; * Maximum security RNG that uses multiple entropy sources:&#10; * - Hardware RNG (RDRAND)&#10; * - CPU information and timings&#10; * - Audio input (microphone)&#10; * - Battery/power status&#10; * - Memory and process statistics&#10; * - Network statistics&#10; * - Performance counters&#10; * &#10; * The entropy is mixed using cryptographic algorithms.&#10; * &#10; * @param buffer Pointer to buffer to fill with random bytes&#10; * @param size Size of the buffer in bytes&#10; * @return 1 on success, 0 on failure&#10; */&#10;__declspec(dllexport)&#10;int MaxRNG(unsigned char* buffer, int size);&#10;&#10;#ifdef __cplusplus&#10;}&#10;#endif&#10;&#10;#endif // PYCTOOLS_HRNG_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.md" />
              <option name="originalContent" value="# Hardware Random Number Generator (hRng)&#10;&#10;The `/dev/urandom/` of Windows.&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hRng.c&lt;/summary&gt;&#10;&#10;## hRng.c&#10;&#10;Implements a hardware random number generator using the RDRAND instruction (if supported by the CPU).&#10;&#10;### Key Function&#10;- `int read_hwrng(unsigned char* buffer, int size)`&#10;    - Fills `buffer` with `size` random bytes from the hardware RNG.&#10;    - Returns 1 on success, 0 if RDRAND is not supported or fails.&#10;    - Exported for use by Python via ctypes.&#10;&#10;### Notes&#10;- Checks for RDRAND support using CPUID.&#10;- Used by `pyCTools.hwrng`.&#10;&lt;/details&gt;&#10;&#10;## Overview&#10;&#10;The Hardware Random Number Generator (hRng) is a high-security random number generation library designed for Windows systems. It provides cryptographically secure random numbers by combining multiple entropy sources with hardware-based random number generation when available.&#10;&#10;## Key Features&#10;&#10;- Hardware-accelerated random number generation using Intel RDRAND instruction (when available)&#10;- Multiple entropy sources for enhanced security:&#10;  - CPU-specific entropy (RDTSC, CPUID)&#10;  - System performance metrics (timing, memory usage, disk I/O)&#10;  - Audio data from microphone&#10;  - Battery and power status information&#10;  - Network statistics&#10;- Secure entropy mixing using SHA-256&#10;- Thread-safe operation&#10;- Self-testing capabilities&#10;- Fallback mechanisms when primary sources fail&#10;- Multiple security levels with extended entropy gathering&#10;&#10;## API Reference&#10;&#10;### Basic Functions&#10;&#10;#### `int has_rdrand()`&#10;Detects if the CPU supports the RDRAND instruction.&#10;&#10;**Returns:**&#10;- `1` if RDRAND is supported&#10;- `0` if RDRAND is not supported&#10;&#10;#### `int read_hwrng(unsigned char* buffer, const int size)`&#10;Fills a buffer with random data using hardware RNG (RDRAND) with retry logic.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int MaxRNG(unsigned char* buffer, const int size)`&#10;The primary RNG function that combines multiple entropy sources.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int MaxRNG_ThreadSafe(unsigned char* buffer, const int size)`&#10;Thread-safe wrapper for MaxRNG.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;### Advanced Functions&#10;&#10;#### `int MaxRNG_Extended(unsigned char* buffer, const int size, const int intensive_level)`&#10;Enhanced random number generation with configurable intensity level.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;- `intensive_level`: Level of entropy gathering intensity (1-5):&#10;  - `1`: Standard MaxRNG operation&#10;  - `2`: Additional CPU jitter entropy&#10;  - `3+`: Maximum entropy gathering from all available sources&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int RNG_SelfTest(void)`&#10;Self-diagnostic function to verify RNG functionality.&#10;&#10;**Returns:**&#10;- `1` if all tests pass&#10;- `0` if any test fails&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*MaxRNG_Func)(unsigned char*, int);&#10;typedef int (*RNG_SelfTest_Func)(void);&#10;&#10;int main() {&#10;    // Load the DLL&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    // Get function pointers&#10;    MaxRNG_Func MaxRNG = (MaxRNG_Func)GetProcAddress(hRngDll, &quot;MaxRNG&quot;);&#10;    RNG_SelfTest_Func RNG_SelfTest = (RNG_SelfTest_Func)GetProcAddress(hRngDll, &quot;RNG_SelfTest&quot;);&#10;    &#10;    if (!MaxRNG || !RNG_SelfTest) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Run self-test&#10;    if (!RNG_SelfTest()) {&#10;        printf(&quot;RNG self-test failed\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate random bytes&#10;    unsigned char buffer[32] = {0};&#10;    if (MaxRNG(buffer, sizeof(buffer))) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;        }&#10;        printf(&quot;\n&quot;);&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Thread-Safe Usage&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_ThreadSafe_Func)(unsigned char*, int);&#10;&#10;DWORD WINAPI ThreadFunc(LPVOID lpParam) {&#10;    MaxRNG_ThreadSafe_Func MaxRNG_ThreadSafe = (MaxRNG_ThreadSafe_Func)lpParam;&#10;    &#10;    unsigned char buffer[16] = {0};&#10;    int result = MaxRNG_ThreadSafe(buffer, sizeof(buffer));&#10;    &#10;    // Print thread ID and result&#10;    printf(&quot;Thread %lu: %s\n&quot;, GetCurrentThreadId(), &#10;           result ? &quot;Success&quot; : &quot;Failed&quot;);&#10;           &#10;    return 0;&#10;}&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_ThreadSafe_Func MaxRNG_ThreadSafe = &#10;        (MaxRNG_ThreadSafe_Func)GetProcAddress(hRngDll, &quot;MaxRNG_ThreadSafe&quot;);&#10;    &#10;    if (!MaxRNG_ThreadSafe) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Create multiple threads to test thread safety&#10;    HANDLE threads[5];&#10;    for (int i = 0; i &lt; 5; i++) {&#10;        threads[i] = CreateThread(NULL, 0, ThreadFunc, &#10;                                 (LPVOID)MaxRNG_ThreadSafe, 0, NULL);&#10;    }&#10;    &#10;    // Wait for all threads to complete&#10;    WaitForMultipleObjects(5, threads, TRUE, INFINITE);&#10;    &#10;    for (int i = 0; i &lt; 5; i++) {&#10;        CloseHandle(threads[i]);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Using MaxRNG_Extended for Maximum Security&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_Extended_Func)(unsigned char*, int, int);&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_Extended_Func MaxRNG_Extended = &#10;        (MaxRNG_Extended_Func)GetProcAddress(hRngDll, &quot;MaxRNG_Extended&quot;);&#10;    &#10;    if (!MaxRNG_Extended) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate high-security random bytes (intensity level 5)&#10;    unsigned char buffer[64] = {0};&#10;    printf(&quot;Generating high-entropy random bytes...\n&quot;);&#10;    &#10;    if (MaxRNG_Extended(buffer, sizeof(buffer), 5)) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;            if ((i + 1) % 16 == 0) printf(&quot;\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Entropy Sources&#10;&#10;The library collects entropy from multiple sources:&#10;&#10;1. **Hardware RNG (RDRAND)**&#10;   - Uses Intel's RDRAND instruction when available&#10;   - Implements retry logic for reliability&#10;&#10;2. **CPU-specific Sources**&#10;   - RDTSC (Read Time-Stamp Counter)&#10;   - CPUID information&#10;&#10;3. **System Performance Metrics**&#10;   - Process memory information&#10;   - CPU timing information&#10;   - Disk I/O statistics&#10;   - High-precision performance counters&#10;&#10;4. **Audio Data**&#10;   - Samples microphone input&#10;   - Falls back to timing data if no microphone is available&#10;&#10;5. **Battery/Power Information**&#10;   - Battery state and charge levels&#10;   - Power status information&#10;&#10;6. **Network Statistics**&#10;   - TCP/IP statistics&#10;   - Network adapter information&#10;&#10;### Entropy Mixing&#10;&#10;All entropy sources are securely combined using SHA-256 through the Windows BCrypt API to ensure:&#10;&#10;- Uniform distribution of random bits&#10;- High entropy density&#10;- Protection against predictability attacks&#10;&#10;### Security Considerations&#10;&#10;- The library securely zeroes memory containing sensitive data using SecureZeroMemory&#10;- Multiple fallback mechanisms ensure reliability when primary entropy sources fail&#10;- Thread synchronization protects against race conditions in multi-threaded environments&#10;- Self-test functionality verifies proper operation before use&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - winmm.lib&#10;  - bcrypt.lib&#10;  - iphlpapi.lib&#10;  - psapi.lib&#10;  - powrprof.lib&#10;&#10;### Linking with Your Application&#10;&#10;When compiling your application, make sure to include the appropriate header file and link against the hRng.dll library.&#10;&#10;#### Static Linking&#10;&#10;```c&#10;#pragma comment(lib, &quot;hRng.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;if (hRngDll) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```&#10;" />
              <option name="updatedContent" value="# Hardware Random Number Generator (hRng)&#10;&#10;The `/dev/urandom/` of Windows.&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hRng.c&lt;/summary&gt;&#10;&#10;## hRng.c&#10;&#10;Implements a hardware random number generator using the RDRAND instruction (if supported by the CPU).&#10;&#10;### Key Function&#10;- `int read_hwrng(unsigned char* buffer, int size)`&#10;    - Fills `buffer` with `size` random bytes from the hardware RNG.&#10;    - Returns 1 on success, 0 if RDRAND is not supported or fails.&#10;    - Exported for use by Python via ctypes.&#10;&#10;### Notes&#10;- Checks for RDRAND support using CPUID.&#10;- Used by `pyCTools.hwrng`.&#10;&lt;/details&gt;&#10;&#10;## Overview&#10;&#10;The Hardware Random Number Generator (hRng) is a high-security random number generation library designed for Windows systems. It provides cryptographically secure random numbers by combining multiple entropy sources with hardware-based random number generation when available.&#10;&#10;## Key Features&#10;&#10;- Hardware-accelerated random number generation using Intel RDRAND instruction (when available)&#10;- Multiple entropy sources for enhanced security:&#10;  - CPU-specific entropy (RDTSC, CPUID)&#10;  - System performance metrics (timing, memory usage)&#10;  - Process memory information&#10;  - Disk space statistics&#10;  - Network adapter and TCP statistics&#10;  - Battery and power status information&#10;- Secure entropy mixing using SHA-256 via Windows BCrypt API&#10;- Thread-safe operation with proper synchronization&#10;- Configurable complexity levels for enhanced security&#10;- Fallback mechanisms when hardware RNG is unavailable&#10;&#10;## API Reference&#10;&#10;### Basic Functions&#10;&#10;#### `int test_rng_available(void)`&#10;Detects if the CPU supports the RDRAND instruction.&#10;&#10;**Returns:**&#10;- `1` if RDRAND is supported&#10;- `0` if RDRAND is not supported&#10;&#10;#### `int test_threading_available(void)`&#10;Checks if threading primitives are initialized.&#10;&#10;**Returns:**&#10;- `1` if threading primitives are initialized&#10;- `0` otherwise&#10;&#10;#### `int maxrng(unsigned char* buffer, const int size)`&#10;The primary RNG function that combines multiple entropy sources with basic complexity.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `void maxrng_init(void)`&#10;Initializes threading primitives for thread-safe operation.&#10;&#10;**Returns:**&#10;- None&#10;&#10;#### `int maxrng_threadsafe(unsigned char* buffer, const int size)`&#10;Thread-safe wrapper for the RNG function.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;### Advanced Functions&#10;&#10;#### `int maxrng_ultra(unsigned char* buffer, const int size, int complexity)`&#10;Enhanced random number generation with configurable complexity level.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;- `complexity`: Level of entropy gathering intensity (1-10):&#10;  - Higher values increase the number of entropy gathering rounds&#10;  - Values are automatically clamped between 1 and 10&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*MaxRNG_Func)(unsigned char*, int);&#10;typedef int (*RngAvailable_Func)(void);&#10;&#10;int main() {&#10;    // Load the DLL&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    // Get function pointers&#10;    MaxRNG_Func rng = (MaxRNG_Func)GetProcAddress(hRngDll, &quot;maxrng&quot;);&#10;    RngAvailable_Func rngAvailable = (RngAvailable_Func)GetProcAddress(hRngDll, &quot;test_rng_available&quot;);&#10;    &#10;    if (!rng || !rngAvailable) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Check if hardware RNG is available&#10;    printf(&quot;Hardware RNG available: %s\n&quot;, rngAvailable() ? &quot;Yes&quot; : &quot;No&quot;);&#10;    &#10;    // Generate random bytes&#10;    unsigned char buffer[32] = {0};&#10;    if (rng(buffer, sizeof(buffer))) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;        }&#10;        printf(&quot;\n&quot;);&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Thread-Safe Usage&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef void (*Init_Func)(void);&#10;typedef int (*ThreadSafe_RNG_Func)(unsigned char*, int);&#10;&#10;DWORD WINAPI ThreadFunc(LPVOID lpParam) {&#10;    ThreadSafe_RNG_Func rng = (ThreadSafe_RNG_Func)lpParam;&#10;    &#10;    unsigned char buffer[16] = {0};&#10;    int result = rng(buffer, sizeof(buffer));&#10;    &#10;    // Print thread ID and result&#10;    printf(&quot;Thread %lu: %s\n&quot;, GetCurrentThreadId(), &#10;           result ? &quot;Success&quot; : &quot;Failed&quot;);&#10;           &#10;    return 0;&#10;}&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    Init_Func init = (Init_Func)GetProcAddress(hRngDll, &quot;maxrng_init&quot;);&#10;    ThreadSafe_RNG_Func threadSafeRng = &#10;        (ThreadSafe_RNG_Func)GetProcAddress(hRngDll, &quot;maxrng_threadsafe&quot;);&#10;    &#10;    if (!init || !threadSafeRng) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Initialize threading primitives&#10;    init();&#10;    &#10;    // Create multiple threads to test thread safety&#10;    HANDLE threads[5];&#10;    for (int i = 0; i &lt; 5; i++) {&#10;        threads[i] = CreateThread(NULL, 0, ThreadFunc, &#10;                                 (LPVOID)threadSafeRng, 0, NULL);&#10;    }&#10;    &#10;    // Wait for all threads to complete&#10;    WaitForMultipleObjects(5, threads, TRUE, INFINITE);&#10;    &#10;    for (int i = 0; i &lt; 5; i++) {&#10;        CloseHandle(threads[i]);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Using Ultra Mode for Maximum Security&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_Ultra_Func)(unsigned char*, int, int);&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_Ultra_Func ultraRng = &#10;        (MaxRNG_Ultra_Func)GetProcAddress(hRngDll, &quot;maxrng_ultra&quot;);&#10;    &#10;    if (!ultraRng) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate high-security random bytes (complexity level 10)&#10;    unsigned char buffer[64] = {0};&#10;    printf(&quot;Generating high-entropy random bytes...\n&quot;);&#10;    &#10;    if (ultraRng(buffer, sizeof(buffer), 10)) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;            if ((i + 1) % 16 == 0) printf(&quot;\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Entropy Sources&#10;&#10;The library collects entropy from multiple sources:&#10;&#10;1. **Hardware RNG (RDRAND)**&#10;   - Uses Intel's RDRAND instruction when available&#10;   - Implements retry logic for reliability (up to 10 retries)&#10;&#10;2. **CPU-specific Sources**&#10;   - RDTSC (Read Time-Stamp Counter)&#10;   - CPUID information&#10;&#10;3. **System Performance Metrics**&#10;   - Process memory information via GetProcessMemoryInfo&#10;   - High-precision performance counters via QueryPerformanceCounter&#10;&#10;4. **Storage Information**&#10;   - Disk free space statistics via GetDiskFreeSpaceEx&#10;&#10;5. **Audio Timing**&#10;   - Timing-based entropy collection with sleep intervals&#10;   - Used as a fallback entropy source&#10;&#10;6. **Battery/Power Information**&#10;   - System power status via GetSystemPowerStatus&#10;&#10;7. **Network Statistics**&#10;   - TCP statistics via GetTcpStatistics&#10;   - Network adapter information via GetAdaptersInfo&#10;&#10;### Entropy Mixing&#10;&#10;All entropy sources are securely combined using SHA-256 through the Windows BCrypt API:&#10;&#10;- Multiple rounds of hashing based on the complexity parameter&#10;- Secure handling of hash state between rounds&#10;- Proper cleanup of cryptographic resources&#10;&#10;### Thread Safety&#10;&#10;- Uses Windows critical sections for thread synchronization&#10;- Initialization of threading primitives via maxrng_init()&#10;- Thread-safe API via maxrng_threadsafe()&#10;&#10;### Security Considerations&#10;&#10;- Multiple fallback mechanisms ensure reliability when hardware RNG is unavailable&#10;- Complexity parameter allows for trading off performance vs. security&#10;- Clean error handling with proper resource cleanup&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - bcrypt.lib&#10;  - winmm.lib&#10;  - iphlpapi.lib&#10;  - psapi.lib&#10;&#10;### Linking with Your Application&#10;&#10;When compiling your application, make sure to link against the required libraries:&#10;&#10;```c&#10;#pragma comment(lib, &quot;bcrypt.lib&quot;)&#10;#pragma comment(lib, &quot;winmm.lib&quot;)&#10;#pragma comment(lib, &quot;iphlpapi.lib&quot;)&#10;#pragma comment(lib, &quot;psapi.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;if (hRngDll) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/processInspect.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/processInspect.md" />
              <option name="updatedContent" value="# Process Inspection Module (processInspect)&#10;&#10;## Overview&#10;&#10;The Process Inspection Module provides powerful, low-level access to Windows process metrics and performance data. This library allows applications to monitor process resource usage with minimal overhead, supporting both instantaneous measurements and differential metrics over specified time periods.&#10;&#10;## Key Features&#10;&#10;- Low-overhead process monitoring&#10;- Memory usage metrics (working set, private bytes, pagefile usage)&#10;- Process resource tracking (handles, threads)&#10;- CPU utilization measurement&#10;- I/O operations monitoring (read/write)&#10;- Support for both snapshot and time-interval measurements&#10;- JSON-formatted output for easy integration&#10;- Customizable metrics selection&#10;&#10;## API Reference&#10;&#10;### Constants&#10;&#10;#### Metrics Flags&#10;&#10;The following constants are used to specify which metrics to collect:&#10;&#10;```c&#10;#define METRIC_WORKING_SET   0x01  // Process working set size&#10;#define METRIC_PRIVATE_BYTES 0x02  // Private memory usage&#10;#define METRIC_PAGEFILE      0x04  // Pagefile usage&#10;#define METRIC_HANDLES       0x08  // Handle count&#10;#define METRIC_THREADS       0x10  // Thread count&#10;#define METRIC_CPU_USAGE     0x20  // CPU usage percentage&#10;#define METRIC_IO            0x40  // I/O read/write operations&#10;#define METRIC_NET           0x80  // Network usage (when implemented)&#10;```&#10;&#10;### Functions&#10;&#10;#### `int get_metrics_json(DWORD pid, DWORD metrics, char *json_buf, size_t json_buflen)`&#10;&#10;Takes an instantaneous snapshot of the specified process metrics.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID to monitor&#10;- `metrics`: Bitwise combination of METRIC_* flags indicating which metrics to collect&#10;- `json_buf`: Output buffer where the JSON-formatted metrics will be written&#10;- `json_buflen`: Size of the output buffer&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure (invalid process, insufficient permissions, buffer too small)&#10;&#10;**JSON Output Format:**&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,&#10;  &quot;working_set_kb&quot;: 45678,&#10;  &quot;private_kb&quot;: 34567,&#10;  &quot;pagefile_kb&quot;: 23456,&#10;  &quot;handles&quot;: 345,&#10;  &quot;threads&quot;: 12,&#10;  &quot;cpu&quot;: 3.45,&#10;  &quot;io_read_kb&quot;: 1234,&#10;  &quot;io_write_kb&quot;: 5678&#10;}&#10;```&#10;&#10;#### `int start_metrics_collection(DWORD pid, DWORD metrics)`&#10;&#10;Begins collecting metrics for a process over a time period. Must be paired with a later call to `end_metrics_collection()`.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID to monitor&#10;- `metrics`: Bitwise combination of METRIC_* flags indicating which metrics to collect&#10;&#10;**Returns:**&#10;- `1` if collection successfully started&#10;- `0` on failure (invalid process, insufficient permissions)&#10;&#10;#### `int end_metrics_collection(DWORD pid, DWORD metrics, char *json_buf, size_t json_buflen)`&#10;&#10;Ends metrics collection and calculates differentials for the time period since `start_metrics_collection()` was called.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID (must match the one used in `start_metrics_collection()`)&#10;- `metrics`: Bitwise combination of METRIC_* flags (must match the ones used in `start_metrics_collection()`)&#10;- `json_buf`: Output buffer where the JSON-formatted metrics will be written&#10;- `json_buflen`: Size of the output buffer&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure (invalid process, metrics mismatch, insufficient permissions, buffer too small)&#10;&#10;**Notes:**&#10;- CPU and I/O metrics are reported as deltas between start and end collection&#10;- Memory metrics are instantaneous values at the time of call&#10;&#10;## Usage Examples&#10;&#10;### Taking a Snapshot of Process Metrics&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*GetMetricsJson_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;int main() {&#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    GetMetricsJson_Func GetMetricsJson = &#10;        (GetMetricsJson_Func)GetProcAddress(hModule, &quot;get_metrics_json&quot;);&#10;    &#10;    if (!GetMetricsJson) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = 1234; // Replace with actual PID&#10;    const DWORD metrics = METRIC_WORKING_SET | METRIC_PRIVATE_BYTES | &#10;                         METRIC_HANDLES | METRIC_CPU_USAGE;&#10;    &#10;    char json_buffer[1024] = {0};&#10;    &#10;    if (GetMetricsJson(pid, metrics, json_buffer, sizeof(json_buffer))) {&#10;        printf(&quot;Process metrics: %s\n&quot;, json_buffer);&#10;    } else {&#10;        printf(&quot;Failed to get process metrics\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Measuring Process Metrics Over Time&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*StartMetricsCollection_Func)(DWORD, DWORD);&#10;typedef int (*EndMetricsCollection_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;int main() {&#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    StartMetricsCollection_Func StartMetricsCollection = &#10;        (StartMetricsCollection_Func)GetProcAddress(hModule, &quot;start_metrics_collection&quot;);&#10;    &#10;    EndMetricsCollection_Func EndMetricsCollection = &#10;        (EndMetricsCollection_Func)GetProcAddress(hModule, &quot;end_metrics_collection&quot;);&#10;    &#10;    if (!StartMetricsCollection || !EndMetricsCollection) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = 1234; // Replace with actual PID&#10;    const DWORD metrics = METRIC_CPU_USAGE | METRIC_IO;&#10;    &#10;    if (StartMetricsCollection(pid, metrics)) {&#10;        printf(&quot;Started metrics collection. Monitoring for 5 seconds...\n&quot;);&#10;        &#10;        // Wait for a period to collect metrics&#10;        Sleep(5000);&#10;        &#10;        char json_buffer[1024] = {0};&#10;        if (EndMetricsCollection(pid, metrics, json_buffer, sizeof(json_buffer))) {&#10;            printf(&quot;Process metrics over 5 seconds: %s\n&quot;, json_buffer);&#10;        } else {&#10;            printf(&quot;Failed to end metrics collection\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to start metrics collection\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Complete Example with All Metrics&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*StartMetricsCollection_Func)(DWORD, DWORD);&#10;typedef int (*EndMetricsCollection_Func)(DWORD, DWORD, char*, size_t);&#10;typedef int (*GetMetricsJson_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;// Metrics flags&#10;#define METRIC_WORKING_SET   0x01&#10;#define METRIC_PRIVATE_BYTES 0x02&#10;#define METRIC_PAGEFILE      0x04&#10;#define METRIC_HANDLES       0x08&#10;#define METRIC_THREADS       0x10&#10;#define METRIC_CPU_USAGE     0x20&#10;#define METRIC_IO            0x40&#10;#define METRIC_NET           0x80&#10;&#10;int main(int argc, char* argv[]) {&#10;    if (argc &lt; 2) {&#10;        printf(&quot;Usage: %s &lt;PID&gt;\n&quot;, argv[0]);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = (DWORD)atoi(argv[1]);&#10;    &#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    StartMetricsCollection_Func StartMetricsCollection = &#10;        (StartMetricsCollection_Func)GetProcAddress(hModule, &quot;start_metrics_collection&quot;);&#10;    &#10;    EndMetricsCollection_Func EndMetricsCollection = &#10;        (EndMetricsCollection_Func)GetProcAddress(hModule, &quot;end_metrics_collection&quot;);&#10;    &#10;    GetMetricsJson_Func GetMetricsJson = &#10;        (GetMetricsJson_Func)GetProcAddress(hModule, &quot;get_metrics_json&quot;);&#10;    &#10;    if (!StartMetricsCollection || !EndMetricsCollection || !GetMetricsJson) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    // All available metrics&#10;    const DWORD all_metrics = METRIC_WORKING_SET | METRIC_PRIVATE_BYTES | &#10;                             METRIC_PAGEFILE | METRIC_HANDLES | METRIC_THREADS | &#10;                             METRIC_CPU_USAGE | METRIC_IO;&#10;    &#10;    // First, take an instant snapshot&#10;    char json_buffer[1024] = {0};&#10;    if (GetMetricsJson(pid, all_metrics, json_buffer, sizeof(json_buffer))) {&#10;        printf(&quot;Instant metrics snapshot:\n%s\n\n&quot;, json_buffer);&#10;    } else {&#10;        printf(&quot;Failed to get instant metrics\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    // Then measure over time&#10;    if (StartMetricsCollection(pid, all_metrics)) {&#10;        printf(&quot;Collecting metrics for 10 seconds...\n&quot;);&#10;        Sleep(10000);&#10;        &#10;        if (EndMetricsCollection(pid, all_metrics, json_buffer, sizeof(json_buffer))) {&#10;            printf(&quot;Metrics over 10 seconds:\n%s\n&quot;, json_buffer);&#10;        } else {&#10;            printf(&quot;Failed to end metrics collection\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to start metrics collection\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Process Metrics Explained&#10;&#10;#### Memory Metrics&#10;&#10;- **Working Set (METRIC_WORKING_SET)**: &#10;  The set of memory pages currently visible to the process in physical RAM. This includes shared and private pages.&#10;&#10;- **Private Bytes (METRIC_PRIVATE_BYTES)**:&#10;  Memory that cannot be shared with other processes. This represents the actual memory cost of the process.&#10;&#10;- **Pagefile Usage (METRIC_PAGEFILE)**:&#10;  The amount of the system page file that is being used by the process. This includes all memory that the process has touched, including pages that are in RAM.&#10;&#10;#### Resource Metrics&#10;&#10;- **Handles (METRIC_HANDLES)**:&#10;  The number of object handles in the process's handle table. This includes files, registry keys, events, etc.&#10;&#10;- **Threads (METRIC_THREADS)**:&#10;  The number of threads currently executing in the process.&#10;&#10;#### Performance Metrics&#10;&#10;- **CPU Usage (METRIC_CPU_USAGE)**:&#10;  Percentage of available CPU time that the process has used. When collected over time, this represents the average usage during that period.&#10;&#10;- **I/O Operations (METRIC_IO)**:&#10;  Total bytes read from and written to the disk by the process. When collected over time, this represents the bytes transferred during that period.&#10;&#10;### Implementation Details&#10;&#10;- The library uses Windows Performance Data Helper (PDH) and Process Status API (PSAPI) to collect metrics&#10;- Thread synchronization is implemented for metric collection over time&#10;- The implementation uses Windows-specific APIs and is optimized for minimal overhead&#10;- CPU usage calculation takes into account all cores/processors in the system&#10;- All memory metrics are reported in kilobytes (KB)&#10;&#10;### Known Limitations&#10;&#10;- Requires administrator privileges to monitor some processes&#10;- CPU usage metrics may not be 100% accurate for very short-lived processes&#10;- Network metrics are reserved for future implementation (METRIC_NET flag)&#10;- Only supports Windows operating systems&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - psapi.lib&#10;  - iphlpapi.lib&#10;&#10;### Linking with Your Application&#10;&#10;#### Static Linking&#10;&#10;```c&#10;#pragma comment(lib, &quot;processInspect.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;if (hModule) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```&#10;&#10;### Python Integration&#10;&#10;The library can be easily used from Python via ctypes:&#10;&#10;```python&#10;import ctypes&#10;from ctypes import c_int, c_ulong, c_char_p, c_size_t&#10;&#10;# Load the DLL&#10;process_inspect = ctypes.CDLL(&quot;processInspect.dll&quot;)&#10;&#10;# Define metrics constants&#10;METRIC_WORKING_SET = 0x01&#10;METRIC_PRIVATE_BYTES = 0x02&#10;METRIC_PAGEFILE = 0x04&#10;METRIC_HANDLES = 0x08&#10;METRIC_THREADS = 0x10&#10;METRIC_CPU_USAGE = 0x20&#10;METRIC_IO = 0x40&#10;METRIC_ALL = 0x7F&#10;&#10;# Define function prototypes&#10;get_metrics_json = process_inspect.get_metrics_json&#10;get_metrics_json.argtypes = [c_ulong, c_ulong, c_char_p, c_size_t]&#10;get_metrics_json.restype = c_int&#10;&#10;# Usage example&#10;def get_process_metrics(pid, metrics=METRIC_ALL):&#10;    buffer = ctypes.create_string_buffer(1024)&#10;    if get_metrics_json(pid, metrics, buffer, len(buffer)):&#10;        return buffer.value.decode('utf-8')&#10;    return None&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import json&#10;    &#10;    pid = 1234  # Replace with actual PID&#10;    metrics_json = get_process_metrics(pid)&#10;    if metrics_json:&#10;        metrics = json.loads(metrics_json)&#10;        print(f&quot;Process {pid} is using {metrics.get('working_set_kb', 0):,} KB of memory&quot;)&#10;        print(f&quot;CPU Usage: {metrics.get('cpu', 0):.2f}%&quot;)&#10;```&#10;&#10;## License and Attribution&#10;&#10;This Process Inspection Module is provided for monitoring and analyzing process performance in Windows environments.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_hrng.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_hrng.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;&#10;DLL_PATH = os.path.join(os.path.dirname(__file__), &quot;src&quot;, &quot;hRng.dll&quot;)&#10;&#10;hrng = ctypes.WinDLL(DLL_PATH)&#10;&#10;# Function prototypes&#10;hrng.MaxRNG.argtypes = [ctypes.c_void_p, ctypes.c_int]&#10;hrng.MaxRNG.restype = ctypes.c_int&#10;&#10;hrng.RNG_SelfTest.restype = ctypes.c_int&#10;&#10;def test_maxrng():&#10;    buf = (ctypes.c_ubyte * 32)()&#10;    result = hrng.MaxRNG(buf, 32)&#10;    print(&quot;MaxRNG result:&quot;, result)&#10;    print(&quot;Random bytes:&quot;, bytes(buf).hex())&#10;&#10;def test_selftest():&#10;    result = hrng.RNG_SelfTest()&#10;    print(&quot;RNG_SelfTest result:&quot;, result)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_selftest()&#10;    test_maxrng()&#10;&#10;" />
              <option name="updatedContent" value="oimport ctypes&#10;import os&#10;&#10;DLL_PATH = os.path.join(os.path.dirname(__file__), &quot;src&quot;, &quot;hRng.dll&quot;)&#10;&#10;hrng = ctypes.WinDLL(DLL_PATH)&#10;&#10;# Function prototypes&#10;hrng.MaxRNG.argtypes = [ctypes.c_void_p, ctypes.c_int]&#10;hrng.MaxRNG.restype = ctypes.c_int&#10;&#10;hrng.RNG_SelfTest.restype = ctypes.c_int&#10;&#10;def test_maxrng():&#10;    buf = (ctypes.c_ubyte * 32)()&#10;    result = hrng.MaxRNG(buf, 32)&#10;    print(&quot;MaxRNG result:&quot;, result)&#10;    print(&quot;Random bytes:&quot;, bytes(buf).hex())&#10;&#10;def test_selftest():&#10;    result = hrng.RNG_SelfTest()&#10;    print(&quot;RNG_SelfTest result:&quot;, result)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_selftest()&#10;    test_maxrng()&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>