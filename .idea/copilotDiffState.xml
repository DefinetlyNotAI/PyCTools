<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/example/hwrng_example.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/hwrng_example.py" />
              <option name="originalContent" value="import os&#10;import threading&#10;import sys&#10;&#10;sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), &quot;..&quot;)))&#10;from pyCTools import MaxRNG&#10;&#10;rng = MaxRNG()&#10;rng.dll.maxrng_init()  # Initialize the RNG for threads, Without this threading will raise RuntimeError&#10;&#10;print(&quot;RDRAND supported:&quot;, rng.test_rng_available())&#10;print(&quot;Threading available:&quot;, rng.test_threading_available())&#10;&#10;print(&quot;Basic RNG 32 bytes:&quot;, rng.maxrng(32).hex())&#10;print(&quot;Ultra RNG 32 bytes (complexity 10):&quot;, rng.maxrng_ultra(32, 10).hex())&#10;print(&quot;Solo Thread-safe RNG 32 bytes:&quot;, rng.maxrng_threadsafe(32).hex())&#10;&#10;&#10;def worker(size, index, results):&#10;    try:&#10;        data = rng.maxrng_threadsafe(size)&#10;        results[index] = data&#10;    except RuntimeError as e:&#10;        results[index] = e&#10;&#10;&#10;num_threads = 5&#10;bytes_per_thread = 16&#10;results_main = [None] * num_threads&#10;threads = []&#10;&#10;for i in range(num_threads):&#10;    t = threading.Thread(target=worker, args=(bytes_per_thread, i, results_main))&#10;    threads.append(t)&#10;    t.start()&#10;&#10;for t in threads:&#10;    t.join()&#10;&#10;for i, result in enumerate(results_main):&#10;    if isinstance(result, Exception):&#10;        print(f&quot;Thread {i}: RNG failed: {result}&quot;)&#10;    else:&#10;        print(f&quot;Thread {i}: got {len(result)} bytes -&gt; {result.hex()}&quot;)&#10;&#10;print(&quot;All threads finished.&quot;)&#10;&#10;&#10;print(&quot;Example completed successfully.&quot;)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Comprehensive example demonstrating all features of MaxRNG from the pyCTools module.&#10;&#10;This example shows:&#10;1. Initializing and checking hardware RNG availability&#10;2. Using different RNG methods (basic, ultra, thread-safe)&#10;3. Working with different complexity levels&#10;4. Proper multi-threading implementation&#10;5. Error handling and best practices&#10;6. Practical applications (encryption keys, random file generation)&#10;7. Performance benchmarking&#10;&quot;&quot;&quot;&#10;import os&#10;import sys&#10;import time&#10;import threading&#10;import binascii&#10;from concurrent.futures import ThreadPoolExecutor&#10;import base64&#10;import hashlib&#10;import secrets&#10;from typing import Dict, List, Any, Tuple&#10;&#10;# Add the parent directory to sys.path to import pyCTools&#10;sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), &quot;..&quot;)))&#10;from pyCTools import MaxRNG&#10;&#10;&#10;def print_separator(title: str = None) -&gt; None:&#10;    &quot;&quot;&quot;Print a separator with an optional title.&quot;&quot;&quot;&#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    if title:&#10;        print(title)&#10;        print(&quot;=&quot; * 80)&#10;&#10;&#10;def hex_format(data: bytes, bytes_per_line: int = 16) -&gt; str:&#10;    &quot;&quot;&quot;Format bytes as a nicely formatted hex dump with ASCII representation.&quot;&quot;&quot;&#10;    result = []&#10;    for i in range(0, len(data), bytes_per_line):&#10;        chunk = data[i:i+bytes_per_line]&#10;        hex_part = ' '.join(f'{b:02x}' for b in chunk)&#10;        &#10;        # Pad the hex part to align the ASCII part&#10;        padding = '   ' * (bytes_per_line - len(chunk))&#10;        &#10;        # Create ASCII representation&#10;        ascii_part = ''.join(chr(b) if 32 &lt;= b &lt;= 126 else '.' for b in chunk)&#10;        &#10;        result.append(f&quot;{i:04x}:  {hex_part}{padding}  |{ascii_part}|&quot;)&#10;    return '\n'.join(result)&#10;&#10;&#10;def check_rng_availability() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if hardware RNG is available and print detailed information.&#10;    &#10;    Returns:&#10;        bool: True if RNG is fully available (including threading)&#10;    &quot;&quot;&quot;&#10;    print_separator(&quot;HARDWARE RNG AVAILABILITY CHECK&quot;)&#10;    &#10;    try:&#10;        rng = MaxRNG()&#10;        &#10;        # Check basic RNG availability (RDRAND instruction)&#10;        rdrand_available = rng.test_rng_available()&#10;        print(f&quot;RDRAND hardware instruction: {'AVAILABLE' if rdrand_available else 'NOT AVAILABLE'}&quot;)&#10;        &#10;        if not rdrand_available:&#10;            print(&quot;⚠️ Hardware RNG not available. This could be because:&quot;)&#10;            print(&quot;  - Your CPU doesn't support the RDRAND instruction&quot;)&#10;            print(&quot;  - The RNG hardware module is disabled in BIOS/UEFI&quot;)&#10;            print(&quot;  - The DLL failed to detect the hardware properly&quot;)&#10;            return False&#10;        &#10;        # First check if threading is available before initialization&#10;        pre_init_threading = rng.test_threading_available()&#10;        print(f&quot;Threading support before initialization: {'YES' if pre_init_threading else 'NO'}&quot;)&#10;        &#10;        # Initialize threading support&#10;        print(&quot;\nInitializing RNG threading support...&quot;)&#10;        try:&#10;            rng.dll.maxrng_init()&#10;            print(&quot;✓ RNG threading initialized successfully&quot;)&#10;        except Exception as e:&#10;            print(f&quot;⚠️ Failed to initialize RNG threading: {e}&quot;)&#10;            return False&#10;        &#10;        # Check again after initialization&#10;        post_init_threading = rng.test_threading_available()&#10;        print(f&quot;Threading support after initialization: {'YES' if post_init_threading else 'NO'}&quot;)&#10;        &#10;        if post_init_threading:&#10;            print(&quot;\n✓ Hardware RNG is FULLY AVAILABLE with threading support&quot;)&#10;            return True&#10;        else:&#10;            print(&quot;\n⚠️ Hardware RNG is available but threading support failed to initialize&quot;)&#10;            return False&#10;            &#10;    except Exception as e:&#10;        print(f&quot;❌ Error checking RNG availability: {e}&quot;)&#10;        return False&#10;&#10;&#10;def basic_rng_demo() -&gt; None:&#10;    &quot;&quot;&quot;Demonstrate the basic RNG functionality.&quot;&quot;&quot;&#10;    print_separator(&quot;BASIC RNG DEMONSTRATION&quot;)&#10;    &#10;    rng = MaxRNG()&#10;    &#10;    # Generate different sizes of random data&#10;    sizes = [16, 32, 64, 128, 256]&#10;    &#10;    print(&quot;Generating random bytes of different sizes using basic maxrng():&quot;)&#10;    for size in sizes:&#10;        random_bytes = rng.maxrng(size)&#10;        print(f&quot;\n{size} random bytes:&quot;)&#10;        print(hex_format(random_bytes))&#10;        print(f&quot;Base64: {base64.b64encode(random_bytes).decode()}&quot;)&#10;    &#10;    print(&quot;\nThis basic RNG function is suitable for:&quot;)&#10;    print(&quot;- General purpose random number generation&quot;)&#10;    print(&quot;- Applications where standard randomness quality is sufficient&quot;)&#10;    print(&quot;- Non-threaded environments&quot;)&#10;&#10;&#10;def ultra_rng_demo() -&gt; None:&#10;    &quot;&quot;&quot;Demonstrate the ultra RNG functionality with different complexity levels.&quot;&quot;&quot;&#10;    print_separator(&quot;ULTRA RNG DEMONSTRATION&quot;)&#10;    &#10;    rng = MaxRNG()&#10;    &#10;    # Demonstrate different complexity levels&#10;    print(&quot;The maxrng_ultra() function allows specifying a 'complexity' parameter&quot;)&#10;    print(&quot;Higher complexity values produce higher-quality randomness at the cost of performance&quot;)&#10;    print(&quot;\nGenerating 64 bytes with different complexity levels:&quot;)&#10;    &#10;    complexities = [1, 5, 10, 20, 50]&#10;    &#10;    # Track timing for performance comparison&#10;    timing_results = []&#10;    &#10;    for complexity in complexities:&#10;        start_time = time.time()&#10;        random_bytes = rng.maxrng_ultra(64, complexity)&#10;        elapsed = time.time() - start_time&#10;        timing_results.append((complexity, elapsed))&#10;        &#10;        print(f&quot;\nComplexity level {complexity} (took {elapsed:.6f} seconds):&quot;)&#10;        print(hex_format(random_bytes))&#10;    &#10;    print(&quot;\nPerformance comparison:&quot;)&#10;    print(&quot;Complexity | Time (seconds) | Relative Speed&quot;)&#10;    print(&quot;-----------+---------------+--------------&quot;)&#10;    base_time = timing_results[0][1]  # Use complexity 1 as baseline&#10;    for complexity, elapsed in timing_results:&#10;        relative = elapsed / base_time&#10;        print(f&quot;{complexity:^11} | {elapsed:^15.6f} | {relative:^14.2f}x&quot;)&#10;    &#10;    print(&quot;\nRecommended complexity levels:&quot;)&#10;    print(&quot;- 1-5:   Good for non-critical applications, fastest performance&quot;)&#10;    print(&quot;- 10-20: Good balance for cryptographic applications&quot;)&#10;    print(&quot;- 20-50: For highest security requirements, slower performance&quot;)&#10;&#10;&#10;def threaded_rng_demo() -&gt; None:&#10;    &quot;&quot;&quot;Demonstrate thread-safe RNG functionality.&quot;&quot;&quot;&#10;    print_separator(&quot;THREAD-SAFE RNG DEMONSTRATION&quot;)&#10;    &#10;    rng = MaxRNG()&#10;    &#10;    # Ensure threading is available&#10;    if not rng.test_threading_available():&#10;        print(&quot;⚠️ Thread-safe RNG not available. Make sure maxrng_init() was called.&quot;)&#10;        try:&#10;            print(&quot;Attempting to initialize threading support now...&quot;)&#10;            rng.dll.maxrng_init()&#10;            if rng.test_threading_available():&#10;                print(&quot;✓ Successfully initialized threading support&quot;)&#10;            else:&#10;                print(&quot;❌ Failed to initialize threading support even after calling maxrng_init()&quot;)&#10;                return&#10;        except Exception as e:&#10;            print(f&quot;❌ Error initializing threading support: {e}&quot;)&#10;            return&#10;    &#10;    # Single-threaded demonstration first&#10;    print(&quot;\nSingle-threaded example:&quot;)&#10;    random_bytes = rng.maxrng_threadsafe(64)&#10;    print(hex_format(random_bytes))&#10;    &#10;    # Multi-threaded demonstration&#10;    print(&quot;\nMulti-threaded example:&quot;)&#10;    &#10;    def worker_function(thread_id, size):&#10;        &quot;&quot;&quot;Worker function that generates random bytes in a thread.&quot;&quot;&quot;&#10;        try:&#10;            start_time = time.time()&#10;            data = rng.maxrng_threadsafe(size)&#10;            elapsed = time.time() - start_time&#10;            return {&#10;                &quot;thread_id&quot;: thread_id,&#10;                &quot;data&quot;: data,&#10;                &quot;size&quot;: size,&#10;                &quot;time&quot;: elapsed,&#10;                &quot;success&quot;: True&#10;            }&#10;        except Exception as e:&#10;            return {&#10;                &quot;thread_id&quot;: thread_id,&#10;                &quot;error&quot;: str(e),&#10;                &quot;success&quot;: False&#10;            }&#10;    &#10;    # Use ThreadPoolExecutor for cleaner thread management&#10;    num_threads = 8&#10;    bytes_per_thread = 32&#10;    print(f&quot;Spawning {num_threads} threads, each generating {bytes_per_thread} bytes...&quot;)&#10;    &#10;    results = []&#10;    with ThreadPoolExecutor(max_workers=num_threads) as executor:&#10;        # Submit all tasks and collect futures&#10;        futures = [executor.submit(worker_function, i, bytes_per_thread) &#10;                  for i in range(num_threads)]&#10;        &#10;        # Wait for all to complete and collect results&#10;        for future in futures:&#10;            results.append(future.result())&#10;    &#10;    # Report results&#10;    success_count = sum(1 for r in results if r[&quot;success&quot;])&#10;    print(f&quot;\n✓ {success_count}/{num_threads} threads completed successfully&quot;)&#10;    &#10;    for result in results:&#10;        if result[&quot;success&quot;]:&#10;            print(f&quot;\nThread {result['thread_id']} ({result['time']:.6f}s):&quot;)&#10;            # Just show a portion of the data for brevity&#10;            print(f&quot;  {result['data'][:16].hex()}...&quot;)&#10;        else:&#10;            print(f&quot;\n❌ Thread {result['thread_id']} failed: {result['error']}&quot;)&#10;    &#10;    # Higher concurrency stress test&#10;    print(&quot;\nHigh concurrency stress test (50 threads):&quot;)&#10;    num_stress_threads = 50&#10;    stress_size = 16&#10;    &#10;    with ThreadPoolExecutor(max_workers=num_stress_threads) as executor:&#10;        start_time = time.time()&#10;        futures = [executor.submit(worker_function, i, stress_size) &#10;                  for i in range(num_stress_threads)]&#10;        &#10;        # Wait for all to complete&#10;        success_count = sum(1 for future in futures if future.result()[&quot;success&quot;])&#10;        total_time = time.time() - start_time&#10;    &#10;    print(f&quot;✓ {success_count}/{num_stress_threads} threads completed in {total_time:.3f}s&quot;)&#10;    print(f&quot;Average time per thread: {total_time/num_stress_threads:.6f}s&quot;)&#10;    print(f&quot;Total random data generated: {success_count * stress_size} bytes&quot;)&#10;    &#10;    print(&quot;\nThe thread-safe RNG function is essential for:&quot;)&#10;    print(&quot;- Multi-threaded applications requiring random data&quot;)&#10;    print(&quot;- Server applications handling concurrent requests&quot;)&#10;    print(&quot;- Parallel processing of random data&quot;)&#10;&#10;&#10;def practical_applications() -&gt; None:&#10;    &quot;&quot;&quot;Demonstrate practical applications of hardware RNG.&quot;&quot;&quot;&#10;    print_separator(&quot;PRACTICAL APPLICATIONS&quot;)&#10;    &#10;    rng = MaxRNG()&#10;    &#10;    # 1. Cryptographic keys&#10;    print(&quot;\n1. GENERATING CRYPTOGRAPHIC KEYS&quot;)&#10;    print(&quot;Hardware RNG is ideal for generating high-quality cryptographic keys&quot;)&#10;    &#10;    # AES-256 key (32 bytes)&#10;    aes_key = rng.maxrng_ultra(32, 20)&#10;    print(f&quot;\nAES-256 Key: {aes_key.hex()}&quot;)&#10;    &#10;    # Ed25519 private key (32 bytes)&#10;    ed25519_seed = rng.maxrng_ultra(32, 20)&#10;    print(f&quot;Ed25519 Seed: {ed25519_seed.hex()}&quot;)&#10;    &#10;    # 2. Random passwords&#10;    print(&quot;\n2. GENERATING SECURE PASSWORDS&quot;)&#10;    &#10;    def generate_password(length=16):&#10;        &quot;&quot;&quot;Generate a random password using hardware RNG.&quot;&quot;&quot;&#10;        # Get random bytes and convert to base64&#10;        random_bytes = rng.maxrng(length)&#10;        # Use base64 encoding to get printable chars, remove padding&#10;        b64_string = base64.b64encode(random_bytes).decode('ascii').rstrip('=')&#10;        # Take the first 'length' characters&#10;        return b64_string[:length]&#10;    &#10;    passwords = [generate_password(length) for length in [8, 12, 16, 24]]&#10;    for i, password in enumerate(passwords):&#10;        print(f&quot;Password {i+1} (length {len(password)}): {password}&quot;)&#10;    &#10;    # 3. Random file generation&#10;    print(&quot;\n3. GENERATING A RANDOM FILE&quot;)&#10;    &#10;    file_size = 1024  # 1 KB&#10;    file_path = &quot;random_data.bin&quot;&#10;    &#10;    with open(file_path, &quot;wb&quot;) as f:&#10;        # Generate data in chunks for efficiency&#10;        chunk_size = 256&#10;        remaining = file_size&#10;        &#10;        while remaining &gt; 0:&#10;            size = min(chunk_size, remaining)&#10;            data = rng.maxrng(size)&#10;            f.write(data)&#10;            remaining -= size&#10;    &#10;    print(f&quot;Generated random file: {file_path} ({file_size} bytes)&quot;)&#10;    &#10;    # Calculate file hash to verify randomness&#10;    with open(file_path, &quot;rb&quot;) as f:&#10;        file_data = f.read()&#10;        file_hash = hashlib.sha256(file_data).hexdigest()&#10;    &#10;    print(f&quot;File SHA-256: {file_hash}&quot;)&#10;    &#10;    # 4. Compare with software RNG&#10;    print(&quot;\n4. COMPARISON WITH SOFTWARE RNG&quot;)&#10;    print(&quot;Hardware RNG vs Python's cryptographic RNG (secrets module)&quot;)&#10;    &#10;    sizes_to_test = [16, 64, 256, 1024]&#10;    &#10;    print(&quot;\nSize (bytes) | Hardware RNG time | Software RNG time | Ratio&quot;)&#10;    print(&quot;-------------+-------------------+-------------------+-------&quot;)&#10;    &#10;    for size in sizes_to_test:&#10;        # Hardware RNG timing&#10;        hw_start = time.time()&#10;        _ = rng.maxrng(size)&#10;        hw_time = time.time() - hw_start&#10;        &#10;        # Software RNG timing&#10;        sw_start = time.time()&#10;        _ = secrets.token_bytes(size)&#10;        sw_time = time.time() - sw_start&#10;        &#10;        # Calculate ratio (higher means hardware is slower)&#10;        ratio = hw_time / sw_time if sw_time &gt; 0 else float('inf')&#10;        &#10;        print(f&quot;{size:^13} | {hw_time:^19.6f} | {sw_time:^19.6f} | {ratio:^7.2f}x&quot;)&#10;    &#10;    print(&quot;\nNote: Hardware RNG may be slower but provides true randomness,&quot;)&#10;    print(&quot;which is crucial for security-sensitive applications.&quot;)&#10;&#10;&#10;def error_handling_demo() -&gt; None:&#10;    &quot;&quot;&quot;Demonstrate proper error handling with MaxRNG.&quot;&quot;&quot;&#10;    print_separator(&quot;ERROR HANDLING DEMONSTRATION&quot;)&#10;    &#10;    rng = MaxRNG()&#10;    &#10;    # 1. Invalid size parameter&#10;    print(&quot;\n1. HANDLING INVALID SIZE PARAMETER&quot;)&#10;    try:&#10;        print(&quot;Attempting to generate -10 random bytes...&quot;)&#10;        random_bytes = rng.maxrng(-10)&#10;        print(&quot;Result:&quot;, random_bytes.hex())&#10;    except Exception as e:&#10;        print(f&quot;✓ Caught expected error: {e}&quot;)&#10;    &#10;    # 2. Invalid complexity parameter&#10;    print(&quot;\n2. HANDLING INVALID COMPLEXITY PARAMETER&quot;)&#10;    try:&#10;        print(&quot;Attempting to use negative complexity...&quot;)&#10;        random_bytes = rng.maxrng_ultra(32, -5)&#10;        print(&quot;Result:&quot;, random_bytes.hex())&#10;    except Exception as e:&#10;        print(f&quot;✓ Caught expected error: {e}&quot;)&#10;    &#10;    # 3. Thread-safety without initialization&#10;    print(&quot;\n3. HANDLING THREAD-SAFETY WITHOUT INITIALIZATION&quot;)&#10;    &#10;    # Create a new instance without initialization&#10;    try:&#10;        new_rng = MaxRNG()&#10;        # Try to bypass the check by accessing the DLL directly&#10;        buf = (ctypes.c_ubyte * 16)()&#10;        print(&quot;Attempting to call maxrng_threadsafe without proper initialization...&quot;)&#10;        success = new_rng.dll.maxrng_threadsafe(buf, 16)&#10;        if success:&#10;            print(&quot;Result:&quot;, bytes(buf).hex())&#10;        else:&#10;            print(&quot;✓ Function returned failure code as expected&quot;)&#10;    except Exception as e:&#10;        print(f&quot;✓ Caught expected error: {e}&quot;)&#10;    &#10;    print(&quot;\nBest practices for error handling:&quot;)&#10;    print(&quot;1. Always check hardware availability with test_rng_available()&quot;)&#10;    print(&quot;2. Always initialize threading with maxrng_init() before threaded usage&quot;)&#10;    print(&quot;3. Verify threading availability with test_threading_available()&quot;)&#10;    print(&quot;4. Use try/except blocks around RNG calls in production code&quot;)&#10;    print(&quot;5. Have a fallback mechanism for when hardware RNG is unavailable&quot;)&#10;&#10;&#10;def main() -&gt; None:&#10;    &quot;&quot;&quot;Main function to run all demonstrations.&quot;&quot;&quot;&#10;    print_separator(&quot;HARDWARE RANDOM NUMBER GENERATOR (HRNG) COMPREHENSIVE DEMO&quot;)&#10;    print(&quot;This example demonstrates all features of the MaxRNG hardware RNG module&quot;)&#10;    &#10;    # First check if hardware RNG is available at all&#10;    if not check_rng_availability():&#10;        print(&quot;\n❌ Hardware RNG is not fully available.&quot;)&#10;        print(&quot;Some demonstrations may fail or fall back to software RNG.&quot;)&#10;        print(&quot;Do you want to continue anyway? (y/n)&quot;)&#10;        if input().lower() != 'y':&#10;            print(&quot;Exiting demonstration.&quot;)&#10;            return&#10;    &#10;    # Run all demonstrations&#10;    basic_rng_demo()&#10;    ultra_rng_demo()&#10;    threaded_rng_demo()&#10;    practical_applications()&#10;    error_handling_demo()&#10;    &#10;    print_separator(&quot;DEMONSTRATION COMPLETE&quot;)&#10;    &#10;    # Clean up the random file we created&#10;    try:&#10;        if os.path.exists(&quot;random_data.bin&quot;):&#10;            os.remove(&quot;random_data.bin&quot;)&#10;    except:&#10;        pass&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    try:&#10;        import ctypes  # Import here for the error handling demo&#10;        main()&#10;    except Exception as e:&#10;        print(f&quot;\n❌ Unhandled exception: {e}&quot;)&#10;        print(&quot;Demonstration terminated.&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/process_inspect_example.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/process_inspect_example.py" />
              <option name="originalContent" value="import os&#10;import sys&#10;&#10;sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), &quot;..&quot;)))&#10;from pyCTools import ProcessMetrics&#10;&#10;metrics = ProcessMetrics()&#10;pid = os.getpid()  # Replace with your actual target PID&#10;flags = (&#10;        ProcessMetrics.METRIC_WORKING_SET |&#10;        ProcessMetrics.METRIC_PRIVATE_BYTES |&#10;        ProcessMetrics.METRIC_CPU_USAGE |&#10;        ProcessMetrics.METRIC_IO |&#10;        ProcessMetrics.METRIC_THREADS |&#10;        ProcessMetrics.METRIC_HANDLES&#10;)&#10;&#10;# Start session&#10;if metrics.start_session(pid, flags):&#10;    # Simulate some work to collect metrics&#10;    # Time await without work&#10;    import time&#10;    time.sleep(5)&#10;&#10;    for i in range(3):&#10;        # Simulate resource intensive work&#10;        _ = [x ** 2 for x in range(10**6)]&#10;&#10;    # End session and get metrics delta&#10;    result = metrics.end_session(pid, flags)&#10;    print(&quot;Delta Metrics:&quot;, result)&#10;else:&#10;    print(&quot;Failed to start metrics session.&quot;)&#10;&#10;# Or get a snapshot instead&#10;try:&#10;    # Some values will be unreliable if it's a snapshot, example CPU usage&#10;    snapshot = metrics.get_snapshot(pid, flags)&#10;    print(&quot;Instant Snapshot:&quot;, snapshot)&#10;except RuntimeError as e:&#10;    print(&quot;Error:&quot;, str(e))&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Comprehensive example demonstrating all features of ProcessMetrics from the pyCTools module.&#10;&#10;This example shows:&#10;1. Setting up the ProcessMetrics module&#10;2. Using both session-based and snapshot monitoring approaches&#10;3. Working with all available metric types&#10;4. Interpreting and displaying the collected metrics&#10;5. Proper error handling and best practices&#10;&quot;&quot;&quot;&#10;import os&#10;import sys&#10;import time&#10;import json&#10;import random&#10;from typing import Dict, Any&#10;&#10;# Add the parent directory to sys.path to import pyCTools&#10;sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), &quot;..&quot;)))&#10;from pyCTools import ProcessMetrics&#10;&#10;&#10;def print_json(data: Dict[str, Any], title: str = None) -&gt; None:&#10;    &quot;&quot;&quot;Helper function to print JSON data in a formatted way.&quot;&quot;&quot;&#10;    if title:&#10;        print(f&quot;\n===== {title} =====&quot;)&#10;    print(json.dumps(data, indent=2))&#10;&#10;&#10;def simulate_workload(intensity: int = 1) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Simulate different types of system workload to demonstrate metric changes.&#10;    &#10;    Args:&#10;        intensity: Level of workload (1-3)&#10;    &quot;&quot;&quot;&#10;    # CPU-intensive work&#10;    print(f&quot;Simulating CPU-intensive work (level {intensity})...&quot;)&#10;    _ = [x ** 2 for x in range(intensity * 10**6)]&#10;    &#10;    # Memory-intensive work&#10;    print(f&quot;Simulating memory-intensive work (level {intensity})...&quot;)&#10;    big_list = [random.random() for _ in range(intensity * 10**5)]&#10;    &#10;    # I/O-intensive work (file operations)&#10;    print(f&quot;Simulating I/O-intensive work (level {intensity})...&quot;)&#10;    temp_filename = &quot;temp_workload_file.txt&quot;&#10;    with open(temp_filename, &quot;w&quot;) as f:&#10;        for i in range(intensity * 100):&#10;            f.write(f&quot;Line {i}: &quot; + &quot;X&quot; * 1000 + &quot;\n&quot;)&#10;    &#10;    # Read the file back&#10;    with open(temp_filename, &quot;r&quot;) as f:&#10;        _ = f.read()&#10;    &#10;    # Clean up&#10;    os.remove(temp_filename)&#10;    &#10;    # Force garbage collection to show memory changes&#10;    import gc&#10;    gc.collect()&#10;&#10;&#10;def demo_session_based_monitoring() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Demonstrates how to use session-based monitoring with ProcessMetrics.&#10;    &#10;    Session-based monitoring is ideal for:&#10;    - Measuring changes over specific periods of time&#10;    - Calculating deltas (differences) between start and end points&#10;    - Getting accurate CPU usage measurements&#10;    &quot;&quot;&quot;&#10;    print(&quot;\n\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;DEMONSTRATION: SESSION-BASED MONITORING&quot;)&#10;    print(&quot;=&quot; * 80)&#10;    &#10;    metrics = ProcessMetrics()&#10;    pid = os.getpid()  # Monitor the current Python process&#10;    &#10;    # Use ALL available metrics flags by combining them with bitwise OR&#10;    # Each flag represents a category of metrics to collect&#10;    flags = (&#10;        ProcessMetrics.METRIC_WORKING_SET |    # Memory currently in RAM&#10;        ProcessMetrics.METRIC_PRIVATE_BYTES |  # Memory exclusively used by the process&#10;        ProcessMetrics.METRIC_PAGEFILE |       # Swap file usage&#10;        ProcessMetrics.METRIC_HANDLES |        # OS resource handles count&#10;        ProcessMetrics.METRIC_THREADS |        # Thread count information&#10;        ProcessMetrics.METRIC_CPU_USAGE |      # CPU utilization percentage&#10;        ProcessMetrics.METRIC_IO |             # I/O operations statistics&#10;        ProcessMetrics.METRIC_NET              # Network usage statistics&#10;    )&#10;    &#10;    print(f&quot;Starting metrics session for PID {pid} with all metrics enabled&quot;)&#10;    print(&quot;Session-based monitoring captures changes between start and end points&quot;)&#10;    &#10;    # Start the metrics collection session&#10;    if not metrics.start_session(pid, flags):&#10;        print(&quot;ERROR: Failed to start metrics session. The process may not exist or you may not have sufficient permissions.&quot;)&#10;        return&#10;    &#10;    print(&quot;Session started successfully. Performing workloads...&quot;)&#10;    &#10;    # Simulate different workloads to show their impact on metrics&#10;    # First a baseline idle period&#10;    print(&quot;\nPHASE 1: Idle period (5 seconds) to establish baseline&quot;)&#10;    time.sleep(5)&#10;    &#10;    # Then perform progressively more intensive operations&#10;    print(&quot;\nPHASE 2: Low-intensity workload&quot;)&#10;    simulate_workload(intensity=1)&#10;    &#10;    print(&quot;\nPHASE 3: Medium-intensity workload&quot;)&#10;    simulate_workload(intensity=2)&#10;    &#10;    print(&quot;\nPHASE 4: High-intensity workload&quot;)&#10;    simulate_workload(intensity=3)&#10;    &#10;    # End the session and get the delta metrics&#10;    print(&quot;\nEnding metrics session and collecting results...&quot;)&#10;    try:&#10;        result = metrics.end_session(pid, flags)&#10;        print_json(result, &quot;SESSION METRICS (DELTA BETWEEN START AND END)&quot;)&#10;        &#10;        # Explain some key metrics&#10;        print(&quot;\n--- KEY METRICS EXPLAINED ---&quot;)&#10;        &#10;        if &quot;cpu&quot; in result:&#10;            print(f&quot;CPU Usage: {result['cpu'].get('usage', 'N/A')}% - Percentage of CPU time used by this process&quot;)&#10;        &#10;        if &quot;memory&quot; in result:&#10;            memory = result[&quot;memory&quot;]&#10;            print(f&quot;Working Set: {memory.get('working_set', 'N/A')} bytes - Memory currently in physical RAM&quot;)&#10;            print(f&quot;Private Bytes: {memory.get('private_bytes', 'N/A')} bytes - Memory exclusively allocated to this process&quot;)&#10;            if &quot;pagefile&quot; in memory:&#10;                print(f&quot;Pagefile Usage: {memory['pagefile']} bytes - Amount of swap file used&quot;)&#10;        &#10;        if &quot;io&quot; in result:&#10;            io = result[&quot;io&quot;]&#10;            print(f&quot;Read Operations: {io.get('read_operations', 'N/A')} - Number of read operations performed&quot;)&#10;            print(f&quot;Write Operations: {io.get('write_operations', 'N/A')} - Number of write operations performed&quot;)&#10;            print(f&quot;Read Bytes: {io.get('read_bytes', 'N/A')} bytes - Total bytes read from disk&quot;)&#10;            print(f&quot;Write Bytes: {io.get('write_bytes', 'N/A')} bytes - Total bytes written to disk&quot;)&#10;        &#10;        if &quot;threads&quot; in result:&#10;            print(f&quot;Thread Count: {result['threads'].get('count', 'N/A')} - Number of threads in this process&quot;)&#10;        &#10;        if &quot;handles&quot; in result:&#10;            print(f&quot;Handle Count: {result['handles'].get('count', 'N/A')} - Number of OS resource handles&quot;)&#10;            &#10;    except RuntimeError as e:&#10;        print(f&quot;Error ending metrics session: {str(e)}&quot;)&#10;&#10;&#10;def demo_snapshot_monitoring() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Demonstrates how to use snapshot-based monitoring with ProcessMetrics.&#10;    &#10;    Snapshot-based monitoring is useful for:&#10;    - Getting immediate metrics without having to start/end a session&#10;    - Polling metrics at regular intervals&#10;    - Getting a quick overview of current process state&#10;    &#10;    Note: Some metrics like CPU usage may be less accurate in snapshot mode&#10;    &quot;&quot;&quot;&#10;    print(&quot;\n\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;DEMONSTRATION: SNAPSHOT-BASED MONITORING&quot;)&#10;    print(&quot;=&quot; * 80)&#10;    &#10;    metrics = ProcessMetrics()&#10;    pid = os.getpid()  # Monitor the current Python process&#10;    &#10;    # Define the metrics we want to collect&#10;    flags = (&#10;        ProcessMetrics.METRIC_WORKING_SET |&#10;        ProcessMetrics.METRIC_PRIVATE_BYTES |&#10;        ProcessMetrics.METRIC_PAGEFILE |&#10;        ProcessMetrics.METRIC_HANDLES |&#10;        ProcessMetrics.METRIC_THREADS |&#10;        ProcessMetrics.METRIC_CPU_USAGE |&#10;        ProcessMetrics.METRIC_IO |&#10;        ProcessMetrics.METRIC_NET&#10;    )&#10;    &#10;    print(f&quot;Taking metrics snapshots for PID {pid}&quot;)&#10;    print(&quot;This approach provides immediate data about the current state&quot;)&#10;    print(&quot;Note: CPU usage may be less accurate in snapshot mode compared to session mode\n&quot;)&#10;    &#10;    # Take an initial snapshot before any work&#10;    try:&#10;        print(&quot;Taking initial snapshot...&quot;)&#10;        snapshot1 = metrics.get_snapshot(pid, flags)&#10;        print_json(snapshot1, &quot;INITIAL SNAPSHOT&quot;)&#10;    except RuntimeError as e:&#10;        print(f&quot;Error taking initial snapshot: {str(e)}&quot;)&#10;        return&#10;    &#10;    # Perform some work to change metrics&#10;    print(&quot;\nPerforming intensive workload...&quot;)&#10;    simulate_workload(intensity=3)&#10;    &#10;    # Take another snapshot after work&#10;    try:&#10;        print(&quot;\nTaking snapshot after workload...&quot;)&#10;        snapshot2 = metrics.get_snapshot(pid, flags)&#10;        print_json(snapshot2, &quot;POST-WORKLOAD SNAPSHOT&quot;)&#10;        &#10;        # Calculate and display some differences manually&#10;        print(&quot;\n--- MANUAL DIFFERENCE CALCULATION ---&quot;)&#10;        if &quot;memory&quot; in snapshot1 and &quot;memory&quot; in snapshot2:&#10;            ws_diff = snapshot2[&quot;memory&quot;].get(&quot;working_set&quot;, 0) - snapshot1[&quot;memory&quot;].get(&quot;working_set&quot;, 0)&#10;            pb_diff = snapshot2[&quot;memory&quot;].get(&quot;private_bytes&quot;, 0) - snapshot1[&quot;memory&quot;].get(&quot;private_bytes&quot;, 0)&#10;            print(f&quot;Working Set Change: {ws_diff} bytes&quot;)&#10;            print(f&quot;Private Bytes Change: {pb_diff} bytes&quot;)&#10;        &#10;        if &quot;handles&quot; in snapshot1 and &quot;handles&quot; in snapshot2:&#10;            handle_diff = snapshot2[&quot;handles&quot;].get(&quot;count&quot;, 0) - snapshot1[&quot;handles&quot;].get(&quot;count&quot;, 0)&#10;            print(f&quot;Handle Count Change: {handle_diff}&quot;)&#10;        &#10;    except RuntimeError as e:&#10;        print(f&quot;Error taking second snapshot: {str(e)}&quot;)&#10;&#10;&#10;def demo_selective_metrics() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Demonstrates how to selectively choose which metrics to collect.&#10;    &#10;    Advantages of selective metrics:&#10;    - Reduced overhead&#10;    - Focused data collection&#10;    - May avoid permission issues for certain metrics&#10;    &quot;&quot;&quot;&#10;    print(&quot;\n\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;DEMONSTRATION: SELECTIVE METRICS COLLECTION&quot;)&#10;    print(&quot;=&quot; * 80)&#10;    &#10;    metrics = ProcessMetrics()&#10;    pid = os.getpid()&#10;    &#10;    print(&quot;You can select only the metrics you need by combining specific flags&quot;)&#10;    print(&quot;This can reduce overhead and focus on metrics relevant to your application&quot;)&#10;    &#10;    # Example 1: Only memory metrics&#10;    memory_flags = (&#10;        ProcessMetrics.METRIC_WORKING_SET |&#10;        ProcessMetrics.METRIC_PRIVATE_BYTES |&#10;        ProcessMetrics.METRIC_PAGEFILE&#10;    )&#10;    &#10;    print(&quot;\n--- MEMORY METRICS ONLY ---&quot;)&#10;    try:&#10;        memory_snapshot = metrics.get_snapshot(pid, memory_flags)&#10;        print_json(memory_snapshot, &quot;MEMORY METRICS&quot;)&#10;    except RuntimeError as e:&#10;        print(f&quot;Error: {str(e)}&quot;)&#10;    &#10;    # Example 2: Only CPU and threads&#10;    performance_flags = (&#10;        ProcessMetrics.METRIC_CPU_USAGE |&#10;        ProcessMetrics.METRIC_THREADS&#10;    )&#10;    &#10;    print(&quot;\n--- PERFORMANCE METRICS ONLY ---&quot;)&#10;    try:&#10;        performance_snapshot = metrics.get_snapshot(pid, performance_flags)&#10;        print_json(performance_snapshot, &quot;PERFORMANCE METRICS&quot;)&#10;    except RuntimeError as e:&#10;        print(f&quot;Error: {str(e)}&quot;)&#10;    &#10;    # Example 3: Only I/O and network metrics&#10;    io_flags = (&#10;        ProcessMetrics.METRIC_IO |&#10;        ProcessMetrics.METRIC_NET&#10;    )&#10;    &#10;    print(&quot;\n--- I/O METRICS ONLY ---&quot;)&#10;    try:&#10;        io_snapshot = metrics.get_snapshot(pid, io_flags)&#10;        print_json(io_snapshot, &quot;I/O METRICS&quot;)&#10;    except RuntimeError as e:&#10;        print(f&quot;Error: {str(e)}&quot;)&#10;&#10;&#10;def demo_other_process_monitoring() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Demonstrates monitoring other processes (with proper permissions).&#10;    &quot;&quot;&quot;&#10;    print(&quot;\n\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;DEMONSTRATION: MONITORING OTHER PROCESSES&quot;)&#10;    print(&quot;=&quot; * 80)&#10;    &#10;    metrics = ProcessMetrics()&#10;    &#10;    # Get a list of processes (this is just an example, requires psutil)&#10;    try:&#10;        import psutil&#10;        processes_available = True&#10;    except ImportError:&#10;        processes_available = False&#10;        print(&quot;psutil not available. Install with 'pip install psutil' to see this demo&quot;)&#10;        return&#10;    &#10;    if processes_available:&#10;        print(&quot;Available processes (first 5):&quot;)&#10;        for i, proc in enumerate(psutil.process_iter(['pid', 'name'])):&#10;            if i &gt;= 5:&#10;                break&#10;            print(f&quot;  PID {proc.info['pid']}: {proc.info['name']}&quot;)&#10;        &#10;        # Try to monitor a system process like explorer.exe on Windows&#10;        target_name = &quot;explorer.exe&quot; if os.name == &quot;nt&quot; else &quot;sshd&quot;&#10;        target_pid = None&#10;        &#10;        for proc in psutil.process_iter(['pid', 'name']):&#10;            if proc.info['name'].lower() == target_name:&#10;                target_pid = proc.info['pid']&#10;                break&#10;        &#10;        if target_pid:&#10;            print(f&quot;\nAttempting to monitor {target_name} (PID {target_pid})&quot;)&#10;            print(&quot;Note: This may fail due to permissions, especially on non-admin accounts&quot;)&#10;            &#10;            flags = ProcessMetrics.METRIC_WORKING_SET | ProcessMetrics.METRIC_THREADS&#10;            &#10;            try:&#10;                snapshot = metrics.get_snapshot(target_pid, flags)&#10;                print_json(snapshot, f&quot;{target_name.upper()} METRICS&quot;)&#10;            except RuntimeError as e:&#10;                print(f&quot;Error monitoring {target_name}: {str(e)}&quot;)&#10;                print(&quot;This is expected if you don't have sufficient permissions&quot;)&#10;        else:&#10;            print(f&quot;\nCould not find {target_name} process&quot;)&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function to demonstrate all ProcessMetrics capabilities.&quot;&quot;&quot;&#10;    print(&quot;=&quot; * 80)&#10;    print(&quot;PROCESS METRICS COMPREHENSIVE DEMONSTRATION&quot;)&#10;    print(&quot;=&quot; * 80)&#10;    print(&quot;\nThis example demonstrates all features of the ProcessMetrics class.&quot;)&#10;    print(&quot;It shows how to monitor process resources in different ways and interpret the results.&quot;)&#10;    &#10;    # Demonstrate different monitoring approaches&#10;    demo_session_based_monitoring()&#10;    demo_snapshot_monitoring()&#10;    demo_selective_metrics()&#10;    demo_other_process_monitoring()&#10;    &#10;    print(&quot;\n&quot; + &quot;=&quot; * 80)&#10;    print(&quot;DEMONSTRATION COMPLETE&quot;)&#10;    print(&quot;=&quot; * 80)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/pyCTools/hwrng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/pyCTools/hwrng.md" />
              <option name="updatedContent" value="# Python Hardware Random Number Generator (hwrng)&#10;&#10;## Overview&#10;&#10;The `pyCTools.hwrng` module provides Python bindings to the high-security hardware random number generation capabilities of the `hRng` library. This module allows Python applications to access cryptographically secure random numbers generated from multiple entropy sources including hardware RNG instructions when available.&#10;&#10;## Features&#10;&#10;- Cryptographically secure random number generation&#10;- Thread-safe operation&#10;- Support for high-intensity entropy gathering&#10;- Self-test capabilities&#10;- Automatic architecture detection (x86/x64)&#10;- Simple Python API with proper error handling&#10;&#10;## Installation&#10;&#10;The `pyCTools` package includes precompiled binaries for both x86 and x64 Windows platforms. No additional installation steps are needed beyond installing the package:&#10;&#10;```bash&#10;pip install pyCTools&#10;```&#10;&#10;## API Reference&#10;&#10;### Functions&#10;&#10;#### `get_hardware_random_bytes(size: int) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the standard MaxRNG algorithm.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;&#10;# Generate 32 random bytes&#10;random_data = get_hardware_random_bytes(32)&#10;print(&quot;Random bytes:&quot;, random_data.hex())&#10;```&#10;&#10;#### `get_hardware_random_bytes_threadsafe(size: int) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the thread-safe version of MaxRNG. This function is safe to call from multiple threads simultaneously.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;import threading&#10;from pyCTools.hwrng import get_hardware_random_bytes_threadsafe&#10;&#10;def worker():&#10;    # Generate 16 random bytes in each thread&#10;    data = get_hardware_random_bytes_threadsafe(16)&#10;    print(f&quot;Thread {threading.current_thread().name}: {data.hex()}&quot;)&#10;&#10;# Create and start 5 threads&#10;threads = []&#10;for i in range(5):&#10;    t = threading.Thread(target=worker, name=f&quot;RNG-{i}&quot;)&#10;    threads.append(t)&#10;    t.start()&#10;&#10;# Wait for all threads to complete&#10;for t in threads:&#10;    t.join()&#10;```&#10;&#10;#### `get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the extended MaxRNG algorithm with configurable entropy gathering intensity.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;- `intensive_level` (int, optional): Entropy gathering intensity level (must be &gt;= 1). Default is 2.&#10;  - Level 1: Standard MaxRNG operation&#10;  - Level 2: Additional CPU jitter entropy&#10;  - Level 3+: Maximum entropy gathering from all available sources&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive or intensive_level is less than 1&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes_extended&#10;&#10;# Generate 64 random bytes with maximum entropy gathering&#10;random_data = get_hardware_random_bytes_extended(64, intensive_level=5)&#10;print(&quot;High-security random bytes:&quot;, random_data.hex())&#10;```&#10;&#10;#### `hardware_rng_selftest() -&gt; bool`&#10;&#10;Runs the built-in self-test for the RNG to verify proper operation.&#10;&#10;**Returns:**&#10;- `bool`: True if the self-test passes, False otherwise&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import hardware_rng_selftest&#10;&#10;if hardware_rng_selftest():&#10;    print(&quot;RNG self-test passed&quot;)&#10;else:&#10;    print(&quot;RNG self-test failed&quot;)&#10;```&#10;&#10;### Exceptions&#10;&#10;#### `HardwareRNGError`&#10;&#10;Raised when a hardware RNG operation fails or when the DLL cannot be loaded.&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes, HardwareRNGError&#10;&#10;try:&#10;    random_data = get_hardware_random_bytes(32)&#10;    print(&quot;Random bytes:&quot;, random_data.hex())&#10;except HardwareRNGError as e:&#10;    print(f&quot;RNG operation failed: {e}&quot;)&#10;```&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;&#10;# Generate a random 256-bit key (32 bytes)&#10;key = get_hardware_random_bytes(32)&#10;print(f&quot;Random 256-bit key: {key.hex()}&quot;)&#10;```&#10;&#10;### Using as a Source for cryptography Library&#10;&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;from cryptography.hazmat.primitives.asymmetric import rsa&#10;import os&#10;&#10;class HardwareRandomGenerator:&#10;    def __init__(self):&#10;        pass&#10;        &#10;    def read(self, size):&#10;        return get_hardware_random_bytes(size)&#10;&#10;# Use our hardware RNG as a source for RSA key generation&#10;os.environ[&quot;PYTHONHASHSEED&quot;] = &quot;0&quot;  # Fix seed for reproducible example&#10;rng = HardwareRandomGenerator()&#10;private_key = rsa.generate_private_key(&#10;    public_exponent=65537,&#10;    key_size=2048,&#10;    backend=default_backend(),&#10;    random_number_generator=rng&#10;)&#10;&#10;print(&quot;Generated RSA key with hardware entropy&quot;)&#10;```&#10;&#10;### High-Security Random Token Generation&#10;&#10;```python&#10;import base64&#10;from pyCTools.hwrng import get_hardware_random_bytes_extended&#10;&#10;def generate_secure_token(length=32):&#10;    &quot;&quot;&quot;Generate a URL-safe, base64 encoded token with maximum entropy.&quot;&quot;&quot;&#10;    random_bytes = get_hardware_random_bytes_extended(length, intensive_level=5)&#10;    return base64.urlsafe_b64encode(random_bytes).decode('utf-8')&#10;&#10;# Generate a secure session token&#10;session_token = generate_secure_token(48)&#10;print(f&quot;Secure session token: {session_token}&quot;)&#10;```&#10;&#10;### Thread Safety Demonstration&#10;&#10;```python&#10;import threading&#10;import time&#10;from pyCTools.hwrng import get_hardware_random_bytes_threadsafe&#10;&#10;def intensive_rng_task(thread_id):&#10;    &quot;&quot;&quot;Generate multiple random values in a thread.&quot;&quot;&quot;&#10;    for i in range(5):&#10;        data = get_hardware_random_bytes_threadsafe(16)&#10;        hex_data = data.hex()&#10;        print(f&quot;Thread {thread_id}, iteration {i}: {hex_data}&quot;)&#10;        time.sleep(0.01)  # Small delay to better visualize concurrent execution&#10;&#10;# Create and start 10 threads&#10;threads = []&#10;for i in range(10):&#10;    t = threading.Thread(target=intensive_rng_task, args=(i,))&#10;    threads.append(t)&#10;    t.start()&#10;&#10;# Wait for all threads to complete&#10;for t in threads:&#10;    t.join()&#10;```&#10;&#10;## Technical Details&#10;&#10;### DLL Loading&#10;&#10;The module automatically locates and loads the appropriate version (x86 or x64) of the `hRng` DLL from the distribution directory. The DLL is loaded only once when the module is first imported.&#10;&#10;### Error Handling&#10;&#10;All RNG operations include proper error checking. If an operation fails, a `HardwareRNGError` exception is raised with an informative error message.&#10;&#10;### Thread Safety&#10;&#10;The `get_hardware_random_bytes_threadsafe` function uses the thread-safe version of the RNG which employs proper synchronization mechanisms to ensure safe concurrent access from multiple threads.&#10;&#10;### Performance Considerations&#10;&#10;- The standard `get_hardware_random_bytes` function provides the best balance of security and performance for most applications.&#10;- The `get_hardware_random_bytes_extended` function with higher intensity levels will be slower but provides additional entropy gathering.&#10;- For applications requiring many random numbers in performance-sensitive contexts, consider generating larger batches less frequently.&#10;&#10;## Security Recommendations&#10;&#10;1. Use `get_hardware_random_bytes_extended` with a high intensity level (4 or 5) for generating cryptographic keys and other highly sensitive values.&#10;2. Use `get_hardware_random_bytes_threadsafe` in multi-threaded applications to ensure thread safety.&#10;3. Consider running `hardware_rng_selftest()` at application startup to verify RNG functionality.&#10;4. For cryptographic applications, combine this RNG with proper key derivation functions (KDFs) such as PBKDF2 or Argon2.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/pyCTools/hwrng.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/pyCTools/hwrng.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;hwrng.py&#10;&#10;Hardware Random Number Generator interface for Python using ctypes and the new hRng.dll.&#10;&quot;&quot;&quot;&#10;&#10;import ctypes&#10;import os&#10;import platform&#10;&#10;__all__ = [&#10;    &quot;get_hardware_random_bytes&quot;,&#10;    &quot;get_hardware_random_bytes_extended&quot;,&#10;    &quot;get_thread_safe_random_bytes&quot;,&#10;    &quot;hardware_rng_selftest&quot;,&#10;    &quot;is_thread_safe_available&quot;,&#10;    &quot;HardwareRNGError&quot;&#10;]&#10;&#10;&#10;class HardwareRNGError(RuntimeError):&#10;    &quot;&quot;&quot;Raised when hardware RNG fails or DLL cannot be loaded.&quot;&quot;&quot;&#10;    def __init__(self, message=&quot;Hardware RNG error occurred&quot;):&#10;        super().__init__(message)&#10;&#10;&#10;def _load_rng_functions():&#10;    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'&#10;    dll_name = f'hRng_{arch}.dll'&#10;    base_dir = os.path.dirname(__file__)&#10;    possible_dist_paths = [&#10;        os.path.join(base_dir, 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', '..', 'dist', arch, dll_name),&#10;    ]&#10;&#10;    dll_path = None&#10;    for path in possible_dist_paths:&#10;        abs_path = os.path.abspath(path)&#10;        if os.path.exists(abs_path):&#10;            dll_path = abs_path&#10;            break&#10;&#10;    if dll_path is None:&#10;        dll_path = os.path.abspath(possible_dist_paths[0])  # fallback for error message&#10;&#10;    dll = ctypes.CDLL(dll_path)&#10;&#10;    # Setup function signatures&#10;    MaxRNG = dll.MaxRNG&#10;    MaxRNG.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int]&#10;    MaxRNG.restype = ctypes.c_int&#10;&#10;    MaxRNG_Extended = dll.MaxRNG_Extended&#10;    MaxRNG_Extended.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int, ctypes.c_int]&#10;    MaxRNG_Extended.restype = ctypes.c_int&#10;&#10;    RNG_SelfTest = dll.RNG_SelfTest&#10;    RNG_SelfTest.argtypes = []&#10;    RNG_SelfTest.restype = ctypes.c_int&#10;&#10;    # Thread safety check function&#10;    IsRNGThreadSafe = dll.IsRNGThreadSafe&#10;    IsRNGThreadSafe.argtypes = []&#10;    IsRNGThreadSafe.restype = ctypes.c_int&#10;&#10;    return MaxRNG, MaxRNG_Extended, RNG_SelfTest, IsRNGThreadSafe&#10;&#10;&#10;# Load the functions only once&#10;_MaxRNG, _MaxRNG_Extended, _RNG_SelfTest, _IsRNGThreadSafe = _load_rng_functions()&#10;&#10;&#10;def get_hardware_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def get_thread_safe_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG with thread safety.&#10;&#10;    This function uses the thread-safe implementation of MaxRNG that properly&#10;    synchronizes access across multiple threads.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails or thread safety is not available.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    if not is_thread_safe_available():&#10;        raise HardwareRNGError(&quot;Thread-safe RNG implementation not available&quot;)&#10;&#10;    # Uses the same MaxRNG function which is internally thread-safe&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;Thread-safe MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def is_thread_safe_available() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if the thread-safe RNG implementation is available.&#10;&#10;    Returns:&#10;        bool: True if thread safety is available, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_IsRNGThreadSafe())&#10;&#10;&#10;# TODO Benchmark all with proper graphs and tests&#10;def get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve random bytes using MaxRNG_Extended.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;        intensive_level (int): Entropy gathering intensity (&gt;=1).&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size or intensive_level is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;    if intensive_level &lt; 1:&#10;        raise ValueError(&quot;intensive_level must be &gt;= 1&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG_Extended(buffer, size, intensive_level)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG_Extended failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def hardware_rng_selftest() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Run the RNG self-test.&#10;&#10;    Returns:&#10;        bool: True if self-test passes, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_RNG_SelfTest())&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;hwrng.py&#10;&#10;Hardware Random Number Generator interface for Python using ctypes and the new hRng.dll.&#10;&quot;&quot;&quot;&#10;&#10;import ctypes&#10;import os&#10;import platform&#10;import threading&#10;&#10;__all__ = [&#10;    &quot;get_hardware_random_bytes&quot;,&#10;    &quot;get_thread_safe_random_bytes&quot;,&#10;    &quot;get_hardware_random_bytes_extended&quot;,&#10;    &quot;hardware_rng_selftest&quot;,&#10;    &quot;is_thread_safe_available&quot;,&#10;    &quot;HardwareRNGError&quot;&#10;]&#10;&#10;&#10;class HardwareRNGError(RuntimeError):&#10;    &quot;&quot;&quot;Raised when hardware RNG fails or DLL cannot be loaded.&quot;&quot;&quot;&#10;    def __init__(self, message=&quot;Hardware RNG error occurred&quot;):&#10;        super().__init__(message)&#10;&#10;&#10;# Global lock for Python-level thread safety&#10;_py_lock = threading.Lock()&#10;&#10;def _load_rng_functions():&#10;    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'&#10;    dll_name = f'hRng_{arch}.dll'&#10;    base_dir = os.path.dirname(__file__)&#10;    possible_dist_paths = [&#10;        os.path.join(base_dir, 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', '..', 'dist', arch, dll_name),&#10;    ]&#10;&#10;    dll_path = None&#10;    for path in possible_dist_paths:&#10;        abs_path = os.path.abspath(path)&#10;        if os.path.exists(abs_path):&#10;            dll_path = abs_path&#10;            break&#10;&#10;    if dll_path is None:&#10;        # Try looking for the DLL in the current directory as a fallback&#10;        current_dir = os.path.abspath(os.getcwd())&#10;        fallback_path = os.path.join(current_dir, dll_name)&#10;        if os.path.exists(fallback_path):&#10;            dll_path = fallback_path&#10;        else:&#10;            dll_path = os.path.abspath(possible_dist_paths[0])  # fallback for error message&#10;            raise HardwareRNGError(f&quot;Could not find {dll_name}. Searched in {', '.join(possible_dist_paths)}&quot;)&#10;&#10;    try:&#10;        dll = ctypes.CDLL(dll_path)&#10;    except Exception as e:&#10;        raise HardwareRNGError(f&quot;Failed to load {dll_path}: {str(e)}&quot;)&#10;&#10;    # Setup function signatures&#10;    MaxRNG = dll.MaxRNG&#10;    MaxRNG.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int]&#10;    MaxRNG.restype = ctypes.c_int&#10;&#10;    MaxRNG_Extended = dll.MaxRNG_Extended&#10;    MaxRNG_Extended.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int, ctypes.c_int]&#10;    MaxRNG_Extended.restype = ctypes.c_int&#10;&#10;    RNG_SelfTest = dll.RNG_SelfTest&#10;    RNG_SelfTest.argtypes = []&#10;    RNG_SelfTest.restype = ctypes.c_int&#10;&#10;    # Thread safety check function&#10;    IsRNGThreadSafe = dll.IsRNGThreadSafe&#10;    IsRNGThreadSafe.argtypes = []&#10;    IsRNGThreadSafe.restype = ctypes.c_int&#10;&#10;    return MaxRNG, MaxRNG_Extended, RNG_SelfTest, IsRNGThreadSafe&#10;&#10;&#10;# Load the functions only once in a thread-safe way&#10;try:&#10;    _MaxRNG, _MaxRNG_Extended, _RNG_SelfTest, _IsRNGThreadSafe = _load_rng_functions()&#10;except HardwareRNGError as e:&#10;    # Provide stubs for functions in case the DLL couldn't be loaded&#10;    def _error_stub(*args, **kwargs):&#10;        raise HardwareRNGError(&quot;RNG functions unavailable - DLL could not be loaded&quot;)&#10;    &#10;    _MaxRNG = _MaxRNG_Extended = _RNG_SelfTest = _IsRNGThreadSafe = _error_stub&#10;    print(f&quot;WARNING: Failed to load RNG DLL: {str(e)}&quot;)&#10;&#10;&#10;def get_hardware_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    # Add Python-level thread safety as a backup&#10;    with _py_lock:&#10;        buffer = (ctypes.c_ubyte * size)()&#10;        success = _MaxRNG(buffer, size)&#10;        if not success:&#10;            raise HardwareRNGError(&quot;MaxRNG failed.&quot;)&#10;        &#10;        # Make a copy to ensure buffer is fully processed before releasing the lock&#10;        return bytes(buffer)&#10;&#10;&#10;def get_thread_safe_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG with thread safety.&#10;&#10;    This function uses the thread-safe implementation of MaxRNG that properly&#10;    synchronizes access across multiple threads.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails or thread safety is not available.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    if not is_thread_safe_available():&#10;        # Fall back to Python-level locking if C-level thread safety is not available&#10;        return get_hardware_random_bytes(size)&#10;&#10;    # Uses the same MaxRNG function which is internally thread-safe&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;Thread-safe MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def is_thread_safe_available() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if the thread-safe RNG implementation is available.&#10;&#10;    Returns:&#10;        bool: True if thread safety is available, False otherwise.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return bool(_IsRNGThreadSafe())&#10;    except Exception:&#10;        return False&#10;&#10;&#10;# TODO Benchmark all with proper graphs and tests&#10;def get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve random bytes using MaxRNG_Extended.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;        intensive_level (int): Entropy gathering intensity (&gt;=1).&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size or intensive_level is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;    if intensive_level &lt; 1:&#10;        raise ValueError(&quot;intensive_level must be &gt;= 1&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG_Extended(buffer, size, intensive_level)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG_Extended failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def hardware_rng_selftest() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Run the RNG self-test.&#10;&#10;    Returns:&#10;        bool: True if self-test passes, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_RNG_SelfTest())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/t.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/t.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Example demonstrating thread-safe random number generation using PyCTools hwrng module.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import threading&#10;from pyCTools.hwrng import (&#10;    get_hardware_random_bytes,&#10;    get_thread_safe_random_bytes,&#10;    is_thread_safe_available,&#10;    HardwareRNGError&#10;)&#10;&#10;&#10;def thread_safe_example():&#10;    &quot;&quot;&quot;&#10;    Demonstrates the usage of thread-safe RNG functionality.&#10;    Compares standard and thread-safe implementations under high contention.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Thread-Safe RNG Example&quot;)&#10;    print(&quot;-----------------------&quot;)&#10;&#10;    # Check if thread safety is available&#10;    thread_safe_available = is_thread_safe_available()&#10;    print(f&quot;Thread-safe RNG implementation available: {thread_safe_available}&quot;)&#10;&#10;    if not thread_safe_available:&#10;        print(&quot;WARNING: Thread-safe implementation not available. Test will use standard RNG.&quot;)&#10;&#10;    # Number of threads to create&#10;    num_threads = 20&#10;    iterations_per_thread = 30&#10;    bytes_per_request = 16&#10;&#10;    # Results storage&#10;    standard_failures = 0&#10;    threadsafe_failures = 0&#10;&#10;    # Function for thread to run&#10;    def worker_thread(thread_id, use_thread_safe, results_list):&#10;        method = &quot;thread_safe&quot; if use_thread_safe else &quot;standard&quot;&#10;        rng_func = get_thread_safe_random_bytes if use_thread_safe else get_hardware_random_bytes&#10;&#10;        for i_ in range(iterations_per_thread):&#10;            try:&#10;                start_time_ = time.time()&#10;                random_data = rng_func(bytes_per_request)&#10;                elapsed = time.time() - start_time_&#10;&#10;                results_list.append({&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'data': random_data.hex()[:8] + '...',  # Show first 4 bytes only&#10;                    'time': elapsed&#10;                })&#10;&#10;                # Add a tiny sleep to allow thread switching&#10;                time.sleep(0.001)&#10;&#10;            except HardwareRNGError as e:&#10;                results_list.append({&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'error': str(e)&#10;                })&#10;                if use_thread_safe:&#10;                    nonlocal threadsafe_failures&#10;                    threadsafe_failures += 1&#10;                else:&#10;                    nonlocal standard_failures&#10;                    standard_failures += 1&#10;                break&#10;&#10;    # Test standard implementation&#10;    print(&quot;\nRunning standard RNG with multiple threads...&quot;)&#10;    standard_results = []&#10;    standard_threads = []&#10;&#10;    start_time = time.time()&#10;    for i in range(num_threads):&#10;        t = threading.Thread(&#10;            target=worker_thread,&#10;            args=(i, False, standard_results)&#10;        )&#10;        standard_threads.append(t)&#10;        t.start()&#10;&#10;    for t in standard_threads:&#10;        t.join()&#10;&#10;    standard_time = time.time() - start_time&#10;&#10;    # Test thread-safe implementation if available&#10;    threadsafe_time = 0&#10;    threadsafe_results = []&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nRunning thread-safe RNG with multiple threads...&quot;)&#10;        threadsafe_threads = []&#10;&#10;        start_time = time.time()&#10;        for i in range(num_threads):&#10;            t = threading.Thread(&#10;                target=worker_thread,&#10;                args=(i, True, threadsafe_results)&#10;            )&#10;            threadsafe_threads.append(t)&#10;            t.start()&#10;&#10;        for t in threadsafe_threads:&#10;            t.join()&#10;&#10;        threadsafe_time = time.time() - start_time&#10;&#10;    # Print results summary&#10;    print(&quot;\nResults Summary:&quot;)&#10;    print(&quot;--------------&quot;)&#10;    print(f&quot;Standard RNG: {len(standard_results)} operations in {standard_time:.3f}s&quot;)&#10;    print(f&quot;  - Success rate: {(len(standard_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;    print(f&quot;  - Failures: {standard_failures}&quot;)&#10;    print(f&quot;  - Avg time per operation: {standard_time / len(standard_results):.6f}s&quot;)&#10;&#10;    if thread_safe_available:&#10;        print(f&quot;\nThread-safe RNG: {len(threadsafe_results)} operations in {threadsafe_time:.3f}s&quot;)&#10;        print(f&quot;  - Success rate: {(len(threadsafe_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;        print(f&quot;  - Failures: {threadsafe_failures}&quot;)&#10;        print(f&quot;  - Avg time per operation: {threadsafe_time / len(threadsafe_results):.6f}s&quot;)&#10;&#10;        # Performance comparison&#10;        if standard_time &gt; 0 and threadsafe_time &gt; 0:&#10;            relative_perf = standard_time / threadsafe_time&#10;            if relative_perf &gt; 1:&#10;                print(f&quot;\nThread-safe implementation is {relative_perf:.2f}x faster than standard&quot;)&#10;            else:&#10;                print(f&quot;\nStandard implementation is {1/relative_perf:.2f}x faster than thread-safe&quot;)&#10;&#10;    # Show a sample of random values from each&#10;    print(&quot;\nSample Standard RNG values:&quot;)&#10;    for i, result in enumerate(standard_results[:5]):&#10;        if 'error' in result:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;        else:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nSample Thread-safe RNG values:&quot;)&#10;        for i, result in enumerate(threadsafe_results[:5]):&#10;            if 'error' in result:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;            else:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    thread_safe_example()&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Example demonstrating thread-safe random number generation using PyCTools hwrng module.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import threading&#10;from pyCTools.hwrng import (&#10;    get_hardware_random_bytes,&#10;    get_thread_safe_random_bytes,&#10;    is_thread_safe_available,&#10;    HardwareRNGError&#10;)&#10;&#10;&#10;def thread_safe_example():&#10;    &quot;&quot;&quot;&#10;    Demonstrates the usage of thread-safe RNG functionality.&#10;    Compares standard and thread-safe implementations under high contention.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Thread-Safe RNG Example&quot;)&#10;    print(&quot;-----------------------&quot;)&#10;&#10;    # Check if thread safety is available&#10;    thread_safe_available = is_thread_safe_available()&#10;    print(f&quot;Thread-safe RNG implementation available: {thread_safe_available}&quot;)&#10;&#10;    if not thread_safe_available:&#10;        print(&quot;WARNING: Thread-safe implementation not available. Test will use standard RNG.&quot;)&#10;&#10;    # Number of threads to create - reduce count to avoid overloading&#10;    num_threads = 10&#10;    iterations_per_thread = 10&#10;    bytes_per_request = 16&#10;&#10;    # Results storage&#10;    standard_failures = 0&#10;    threadsafe_failures = 0&#10;&#10;    # Function for thread to run with proper exception handling&#10;    def worker_thread(thread_id, use_thread_safe, results_list):&#10;        method = &quot;thread_safe&quot; if use_thread_safe else &quot;standard&quot;&#10;        rng_func = get_thread_safe_random_bytes if use_thread_safe else get_hardware_random_bytes&#10;&#10;        for i_ in range(iterations_per_thread):&#10;            try:&#10;                start_time_ = time.time()&#10;                random_data = rng_func(bytes_per_request)&#10;                elapsed = time.time() - start_time_&#10;                &#10;                # Store result safely&#10;                result_entry = {&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'data': random_data.hex()[:8] + '...',  # Show first 4 bytes only&#10;                    'time': elapsed&#10;                }&#10;                &#10;                # Use thread lock for updating shared data&#10;                with threading.Lock():&#10;                    results_list.append(result_entry)&#10;&#10;                # Add a tiny sleep to allow thread switching&#10;                time.sleep(0.005)  # Slightly longer sleep to reduce contention&#10;&#10;            except Exception as e:&#10;                error_entry = {&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'error': str(e)&#10;                }&#10;                &#10;                with threading.Lock():&#10;                    results_list.append(error_entry)&#10;                    if use_thread_safe:&#10;                        nonlocal threadsafe_failures&#10;                        threadsafe_failures += 1&#10;                    else:&#10;                        nonlocal standard_failures&#10;                        standard_failures += 1&#10;                &#10;                # Don't break - let thread continue trying other iterations&#10;                time.sleep(0.01)  # Sleep a bit after error&#10;&#10;    # Test standard implementation&#10;    print(&quot;\nRunning standard RNG with multiple threads...&quot;)&#10;    standard_results = []&#10;    standard_threads = []&#10;&#10;    start_time = time.time()&#10;    &#10;    # Create threads with proper error handling&#10;    try:&#10;        for i in range(num_threads):&#10;            t = threading.Thread(&#10;                target=worker_thread,&#10;                args=(i, False, standard_results),&#10;                name=f&quot;Std-Thread-{i}&quot;&#10;            )&#10;            standard_threads.append(t)&#10;            t.start()&#10;            # Brief sleep between thread starts&#10;            time.sleep(0.01)&#10;            &#10;        print(f&quot;Started {len(standard_threads)} standard threads&quot;)&#10;            &#10;        # Join with timeout to prevent hanging&#10;        for t in standard_threads:&#10;            t.join(timeout=10.0)  # 10 second timeout per thread&#10;            if t.is_alive():&#10;                print(f&quot;Warning: Thread {t.name} did not complete in time&quot;)&#10;                &#10;    except Exception as e:&#10;        print(f&quot;Error during standard thread execution: {str(e)}&quot;)&#10;&#10;    standard_time = time.time() - start_time&#10;    print(f&quot;Standard thread test completed in {standard_time:.2f} seconds&quot;)&#10;&#10;    # Test thread-safe implementation if available&#10;    threadsafe_time = 0&#10;    threadsafe_results = []&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nRunning thread-safe RNG with multiple threads...&quot;)&#10;        threadsafe_threads = []&#10;&#10;        start_time = time.time()&#10;        &#10;        try:&#10;            for i in range(num_threads):&#10;                t = threading.Thread(&#10;                    target=worker_thread,&#10;                    args=(i, True, threadsafe_results),&#10;                    name=f&quot;Safe-Thread-{i}&quot;&#10;                )&#10;                threadsafe_threads.append(t)&#10;                t.start()&#10;                # Brief sleep between thread starts&#10;                time.sleep(0.01)&#10;                &#10;            print(f&quot;Started {len(threadsafe_threads)} thread-safe threads&quot;)&#10;                &#10;            # Join with timeout to prevent hanging&#10;            for t in threadsafe_threads:&#10;                t.join(timeout=10.0)&#10;                if t.is_alive():&#10;                    print(f&quot;Warning: Thread {t.name} did not complete in time&quot;)&#10;                    &#10;        except Exception as e:&#10;            print(f&quot;Error during thread-safe thread execution: {str(e)}&quot;)&#10;&#10;        threadsafe_time = time.time() - start_time&#10;        print(f&quot;Thread-safe test completed in {threadsafe_time:.2f} seconds&quot;)&#10;&#10;    # Print results summary - only if we have any results&#10;    if standard_results:&#10;        print(&quot;\nResults Summary:&quot;)&#10;        print(&quot;--------------&quot;)&#10;        print(f&quot;Standard RNG: {len(standard_results)} operations in {standard_time:.3f}s&quot;)&#10;        print(f&quot;  - Success rate: {(len(standard_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;        print(f&quot;  - Failures: {standard_failures}&quot;)&#10;        if standard_results:&#10;            print(f&quot;  - Avg time per operation: {standard_time / max(len(standard_results), 1):.6f}s&quot;)&#10;&#10;        if thread_safe_available and threadsafe_results:&#10;            print(f&quot;\nThread-safe RNG: {len(threadsafe_results)} operations in {threadsafe_time:.3f}s&quot;)&#10;            print(f&quot;  - Success rate: {(len(threadsafe_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;            print(f&quot;  - Failures: {threadsafe_failures}&quot;)&#10;            print(f&quot;  - Avg time per operation: {threadsafe_time / max(len(threadsafe_results), 1):.6f}s&quot;)&#10;&#10;            # Performance comparison&#10;            if standard_time &gt; 0 and threadsafe_time &gt; 0 and len(standard_results) &gt; 0 and len(threadsafe_results) &gt; 0:&#10;                relative_perf = standard_time / threadsafe_time&#10;                if relative_perf &gt; 1:&#10;                    print(f&quot;\nThread-safe implementation is {relative_perf:.2f}x faster than standard&quot;)&#10;                else:&#10;                    print(f&quot;\nStandard implementation is {1/relative_perf:.2f}x faster than thread-safe&quot;)&#10;    else:&#10;        print(&quot;\nNo results collected! Test failed to run properly.&quot;)&#10;&#10;    # Show a sample of random values from each&#10;    print(&quot;\nSample Standard RNG values:&quot;)&#10;    for i, result in enumerate(standard_results[:5]):&#10;        if 'error' in result:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;        else:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;    if thread_safe_available and threadsafe_results:&#10;        print(&quot;\nSample Thread-safe RNG values:&quot;)&#10;        for i, result in enumerate(threadsafe_results[:5]):&#10;            if 'error' in result:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;            else:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    thread_safe_example()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyCTools/Overview.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyCTools/Overview.md" />
              <option name="originalContent" value="# PyCTools Library Documentation&#10;&#10;## Overview&#10;&#10;PyCTools is a high-performance Python library that provides native C-backed functionality for system-level operations that require maximum performance and direct hardware access. The library bridges Python's ease of use with C's raw performance through carefully designed wrapper classes.&#10;&#10;## Components&#10;&#10;The library currently consists of two main modules:&#10;&#10;1. **hwrng** - Hardware-based Random Number Generator that interfaces with CPU hardware to generate cryptographically secure random numbers at maximum performance.&#10;&#10;2. **processInspect** - Advanced process metrics collection system for detailed system and process monitoring with minimal overhead.&#10;&#10;## Key Strengths&#10;&#10;- **Native Performance**: Direct access to hardware and system resources via compiled C/C++ code&#10;- **Cross-Architecture Support**: Works on both x86 and x64 Windows environments&#10;- **Thread Safety**: Designed for concurrent operation in multithreaded environments&#10;- **Comprehensive Metrics**: Detailed process and system statistics beyond what's available in standard Python libraries&#10;- **Hardware RNG**: True random number generation using CPU hardware features&#10;- **Minimal Overhead**: Engineered to add negligible performance impact while monitoring&#10;&#10;## Usage Domains&#10;&#10;- Performance monitoring and diagnostics&#10;- Security applications requiring cryptographically secure random numbers&#10;- System administration and monitoring tools&#10;- Performance-critical scientific or financial applications&#10;&#10;Each module is documented in detail in its dedicated documentation file.&#10;&#10;" />
              <option name="updatedContent" value="# PyCTools Library Documentation&#10;&#10;## Overview&#10;&#10;PyCTools is a high-performance Python library that provides native C-backed functionality for system-level operations that require maximum performance and direct hardware access. The library bridges Python's ease of use with C's raw performance through carefully designed wrapper classes that interface with compiled native code.&#10;&#10;## Components&#10;&#10;The library currently consists of two main modules:&#10;&#10;1. **hwrng** - Hardware-based Random Number Generator that interfaces with CPU hardware to generate cryptographically secure random numbers at maximum performance. It utilizes the CPU's RDRAND instruction (where available) for true hardware randomness.&#10;&#10;2. **processInspect** - Advanced process metrics collection system for detailed system and process monitoring with minimal overhead. Provides comprehensive performance data for Windows processes beyond standard Python libraries.&#10;&#10;## Architecture&#10;&#10;PyCTools employs a hybrid architecture:&#10;&#10;- **Python Layer**: Clean, Pythonic wrapper classes providing a user-friendly API&#10;- **Native Layer**: High-performance C/C++ code compiled to architecture-specific DLLs&#10;- **Dynamic Loading**: Intelligent DLL loader that automatically selects the correct binary for the host architecture&#10;&#10;The library uses a centralized DLL loading mechanism through the `_loadDLL` module, which implements sophisticated path resolution and error handling to ensure reliable operation across different environments.&#10;&#10;## Key Strengths&#10;&#10;- **Native Performance**: Direct access to hardware and system resources via compiled C/C++ code&#10;- **Cross-Architecture Support**: Works seamlessly on both x86 and x64 Windows environments&#10;- **Thread Safety**: Designed for concurrent operation in multithreaded environments&#10;- **Comprehensive Metrics**: Detailed process and system statistics beyond what's available in standard Python libraries&#10;- **Hardware RNG**: True random number generation using CPU hardware features&#10;- **Minimal Overhead**: Engineered to add negligible performance impact while monitoring&#10;- **Robust DLL Management**: Intelligent DLL discovery and loading with clear error reporting&#10;- **Consistent API**: Uniform interface pattern across different modules for ease of use&#10;- **Detailed Documentation**: Comprehensive documentation with examples and best practices&#10;&#10;## Usage Domains&#10;&#10;- Performance monitoring and diagnostics&#10;- Security applications requiring cryptographically secure random numbers&#10;- System administration and monitoring tools&#10;- Performance-critical scientific or financial applications&#10;- Resource usage tracking and optimization&#10;- Application performance benchmarking&#10;&#10;Each module is documented in detail in its dedicated documentation file." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyCTools/hwrng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyCTools/hwrng.md" />
              <option name="originalContent" value="# Hardware Random Number Generator (hwrng) Module&#10;&#10;The OSS `/dev/urandom` of Windows.&#10;&#10;---&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hwrng.py&lt;/summary&gt;&#10;&#10;## hwrng.py&#10;&#10;&gt; This is not comprehensive at all&#10;&#10;### Features&#10;- Get cryptographically secure random bytes from hardware RNG (RDRAND).&#10;- Raises `HardwareRNGError` if not supported or DLL missing.&#10;&#10;### Usage&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;rb = get_hardware_random_bytes(32)&#10;print(rb.hex())&#10;```&#10;&#10;&lt;/details&gt;&#10;&#10;---&#10;&#10;&#10;## Module Overview&#10;&#10;The `hwrng` module provides a Python interface to hardware-based random number generation capabilities through the `MaxRNG` class. This class wraps a native C library that accesses CPU hardware random number generation features to produce high-quality random data with superior entropy compared to software-based PRNGs.&#10;&#10;## MaxRNG Class&#10;&#10;### Class Description&#10;`MaxRNG` is a wrapper class for hardware-based random number generation that interfaces with a native DLL (`hRng_x64.dll` or `hRng_x86.dll` depending on architecture). It automatically detects the system architecture and loads the appropriate binary.&#10;&#10;### Initialization&#10;```python&#10;rng = MaxRNG()&#10;```&#10;When instantiating the class, it performs the following operations:&#10;- Determines system architecture (x86/x64)&#10;- Searches for the appropriate DLL in multiple possible paths&#10;- Loads the DLL using ctypes&#10;- Sets up function prototypes and return types&#10;&#10;### Constants&#10;The class does not expose any constants directly.&#10;&#10;### Methods&#10;&#10;#### `test_rng_available() -&gt; bool`&#10;&#10;Checks if the hardware random number generator is available on the current system.&#10;&#10;**Returns:**&#10;- `True` if hardware RNG is available&#10;- `False` otherwise&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_rng_available():&#10;    print(&quot;Hardware RNG is available&quot;)&#10;else:&#10;    print(&quot;Hardware RNG is not available&quot;)&#10;```&#10;&#10;#### `test_threading_available() -&gt; bool`&#10;&#10;Checks if the thread-safe version of the RNG is available.&#10;&#10;**Returns:**&#10;- `True` if thread-safe RNG is available&#10;- `False` otherwise&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    print(&quot;Thread-safe RNG is available&quot;)&#10;else:&#10;    print(&quot;Thread-safe RNG is not available&quot;)&#10;```&#10;&#10;#### `maxrng(size: int) -&gt; bytes`&#10;&#10;Generates random bytes using the hardware RNG.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng(32)  # Generate 32 random bytes&#10;```&#10;&#10;#### `maxrng_ultra(size: int, complexity: int) -&gt; bytes`&#10;&#10;Generates random bytes with additional complexity for enhanced security.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;- `complexity` (int): Level of additional entropy mixing (higher values provide potentially better randomness but slower performance)&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng_ultra(32, 3)  # Generate 32 random bytes with complexity level 3&#10;```&#10;&#10;#### `maxrng_threadsafe(size: int) -&gt; bytes`&#10;&#10;Thread-safe version of the random number generator.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If threading is not available or if the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    random_data = rng.maxrng_threadsafe(32)  # Generate 32 random bytes in thread-safe mode&#10;```&#10;&#10;### Implementation Details&#10;&#10;#### DLL Loading&#10;The class implements a sophisticated DLL search mechanism that looks in multiple relative paths:&#10;- `./dist/{arch}/hRng_{arch}.dll`&#10;- `../dist/{arch}/hRng_{arch}.dll`&#10;- `../../dist/{arch}/hRng_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;#### Error Handling&#10;All methods perform proper error checking of the underlying C functions and raise appropriate exceptions with detailed error messages when operations fail.&#10;&#10;#### Memory Management&#10;The class handles all memory allocation and deallocation for the buffer used to store random data, ensuring no memory leaks occur during operation.&#10;&#10;## Usage Best Practices&#10;&#10;1. **Always check availability before use:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_rng_available():&#10;       # Proceed with RNG operations&#10;   ```&#10;&#10;2. **For thread-safe operations:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_threading_available():&#10;       # Proceed with thread-safe RNG operations&#10;   ```&#10;&#10;3. **Handle potential exceptions:**&#10;   ```python&#10;   try:&#10;       random_data = rng.maxrng(32)&#10;   except RuntimeError as e:&#10;       # Handle failure&#10;   ```&#10;&#10;4. **Choose the appropriate method:**&#10;   - `maxrng()` for standard random number generation&#10;   - `maxrng_ultra()` for higher security requirements&#10;   - `maxrng_threadsafe()` for multithreaded applications&#10;&#10;" />
              <option name="updatedContent" value="# Hardware Random Number Generator (hwrng) Module&#10;&#10;The OSS `/dev/urandom` of Windows.&#10;&#10;---&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hwrng.py&lt;/summary&gt;&#10;&#10;## hwrng.py&#10;&#10;&gt; This is not comprehensive at all&#10;&#10;### Features&#10;- Get cryptographically secure random bytes from hardware RNG (RDRAND).&#10;- Raises `HardwareRNGError` if not supported or DLL missing.&#10;&#10;### Usage&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;rb = get_hardware_random_bytes(32)&#10;print(rb.hex())&#10;```&#10;&#10;&lt;/details&gt;&#10;&#10;---&#10;&#10;## Module Overview&#10;&#10;The `hwrng` module provides a Python interface to hardware-based random number generation capabilities through the `MaxRNG` class. This class wraps a native C library that accesses CPU hardware random number generation features (like Intel's RDRAND instruction) to produce high-quality random data with superior entropy compared to software-based PRNGs.&#10;&#10;## MaxRNG Class&#10;&#10;### Class Description&#10;`MaxRNG` is a wrapper class for hardware-based random number generation that interfaces with a native DLL (`hRng_x64.dll` or `hRng_x86.dll` depending on architecture). It automatically detects the system architecture and loads the appropriate binary through the centralized `_loadDLL` module.&#10;&#10;### Initialization&#10;```python&#10;rng = MaxRNG()&#10;```&#10;&#10;When instantiating the class, it performs the following operations:&#10;- Loads the appropriate DLL using the `load_dll` helper function:&#10;  - Determines system architecture (x86/x64) automatically&#10;  - Searches for the appropriate DLL in the standard distribution paths&#10;  - Configures the loader to use `ctypes.WinDLL` specifically for this module&#10;- Sets up ctypes function prototypes and return types for type safety:&#10;  - Defines appropriate argument types for all DLL functions&#10;  - Defines appropriate return types for all DLL functions&#10;&#10;### DLL Loading Details&#10;&#10;The `MaxRNG` class uses the centralized `load_dll` function with these parameters:&#10;- `dll_prefix_name=&quot;hRng&quot;`: Loads either `hRng_x64.dll` or `hRng_x86.dll` based on architecture&#10;- `dll_load_func=ctypes.WinDLL`: Uses WinDLL loader specifically for the Windows API functions used in this module&#10;&#10;The DLL search mechanism looks in these locations by default:&#10;- `./dist/{arch}/hRng_{arch}.dll`&#10;- `../dist/{arch}/hRng_{arch}.dll`&#10;- `../../dist/{arch}/hRng_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;### Methods&#10;&#10;#### `test_rng_available() -&gt; bool`&#10;&#10;Checks if the hardware random number generator is available on the current system.&#10;&#10;**Returns:**&#10;- `True` if hardware RNG is available&#10;- `False` otherwise&#10;&#10;**Implementation Details:**&#10;- Calls the C function `test_rng_available()` in the DLL&#10;- Returns `True` if the function returns `1`, `False` otherwise&#10;- Does not throw exceptions, making it safe to use for feature detection&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_rng_available():&#10;    print(&quot;Hardware RNG is available&quot;)&#10;else:&#10;    print(&quot;Hardware RNG is not available&quot;)&#10;```&#10;&#10;#### `test_threading_available() -&gt; bool`&#10;&#10;Checks if the thread-safe version of the RNG is available.&#10;&#10;**Returns:**&#10;- `True` if thread-safe RNG is available&#10;- `False` otherwise&#10;&#10;**Implementation Details:**&#10;- Calls the C function `test_threading_available()` in the DLL&#10;- Returns `True` if the function returns `1`, `False` otherwise&#10;- Does not throw exceptions, making it safe to use for feature detection&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    print(&quot;Thread-safe RNG is available&quot;)&#10;else:&#10;    print(&quot;Thread-safe RNG is not available&quot;)&#10;```&#10;&#10;#### `maxrng(size: int) -&gt; bytes`&#10;&#10;Generates random bytes using the hardware RNG.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Implementation Details:**&#10;- Allocates a buffer of specified size using `ctypes.c_ubyte * size`&#10;- Calls the C function `maxrng` with the buffer and size&#10;- Checks the return value for success (non-zero)&#10;- Converts the ctypes buffer to Python bytes before returning&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng(32)  # Generate 32 random bytes&#10;```&#10;&#10;#### `maxrng_ultra(size: int, complexity: int) -&gt; bytes`&#10;&#10;Generates random bytes with additional complexity for enhanced security.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;- `complexity` (int): Level of additional entropy mixing (higher values provide potentially better randomness but slower performance)&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the RNG operation fails&#10;&#10;**Implementation Details:**&#10;- Allocates a buffer of specified size using `ctypes.c_ubyte * size`&#10;- Calls the C function `maxrng_ultra` with the buffer, size, and complexity level&#10;- Checks the return value for success (non-zero)&#10;- Converts the ctypes buffer to Python bytes before returning&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;random_data = rng.maxrng_ultra(32, 3)  # Generate 32 random bytes with complexity level 3&#10;```&#10;&#10;#### `maxrng_threadsafe(size: int) -&gt; bytes`&#10;&#10;Thread-safe version of the random number generator.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate&#10;&#10;**Returns:**&#10;- `bytes`: Random bytes of specified length&#10;&#10;**Raises:**&#10;- `RuntimeError`: If threading is not available or if the RNG operation fails&#10;&#10;**Implementation Details:**&#10;- First checks if threading is available by calling `test_threading_available()`&#10;- If not available, raises a detailed RuntimeError with best practices advice&#10;- Allocates a buffer of specified size using `ctypes.c_ubyte * size`&#10;- Calls the C function `maxrng_threadsafe` with the buffer and size&#10;- Checks the return value for success (non-zero)&#10;- Converts the ctypes buffer to Python bytes before returning&#10;&#10;**Example:**&#10;```python&#10;rng = MaxRNG()&#10;if rng.test_threading_available():&#10;    random_data = rng.maxrng_threadsafe(32)  # Generate 32 random bytes in thread-safe mode&#10;```&#10;&#10;### Error Handling&#10;&#10;The class implements comprehensive error handling:&#10;&#10;- **Feature Detection**: Non-throwing methods `test_rng_available()` and `test_threading_available()` for safely detecting capabilities&#10;- **Operation Validation**: All generator methods check return values and raise descriptive exceptions&#10;- **Threading Safety Check**: The `maxrng_threadsafe()` method validates threading availability before attempting operations&#10;- **Detailed Error Messages**: Clear error messages when operations fail, including best practices advice&#10;&#10;### Memory Management&#10;&#10;The class handles all memory allocation and deallocation for the buffer used to store random data, ensuring no memory leaks occur during operation:&#10;&#10;- Uses properly sized ctypes buffers for each operation&#10;- Converts C buffers to Python bytes objects which are managed by Python's garbage collector&#10;- Ensures C memory is properly released after each operation&#10;&#10;## Usage Best Practices&#10;&#10;1. **Always check availability before use:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_rng_available():&#10;       # Proceed with RNG operations&#10;   ```&#10;&#10;2. **For thread-safe operations:**&#10;   ```python&#10;   rng = MaxRNG()&#10;   if rng.test_threading_available():&#10;       # Proceed with thread-safe RNG operations&#10;   ```&#10;&#10;3. **Handle potential exceptions:**&#10;   ```python&#10;   try:&#10;       random_data = rng.maxrng(32)&#10;   except RuntimeError as e:&#10;       # Handle failure&#10;   ```&#10;&#10;4. **Choose the appropriate method:**&#10;   - `maxrng()` for standard random number generation&#10;   - `maxrng_ultra()` for higher security requirements&#10;   - `maxrng_threadsafe()` for multithreaded applications&#10;&#10;5. **Performance considerations:**&#10;   - `maxrng()` is the fastest method with basic hardware randomness&#10;   - `maxrng_ultra()` provides enhanced security at the cost of performance&#10;   - Lower complexity values in `maxrng_ultra()` offer better performance with reasonable security&#10;&#10;6. **Reuse the MaxRNG instance:**&#10;   ```python&#10;   # Create once, reuse multiple times&#10;   rng = MaxRNG()&#10;   &#10;   # Use in multiple places&#10;   data1 = rng.maxrng(32)&#10;   data2 = rng.maxrng(64)&#10;   ```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyCTools/pI.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyCTools/pI.md" />
              <option name="originalContent" value="# Process Inspection (processInspect) Module&#10;&#10;## Module Overview&#10;&#10;The `processInspect` module provides comprehensive process and system metrics collection capabilities through the `ProcessMetrics` class. This class interfaces with a native DLL to collect detailed metrics about Windows processes with minimal performance overhead, offering insights beyond what's available through standard Python libraries.&#10;&#10;## ProcessMetrics Class&#10;&#10;### Class Description&#10;`ProcessMetrics` is a wrapper class that interfaces with the native `processInspect` DLL to collect various system and process metrics on Windows systems. It supports both instant snapshots and time-span measurements for comprehensive performance analysis.&#10;&#10;### Initialization&#10;```python&#10;metrics = ProcessMetrics()&#10;```&#10;When instantiating the class, it:&#10;- Determines system architecture (x86/x64)&#10;- Searches for the appropriate DLL in multiple possible paths&#10;- Loads the DLL using ctypes&#10;- Sets up function prototypes and return types&#10;- Raises `FileNotFoundError` if the DLL cannot be found&#10;&#10;### Constants&#10;&#10;The class provides constants for selecting which metrics to collect:&#10;&#10;| Constant | Value | Description |&#10;|----------|-------|-------------|&#10;| `METRIC_WORKING_SET` | 0x01 | Memory currently in RAM (working set) |&#10;| `METRIC_PRIVATE_BYTES` | 0x02 | Memory exclusively allocated to the process |&#10;| `METRIC_PAGEFILE` | 0x04 | Memory usage in the pagefile |&#10;| `METRIC_HANDLES` | 0x08 | Number of handles open by the process |&#10;| `METRIC_THREADS` | 0x10 | Number of threads in the process |&#10;| `METRIC_CPU_USAGE` | 0x20 | CPU usage percentage |&#10;| `METRIC_IO` | 0x40 | I/O statistics (reads, writes) |&#10;| `METRIC_NET` | 0x80 | Network statistics |&#10;&#10;These constants can be combined using bitwise OR (`|`) to select multiple metrics.&#10;&#10;### Methods&#10;&#10;#### `start_session(pid: int, metrics: int) -&gt; bool`&#10;&#10;Starts a metrics collection session for a specific process.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to monitor&#10;- `metrics` (int): Bitmask of metrics to collect, using class constants&#10;&#10;**Returns:**&#10;- `bool`: `True` if session started successfully, `False` otherwise&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;success = pm.start_session(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;)&#10;```&#10;&#10;#### `end_session(pid: int, metrics: int) -&gt; dict`&#10;&#10;Ends a previously started metrics collection session and retrieves results.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID of the session to end&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Metrics collected during the session, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;# Start session first&#10;pm.start_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;# ... do some work ...&#10;# End session and get results&#10;results = pm.end_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;```&#10;&#10;#### `get_snapshot(pid: int, metrics: int) -&gt; dict`&#10;&#10;Retrieves an instant snapshot of metrics for a process without starting a session.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to query&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Current metrics snapshot, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;snapshot = pm.get_snapshot(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | &#10;    ProcessMetrics.METRIC_WORKING_SET | &#10;    ProcessMetrics.METRIC_HANDLES&#10;)&#10;```&#10;&#10;### Return Value Structure&#10;&#10;All methods that return metrics provide a dictionary with the following structure (keys present depend on requested metrics):&#10;&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,                    // Process ID&#10;  &quot;name&quot;: &quot;example.exe&quot;,          // Process name&#10;  &quot;timestamp&quot;: 1629384756,        // Unix timestamp&#10;  &quot;duration&quot;: 5.23,               // Duration in seconds (for session metrics)&#10;  &quot;cpu_usage&quot;: {                  // If METRIC_CPU_USAGE requested&#10;    &quot;percent&quot;: 14.5,              // CPU usage percentage&#10;    &quot;kernel_time&quot;: 0.234,         // Time spent in kernel mode (seconds)&#10;    &quot;user_time&quot;: 1.456            // Time spent in user mode (seconds)&#10;  },&#10;  &quot;memory&quot;: {                     // Memory metrics&#10;    &quot;working_set&quot;: 123456789,     // If METRIC_WORKING_SET requested (bytes)&#10;    &quot;private_bytes&quot;: 98765432,    // If METRIC_PRIVATE_BYTES requested (bytes)&#10;    &quot;pagefile&quot;: 45678912          // If METRIC_PAGEFILE requested (bytes)&#10;  },&#10;  &quot;handles&quot;: 345,                 // If METRIC_HANDLES requested&#10;  &quot;threads&quot;: 12,                  // If METRIC_THREADS requested&#10;  &quot;io&quot;: {                         // If METRIC_IO requested&#10;    &quot;reads&quot;: 1234,                // Number of read operations&#10;    &quot;writes&quot;: 5678,               // Number of write operations&#10;    &quot;bytes_read&quot;: 12345678,       // Total bytes read&#10;    &quot;bytes_written&quot;: 87654321     // Total bytes written&#10;  },&#10;  &quot;network&quot;: {                    // If METRIC_NET requested&#10;    &quot;bytes_sent&quot;: 123456,         // Total bytes sent&#10;    &quot;bytes_received&quot;: 654321      // Total bytes received&#10;  }&#10;}&#10;```&#10;&#10;### Implementation Details&#10;&#10;#### DLL Loading&#10;The class implements a DLL search mechanism that looks in multiple relative paths:&#10;- `./dist/{arch}/processInspect_{arch}.dll`&#10;- `../dist/{arch}/processInspect_{arch}.dll`&#10;- `../../dist/{arch}/processInspect_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;#### Internal Helper Methods&#10;`_json_call(func, pid, metrics)`: Internal helper method that calls DLL functions returning JSON data, handles the buffer, parses the JSON, and returns the result as a Python dictionary.&#10;&#10;#### Error Handling&#10;All methods perform proper error checking and raise appropriate exceptions with detailed error messages when operations fail.&#10;&#10;## Usage Best Practices&#10;&#10;### Selecting the Right Method&#10;&#10;- **For a single point-in-time measurement:**&#10;  ```python&#10;  snapshot = metrics.get_snapshot(pid, metrics_flags)&#10;  ```&#10;&#10;- **For measuring performance over time:**&#10;  ```python&#10;  metrics.start_session(pid, metrics_flags)&#10;  # ... time passes ...&#10;  results = metrics.end_session(pid, metrics_flags)&#10;  ```&#10;&#10;### Efficient Metric Collection&#10;&#10;Combine only the metrics you need to minimize overhead:&#10;&#10;```python&#10;# Only collect CPU and memory metrics&#10;flags = ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;```&#10;&#10;### Error Handling&#10;&#10;Always handle potential errors:&#10;&#10;```python&#10;try:&#10;    results = metrics.get_snapshot(pid, metrics_flags)&#10;except (RuntimeError, FileNotFoundError) as e:&#10;    print(f&quot;Error collecting metrics: {e}&quot;)&#10;```&#10;&#10;### Performance Monitoring Example&#10;&#10;```python&#10;import time&#10;from pyCTools import ProcessMetrics&#10;&#10;def monitor_process(pid, duration_seconds=60, interval_seconds=5):&#10;    metrics = ProcessMetrics()&#10;    flags = (ProcessMetrics.METRIC_CPU_USAGE | &#10;             ProcessMetrics.METRIC_WORKING_SET | &#10;             ProcessMetrics.METRIC_PRIVATE_BYTES)&#10;    &#10;    end_time = time.time() + duration_seconds&#10;    &#10;    while time.time() &lt; end_time:&#10;        try:&#10;            snapshot = metrics.get_snapshot(pid, flags)&#10;            print(f&quot;CPU: {snapshot['cpu_usage']['percent']}%, &quot;&#10;                  f&quot;Memory: {snapshot['memory']['working_set'] / (1024*1024):.2f} MB&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error: {e}&quot;)&#10;        &#10;        time.sleep(interval_seconds)&#10;```&#10;&#10;" />
              <option name="updatedContent" value="# Process Inspection (processInspect) Module&#10;&#10;## Module Overview&#10;&#10;The `processInspect` module provides comprehensive process and system metrics collection capabilities through the `ProcessMetrics` class. This class interfaces with a native DLL to collect detailed metrics about Windows processes with minimal performance overhead, offering insights beyond what's available through standard Python libraries.&#10;&#10;## ProcessMetrics Class&#10;&#10;### Class Description&#10;`ProcessMetrics` is a wrapper class that interfaces with the native `processInspect` DLL to collect various system and process metrics on Windows systems. It supports both instant snapshots and time-span measurements for comprehensive performance analysis.&#10;&#10;### Initialization&#10;```python&#10;metrics = ProcessMetrics()&#10;```&#10;&#10;When instantiating the class, it:&#10;- Loads the appropriate DLL using the `load_dll` helper function:&#10;  - Determines system architecture (x86/x64) automatically&#10;  - Searches for the appropriate DLL in the standard distribution paths&#10;  - Configures the loader to use `ctypes.CDLL` for this module's functions&#10;- Sets up ctypes function prototypes and return types for type safety:&#10;  - Defines appropriate argument types for all DLL functions&#10;  - Defines appropriate return types for all DLL functions&#10;&#10;### DLL Loading Details&#10;&#10;The `ProcessMetrics` class uses the centralized `load_dll` function with these parameters:&#10;- `dll_prefix_name=&quot;processInspect&quot;`: Loads either `processInspect_x64.dll` or `processInspect_x86.dll` based on architecture&#10;- `dll_load_func=ctypes.CDLL`: Uses standard CDLL loader for this module's C functions&#10;&#10;The DLL search mechanism looks in these locations by default:&#10;- `./dist/{arch}/processInspect_{arch}.dll`&#10;- `../dist/{arch}/processInspect_{arch}.dll`&#10;- `../../dist/{arch}/processInspect_{arch}.dll`&#10;&#10;Where `{arch}` is either `x64` or `x86` based on the detected platform architecture.&#10;&#10;### Constants&#10;&#10;The class provides constants for selecting which metrics to collect:&#10;&#10;| Constant | Value | Description |&#10;|----------|-------|-------------|&#10;| `METRIC_WORKING_SET` | 0x01 | Memory currently in RAM (working set) |&#10;| `METRIC_PRIVATE_BYTES` | 0x02 | Memory exclusively allocated to the process |&#10;| `METRIC_PAGEFILE` | 0x04 | Memory usage in the pagefile |&#10;| `METRIC_HANDLES` | 0x08 | Number of handles open by the process |&#10;| `METRIC_THREADS` | 0x10 | Number of threads in the process |&#10;| `METRIC_CPU_USAGE` | 0x20 | CPU usage percentage |&#10;| `METRIC_IO` | 0x40 | I/O statistics (reads, writes) |&#10;| `METRIC_NET` | 0x80 | Network statistics |&#10;&#10;These constants can be combined using bitwise OR (`|`) to select multiple metrics:&#10;&#10;```python&#10;# Select both CPU usage and working set metrics&#10;metrics_flags = ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;```&#10;&#10;### Methods&#10;&#10;#### `_json_call(func, pid: int, metrics: int, _buffer_size: int = 4096) -&gt; dict`&#10;&#10;Internal helper method that calls a DLL function that returns JSON data in a buffer, parses it, and returns it as a Python dictionary.&#10;&#10;**Parameters:**&#10;- `func` (callable): DLL function to call, which fills a buffer with JSON&#10;- `pid` (int): Process ID to query&#10;- `metrics` (int): Bitmask of metrics flags to request&#10;- `_buffer_size` (int): Size of the buffer to hold JSON data (default 4096 bytes)&#10;&#10;**Returns:**&#10;- `dict`: Parsed JSON metrics&#10;&#10;**Raises:**&#10;- `RuntimeError`: If the DLL function call returns failure&#10;&#10;**Implementation Details:**&#10;- Creates a string buffer of specified size (4KB default)&#10;- Calls the provided DLL function with pid, metrics flags, buffer pointer, and buffer size&#10;- Checks for successful return value&#10;- Decodes the buffer content from UTF-8 to a string&#10;- Parses the JSON string into a Python dictionary&#10;- Returns the parsed dictionary or raises an exception on failure&#10;&#10;#### `start_session(pid: int, metrics: int) -&gt; bool`&#10;&#10;Starts a metrics collection session for a specific process.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to monitor&#10;- `metrics` (int): Bitmask of metrics to collect, using class constants&#10;&#10;**Returns:**&#10;- `bool`: `True` if session started successfully, `False` otherwise&#10;&#10;**Implementation Details:**&#10;- Directly calls the native DLL's `start_metrics_collection` function&#10;- Returns a boolean indicating success or failure&#10;- Does not raise exceptions for failure, allowing for graceful handling by caller&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;success = pm.start_session(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;)&#10;```&#10;&#10;#### `end_session(pid: int, metrics: int) -&gt; dict`&#10;&#10;Ends a previously started metrics collection session and retrieves results.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID of the session to end&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Metrics collected during the session, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Implementation Details:**&#10;- Uses the internal `_json_call` helper to call the `end_metrics_collection` DLL function&#10;- Provides a detailed exception if the operation fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;# Start session first&#10;pm.start_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;# ... do some work ...&#10;# End session and get results&#10;results = pm.end_session(1234, ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET)&#10;```&#10;&#10;#### `get_snapshot(pid: int, metrics: int) -&gt; dict`&#10;&#10;Retrieves an instant snapshot of metrics for a process without starting a session.&#10;&#10;**Parameters:**&#10;- `pid` (int): Process ID to query&#10;- `metrics` (int): Bitmask of metrics to retrieve&#10;&#10;**Returns:**&#10;- `dict`: Current metrics snapshot, parsed from JSON&#10;&#10;**Raises:**&#10;- `RuntimeError`: If metric collection fails&#10;&#10;**Implementation Details:**&#10;- Uses the internal `_json_call` helper to call the `get_metrics_json` DLL function&#10;- Provides a detailed exception if the operation fails&#10;&#10;**Example:**&#10;```python&#10;pm = ProcessMetrics()&#10;snapshot = pm.get_snapshot(&#10;    1234,  # PID to monitor&#10;    ProcessMetrics.METRIC_CPU_USAGE | &#10;    ProcessMetrics.METRIC_WORKING_SET | &#10;    ProcessMetrics.METRIC_HANDLES&#10;)&#10;```&#10;&#10;### Return Value Structure&#10;&#10;All methods that return metrics provide a dictionary with the following structure (keys present depend on requested metrics):&#10;&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,                    // Process ID&#10;  &quot;name&quot;: &quot;example.exe&quot;,          // Process name&#10;  &quot;timestamp&quot;: 1629384756,        // Unix timestamp&#10;  &quot;duration&quot;: 5.23,               // Duration in seconds (for session metrics)&#10;  &quot;cpu_usage&quot;: {                  // If METRIC_CPU_USAGE requested&#10;    &quot;percent&quot;: 14.5,              // CPU usage percentage&#10;    &quot;kernel_time&quot;: 0.234,         // Time spent in kernel mode (seconds)&#10;    &quot;user_time&quot;: 1.456            // Time spent in user mode (seconds)&#10;  },&#10;  &quot;memory&quot;: {                     // Memory metrics&#10;    &quot;working_set&quot;: 123456789,     // If METRIC_WORKING_SET requested (bytes)&#10;    &quot;private_bytes&quot;: 98765432,    // If METRIC_PRIVATE_BYTES requested (bytes)&#10;    &quot;pagefile&quot;: 45678912          // If METRIC_PAGEFILE requested (bytes)&#10;  },&#10;  &quot;handles&quot;: 345,                 // If METRIC_HANDLES requested&#10;  &quot;threads&quot;: 12,                  // If METRIC_THREADS requested&#10;  &quot;io&quot;: {                         // If METRIC_IO requested&#10;    &quot;reads&quot;: 1234,                // Number of read operations&#10;    &quot;writes&quot;: 5678,               // Number of write operations&#10;    &quot;bytes_read&quot;: 12345678,       // Total bytes read&#10;    &quot;bytes_written&quot;: 87654321     // Total bytes written&#10;  },&#10;  &quot;network&quot;: {                    // If METRIC_NET requested&#10;    &quot;bytes_sent&quot;: 123456,         // Total bytes sent&#10;    &quot;bytes_received&quot;: 654321      // Total bytes received&#10;  }&#10;}&#10;```&#10;&#10;### Error Handling&#10;&#10;The class implements robust error handling:&#10;&#10;- **Buffer Allocation**: Creates appropriately sized buffers for JSON responses&#10;- **Return Value Checking**: Verifies all DLL function calls succeed&#10;- **Exception Handling**: Raises descriptive RuntimeError with process ID on failure&#10;- **JSON Parsing**: Safely decodes and parses JSON data from the native DLL&#10;&#10;## Usage Best Practices&#10;&#10;### Selecting the Right Method&#10;&#10;- **For a single point-in-time measurement:**&#10;  ```python&#10;  snapshot = metrics.get_snapshot(pid, metrics_flags)&#10;  ```&#10;&#10;- **For measuring performance over time:**&#10;  ```python&#10;  metrics.start_session(pid, metrics_flags)&#10;  # ... time passes ...&#10;  results = metrics.end_session(pid, metrics_flags)&#10;  ```&#10;&#10;### Efficient Metric Collection&#10;&#10;Combine only the metrics you need to minimize overhead:&#10;&#10;```python&#10;# Only collect CPU and memory metrics&#10;flags = ProcessMetrics.METRIC_CPU_USAGE | ProcessMetrics.METRIC_WORKING_SET&#10;```&#10;&#10;### Error Handling&#10;&#10;Always handle potential errors:&#10;&#10;```python&#10;try:&#10;    results = metrics.get_snapshot(pid, metrics_flags)&#10;except (RuntimeError, FileNotFoundError) as e:&#10;    print(f&quot;Error collecting metrics: {e}&quot;)&#10;```&#10;&#10;### Reuse ProcessMetrics Instance&#10;&#10;For efficiency, create a single instance and reuse it:&#10;&#10;```python&#10;# Create once&#10;metrics = ProcessMetrics()&#10;&#10;# Use for multiple operations&#10;metrics.start_session(pid1, flags)&#10;snapshot = metrics.get_snapshot(pid2, flags)&#10;results = metrics.end_session(pid1, flags)&#10;```&#10;&#10;### Performance Monitoring Example&#10;&#10;```python&#10;import time&#10;from pyCTools import ProcessMetrics&#10;&#10;def monitor_process(pid, duration_seconds=60, interval_seconds=5):&#10;    metrics = ProcessMetrics()&#10;    flags = (ProcessMetrics.METRIC_CPU_USAGE | &#10;             ProcessMetrics.METRIC_WORKING_SET | &#10;             ProcessMetrics.METRIC_PRIVATE_BYTES)&#10;    &#10;    end_time = time.time() + duration_seconds&#10;    &#10;    while time.time() &lt; end_time:&#10;        try:&#10;            snapshot = metrics.get_snapshot(pid, flags)&#10;            print(f&quot;CPU: {snapshot['cpu_usage']['percent']}%, &quot;&#10;                  f&quot;Memory: {snapshot['memory']['working_set'] / (1024*1024):.2f} MB&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error: {e}&quot;)&#10;        &#10;        time.sleep(interval_seconds)&#10;```&#10;&#10;### Working with Multiple Processes&#10;&#10;```python&#10;import time&#10;from pyCTools import ProcessMetrics&#10;&#10;def compare_processes(pids, metrics_flags):&#10;    pm = ProcessMetrics()&#10;    results = {}&#10;    &#10;    # Start sessions for all processes&#10;    for pid in pids:&#10;        pm.start_session(pid, metrics_flags)&#10;    &#10;    # Wait for some time&#10;    time.sleep(30)&#10;    &#10;    # End sessions and collect results&#10;    for pid in pids:&#10;        try:&#10;            results[pid] = pm.end_session(pid, metrics_flags)&#10;        except RuntimeError as e:&#10;            results[pid] = f&quot;Error: {e}&quot;&#10;    &#10;    return results&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.c" />
              <option name="originalContent" value="#define CRT_SECURE_NO_WARNINGS&#10;#include &lt;windows.h&gt;&#10;#include &lt;intrin.h&gt;&#10;#include &lt;stdint.h&gt;&#10;#include &lt;bcrypt.h&gt;&#10;#include &lt;psapi.h&gt;&#10;#include &lt;iphlpapi.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;#pragma comment(lib, &quot;bcrypt.lib&quot;)&#10;#pragma comment(lib, &quot;winmm.lib&quot;)&#10;#pragma comment(lib, &quot;iphlpapi.lib&quot;)&#10;#pragma comment(lib, &quot;psapi.lib&quot;)&#10;&#10;// Globals for thread safety&#10;static CRITICAL_SECTION g_rngLock;&#10;static volatile LONG g_threadingInitialized = 0;&#10;&#10;&#10;static int rdrand_supported()&#10;{&#10;    int cpuInfo[4];&#10;    __cpuid(cpuInfo, 1);&#10;    return (cpuInfo[2] &amp; (1 &lt;&lt; 30)) != 0;&#10;}&#10;&#10;// Retry RDRAND 10 times max&#10;static int rdrand32_retry(uint32_t *val)&#10;{&#10;    for (int i = 0; i &lt; 10; i++)&#10;    {&#10;        if (_rdrand32_step(val))&#10;            return 1;&#10;    }&#10;    return 0;&#10;}&#10;&#10;// Collect CPU info entropy: CPUID and RDTSC&#10;static void collect_cpu_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    int cpuInfo[4];&#10;    __cpuid(cpuInfo, 0);&#10;    BCryptHashData(hHash, (PUCHAR)cpuInfo, sizeof(cpuInfo), 0);&#10;&#10;    __cpuid(cpuInfo, 1);&#10;    BCryptHashData(hHash, (PUCHAR)cpuInfo, sizeof(cpuInfo), 0);&#10;&#10;    uint64_t tsc = __rdtsc();&#10;    BCryptHashData(hHash, (PUCHAR)&amp;tsc, sizeof(tsc), 0);&#10;}&#10;&#10;// Process memory info entropy&#10;static void collect_process_memory_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    PROCESS_MEMORY_COUNTERS pmc = { 0 };&#10;    if (GetProcessMemoryInfo(GetCurrentProcess(), &amp;pmc, sizeof(pmc)))&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;pmc, sizeof(pmc), 0);&#10;    }&#10;}&#10;&#10;// Performance counter entropy&#10;static void collect_perf_counter_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    LARGE_INTEGER counter;&#10;    if (QueryPerformanceCounter(&amp;counter))&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;counter, sizeof(counter), 0);&#10;    }&#10;}&#10;&#10;// Disk free space entropy&#10;static void collect_disk_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    ULARGE_INTEGER freeBytesAvailable, totalNumberOfBytes, totalNumberOfFreeBytes;&#10;    if (GetDiskFreeSpaceExA(&quot;C:\\&quot;, &amp;freeBytesAvailable, &amp;totalNumberOfBytes, &amp;totalNumberOfFreeBytes))&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;freeBytesAvailable, sizeof(freeBytesAvailable), 0);&#10;        BCryptHashData(hHash, (PUCHAR)&amp;totalNumberOfBytes, sizeof(totalNumberOfBytes), 0);&#10;        BCryptHashData(hHash, (PUCHAR)&amp;totalNumberOfFreeBytes, sizeof(totalNumberOfFreeBytes), 0);&#10;    }&#10;}&#10;&#10;// Audio entropy fallback (simple timing fallback)&#10;static void collect_audio_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    // Simplified: no real audio capture to keep minimal&#10;    // Just hash QueryPerformanceCounter several times with Sleep&#10;    for (int i = 0; i &lt; 5; i++)&#10;    {&#10;        LARGE_INTEGER counter;&#10;        QueryPerformanceCounter(&amp;counter);&#10;        BCryptHashData(hHash, (PUCHAR)&amp;counter, sizeof(counter), 0);&#10;        Sleep(10);&#10;    }&#10;}&#10;&#10;// Battery info entropy&#10;static void collect_battery_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    SYSTEM_POWER_STATUS status = { 0 };&#10;    if (GetSystemPowerStatus(&amp;status))&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;status, sizeof(status), 0);&#10;    }&#10;}&#10;&#10;// Network stats entropy&#10;static void collect_network_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    MIB_TCPSTATS stats = { 0 };&#10;    if (GetTcpStatistics(&amp;stats) == NO_ERROR)&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;stats, sizeof(stats), 0);&#10;    }&#10;&#10;    // Adapter info&#10;    ULONG size = 0;&#10;    GetAdaptersInfo(NULL, &amp;size);&#10;    if (size &gt; 0)&#10;    {&#10;        // ReSharper disable once CppLocalVariableMayBeConst&#10;        PIP_ADAPTER_INFO pAdapterInfo = (PIP_ADAPTER_INFO)malloc(size);&#10;        if (pAdapterInfo)&#10;        {&#10;            if (GetAdaptersInfo(pAdapterInfo, &amp;size) == NO_ERROR)&#10;            {&#10;                BCryptHashData(hHash, (PUCHAR)pAdapterInfo, size, 0);&#10;            }&#10;            free(pAdapterInfo);&#10;        }&#10;    }&#10;}&#10;&#10;// Combine all entropy sources and hash to buffer with complexity rounds&#10;static int collect_entropy(unsigned char *buffer, const int size, const int complexity)&#10;{&#10;    BCRYPT_ALG_HANDLE hAlg = NULL;&#10;    BCRYPT_HASH_HANDLE hHash = NULL;&#10;    DWORD cbHash = 0, cbData = 0;&#10;    unsigned char hash[32]; // SHA256&#10;&#10;    NTSTATUS status = BCryptOpenAlgorithmProvider(&amp;hAlg, BCRYPT_SHA256_ALGORITHM, NULL, 0);&#10;    if (!BCRYPT_SUCCESS(status)) return 0;&#10;&#10;    status = BCryptGetProperty(hAlg, BCRYPT_HASH_LENGTH, (PUCHAR)&amp;cbHash, sizeof(DWORD), &amp;cbData, 0);&#10;    if (!BCRYPT_SUCCESS(status)) { BCryptCloseAlgorithmProvider(hAlg, 0); return 0; }&#10;    if (cbHash != 32) { BCryptCloseAlgorithmProvider(hAlg, 0); return 0; }&#10;&#10;    // Create hash object&#10;    status = BCryptCreateHash(hAlg, &amp;hHash, NULL, 0, NULL, 0, 0);&#10;    if (!BCRYPT_SUCCESS(status)) { BCryptCloseAlgorithmProvider(hAlg, 0); return 0; }&#10;&#10;    for (int round = 0; round &lt; complexity; round++)&#10;    {&#10;        // RDRAND entropy&#10;        if (rdrand_supported())&#10;        {&#10;            uint32_t rndVal = 0;&#10;            if (rdrand32_retry(&amp;rndVal))&#10;            {&#10;                BCryptHashData(hHash, (PUCHAR)&amp;rndVal, sizeof(rndVal), 0);&#10;            }&#10;        }&#10;&#10;        collect_cpu_entropy(hHash);&#10;        collect_process_memory_entropy(hHash);&#10;        collect_perf_counter_entropy(hHash);&#10;        collect_disk_entropy(hHash);&#10;        collect_audio_entropy(hHash);&#10;        collect_battery_entropy(hHash);&#10;        collect_network_entropy(hHash);&#10;&#10;        // Finalize this round hash&#10;        status = BCryptFinishHash(hHash, hash, cbHash, 0);&#10;        if (!BCRYPT_SUCCESS(status))&#10;        {&#10;            const NTSTATUS destroyStatus = BCryptDestroyHash(hHash);&#10;            const NTSTATUS closeStatus = BCryptCloseAlgorithmProvider(hAlg, 0);&#10;            (void)destroyStatus;&#10;            (void)closeStatus;&#10;            return 0;&#10;        }&#10;&#10;        // Feed hash again for next round if more than 1 round&#10;        if (round + 1 &lt; complexity)&#10;        {&#10;            status = BCryptDestroyHash(hHash);&#10;            if (!BCRYPT_SUCCESS(status))&#10;            {&#10;                const NTSTATUS closeStatus = BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                (void)closeStatus;&#10;                return 0;&#10;            }&#10;            status = BCryptCreateHash(hAlg, &amp;hHash, NULL, 0, NULL, 0, 0);&#10;            if (!BCRYPT_SUCCESS(status))&#10;            {&#10;                const NTSTATUS closeStatus = BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                (void)closeStatus;&#10;                return 0;&#10;            }&#10;            const NTSTATUS hashStatus = BCryptHashData(hHash, hash, cbHash, 0);&#10;            if (!BCRYPT_SUCCESS(hashStatus)) {&#10;                const NTSTATUS destroyHashStatus = BCryptDestroyHash(hHash);&#10;                const NTSTATUS closeAlgStatus = BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                (void)destroyHashStatus;&#10;                (void)closeAlgStatus;&#10;                return 0;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Generate unique random bytes for the entire buffer&#10;    // First, copy the initial hash block&#10;    int bytesRemaining = size;&#10;    int offset = 0;&#10;&#10;    // Copy first block (up to 32 bytes)&#10;    int bytesToCopy = (bytesRemaining &lt; cbHash) ? bytesRemaining : cbHash;&#10;    memcpy(buffer, hash, bytesToCopy);&#10;    bytesRemaining -= bytesToCopy;&#10;    offset += bytesToCopy;&#10;&#10;    // For larger buffers, we need to generate additional unique blocks&#10;    if (bytesRemaining &gt; 0) {&#10;        // Create new hash for additional blocks&#10;        status = BCryptDestroyHash(hHash);&#10;        if (!BCRYPT_SUCCESS(status)) {&#10;            BCryptCloseAlgorithmProvider(hAlg, 0);&#10;            return 0;&#10;        }&#10;&#10;        // Use counter mode to generate unique blocks&#10;        uint32_t counter = 1; // Start from 1 since we already used block 0&#10;&#10;        while (bytesRemaining &gt; 0) {&#10;            status = BCryptCreateHash(hAlg, &amp;hHash, NULL, 0, NULL, 0, 0);&#10;            if (!BCRYPT_SUCCESS(status)) {&#10;                BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                return 0;&#10;            }&#10;&#10;            // Hash the previous output + counter for chaining&#10;            status = BCryptHashData(hHash, hash, cbHash, 0);&#10;            if (!BCRYPT_SUCCESS(status)) {&#10;                BCryptDestroyHash(hHash);&#10;                BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                return 0;&#10;            }&#10;&#10;            status = BCryptHashData(hHash, (PUCHAR)&amp;counter, sizeof(counter), 0);&#10;            if (!BCRYPT_SUCCESS(status)) {&#10;                BCryptDestroyHash(hHash);&#10;                BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                return 0;&#10;            }&#10;&#10;            // Generate next block&#10;            status = BCryptFinishHash(hHash, hash, cbHash, 0);&#10;            if (!BCRYPT_SUCCESS(status)) {&#10;                BCryptDestroyHash(hHash);&#10;                BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                return 0;&#10;            }&#10;&#10;            // Copy to output buffer&#10;            bytesToCopy = (bytesRemaining &lt; cbHash) ? bytesRemaining : cbHash;&#10;            memcpy(buffer + offset, hash, bytesToCopy);&#10;            bytesRemaining -= bytesToCopy;&#10;            offset += bytesToCopy;&#10;            counter++;&#10;&#10;            BCryptDestroyHash(hHash);&#10;        }&#10;    }&#10;&#10;    BCryptCloseAlgorithmProvider(hAlg, 0);&#10;    return 1;&#10;}&#10;&#10;// PUBLIC API&#10;&#10;// Returns 1 if RDRAND is supported, else 0&#10;__declspec(dllexport) int test_rng_available(void)&#10;{&#10;    return rdrand_supported() ? 1 : 0;&#10;}&#10;&#10;// Returns 1 if threading primitives initialized or initializes now&#10;__declspec(dllexport) int test_threading_available(void)&#10;{&#10;    return InterlockedCompareExchange(&amp;g_threadingInitialized, 0, 0) != 0 ? 1 : 0;&#10;}&#10;&#10;// Basic RNG, complexity 1&#10;__declspec(dllexport) int maxrng(unsigned char *buffer, const int size)&#10;{&#10;    if (!buffer || size &lt;= 0) return 0;&#10;    return collect_entropy(buffer, size, 1);&#10;}&#10;&#10;// Ultra RNG with complexity param, limits from 1 to 10&#10;__declspec(dllexport) int maxrng_ultra(unsigned char *buffer, const int size, int complexity)&#10;{&#10;    if (!buffer || size &lt;= 0) return 0;&#10;    if (complexity &lt; 1) complexity = 1;&#10;    if (complexity &gt; 10) complexity = 10;&#10;    return collect_entropy(buffer, size, complexity);&#10;}&#10;&#10;// Initializes threading primitives if not already done&#10;__declspec(dllexport) void maxrng_init(void)&#10;{&#10;    if (InterlockedCompareExchange(&amp;g_threadingInitialized, 1, 0) == 0) {&#10;        InitializeCriticalSection(&amp;g_rngLock);&#10;    }&#10;}&#10;&#10;// Thread-safe version, uses critical section lock&#10;__declspec(dllexport) int maxrng_threadsafe(unsigned char *buffer, const int size)&#10;{&#10;    if (!buffer || size &lt;= 0) return 0;&#10;    EnterCriticalSection(&amp;g_rngLock);&#10;    const int result = collect_entropy(buffer, size, 1);&#10;    LeaveCriticalSection(&amp;g_rngLock);&#10;    return result;&#10;}&#10;" />
              <option name="updatedContent" value="#define CRT_SECURE_NO_WARNINGS&#10;#include &lt;windows.h&gt;&#10;#include &lt;intrin.h&gt;&#10;#include &lt;stdint.h&gt;&#10;#include &lt;bcrypt.h&gt;&#10;#include &lt;psapi.h&gt;&#10;#include &lt;iphlpapi.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;#pragma comment(lib, &quot;bcrypt.lib&quot;)&#10;#pragma comment(lib, &quot;winmm.lib&quot;)&#10;#pragma comment(lib, &quot;iphlpapi.lib&quot;)&#10;#pragma comment(lib, &quot;psapi.lib&quot;)&#10;&#10;// Globals for thread safety&#10;static CRITICAL_SECTION g_rngLock;&#10;static volatile LONG g_threadingInitialized = 0;&#10;&#10;&#10;static int rdrand_supported()&#10;{&#10;    int cpuInfo[4];&#10;    __cpuid(cpuInfo, 1);&#10;    return (cpuInfo[2] &amp; (1 &lt;&lt; 30)) != 0;&#10;}&#10;&#10;// Retry RDRAND 10 times max&#10;static int rdrand32_retry(uint32_t *val)&#10;{&#10;    for (int i = 0; i &lt; 10; i++)&#10;    {&#10;        if (_rdrand32_step(val))&#10;            return 1;&#10;    }&#10;    return 0;&#10;}&#10;&#10;// Collect CPU info entropy: CPUID and RDTSC&#10;static void collect_cpu_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    int cpuInfo[4];&#10;    __cpuid(cpuInfo, 0);&#10;    BCryptHashData(hHash, (PUCHAR)cpuInfo, sizeof(cpuInfo), 0);&#10;&#10;    __cpuid(cpuInfo, 1);&#10;    BCryptHashData(hHash, (PUCHAR)cpuInfo, sizeof(cpuInfo), 0);&#10;&#10;    uint64_t tsc = __rdtsc();&#10;    BCryptHashData(hHash, (PUCHAR)&amp;tsc, sizeof(tsc), 0);&#10;}&#10;&#10;// Process memory info entropy&#10;static void collect_process_memory_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    PROCESS_MEMORY_COUNTERS pmc = { 0 };&#10;    if (GetProcessMemoryInfo(GetCurrentProcess(), &amp;pmc, sizeof(pmc)))&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;pmc, sizeof(pmc), 0);&#10;    }&#10;}&#10;&#10;// Performance counter entropy&#10;static void collect_perf_counter_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    LARGE_INTEGER counter;&#10;    if (QueryPerformanceCounter(&amp;counter))&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;counter, sizeof(counter), 0);&#10;    }&#10;}&#10;&#10;// Disk free space entropy&#10;static void collect_disk_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    ULARGE_INTEGER freeBytesAvailable, totalNumberOfBytes, totalNumberOfFreeBytes;&#10;    if (GetDiskFreeSpaceExA(&quot;C:\\&quot;, &amp;freeBytesAvailable, &amp;totalNumberOfBytes, &amp;totalNumberOfFreeBytes))&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;freeBytesAvailable, sizeof(freeBytesAvailable), 0);&#10;        BCryptHashData(hHash, (PUCHAR)&amp;totalNumberOfBytes, sizeof(totalNumberOfBytes), 0);&#10;        BCryptHashData(hHash, (PUCHAR)&amp;totalNumberOfFreeBytes, sizeof(totalNumberOfFreeBytes), 0);&#10;    }&#10;}&#10;&#10;// Audio entropy fallback (simple timing fallback)&#10;static void collect_audio_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    // Simplified: no real audio capture to keep minimal&#10;    // Just hash QueryPerformanceCounter several times with Sleep&#10;    for (int i = 0; i &lt; 5; i++)&#10;    {&#10;        LARGE_INTEGER counter;&#10;        QueryPerformanceCounter(&amp;counter);&#10;        BCryptHashData(hHash, (PUCHAR)&amp;counter, sizeof(counter), 0);&#10;        Sleep(10);&#10;    }&#10;}&#10;&#10;// Battery info entropy&#10;static void collect_battery_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    SYSTEM_POWER_STATUS status = { 0 };&#10;    if (GetSystemPowerStatus(&amp;status))&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;status, sizeof(status), 0);&#10;    }&#10;}&#10;&#10;// Network stats entropy&#10;static void collect_network_entropy(const BCRYPT_HASH_HANDLE hHash)&#10;{&#10;    MIB_TCPSTATS stats = { 0 };&#10;    if (GetTcpStatistics(&amp;stats) == NO_ERROR)&#10;    {&#10;        BCryptHashData(hHash, (PUCHAR)&amp;stats, sizeof(stats), 0);&#10;    }&#10;&#10;    // Adapter info&#10;    ULONG size = 0;&#10;    GetAdaptersInfo(NULL, &amp;size);&#10;    if (size &gt; 0)&#10;    {&#10;        // ReSharper disable once CppLocalVariableMayBeConst&#10;        PIP_ADAPTER_INFO pAdapterInfo = (PIP_ADAPTER_INFO)malloc(size);&#10;        if (pAdapterInfo)&#10;        {&#10;            if (GetAdaptersInfo(pAdapterInfo, &amp;size) == NO_ERROR)&#10;            {&#10;                BCryptHashData(hHash, (PUCHAR)pAdapterInfo, size, 0);&#10;            }&#10;            free(pAdapterInfo);&#10;        }&#10;    }&#10;}&#10;&#10;// Combine all entropy sources and hash to buffer with complexity rounds&#10;static int collect_entropy(unsigned char *buffer, const int size, const int complexity)&#10;{&#10;    BCRYPT_ALG_HANDLE hAlg = NULL;&#10;    BCRYPT_HASH_HANDLE hHash = NULL;&#10;    DWORD cbHash = 0, cbData = 0;&#10;    unsigned char hash[32]; // SHA256&#10;&#10;    NTSTATUS status = BCryptOpenAlgorithmProvider(&amp;hAlg, BCRYPT_SHA256_ALGORITHM, NULL, 0);&#10;    if (!BCRYPT_SUCCESS(status)) return 0;&#10;&#10;    status = BCryptGetProperty(hAlg, BCRYPT_HASH_LENGTH, (PUCHAR)&amp;cbHash, sizeof(DWORD), &amp;cbData, 0);&#10;    if (!BCRYPT_SUCCESS(status)) { BCryptCloseAlgorithmProvider(hAlg, 0); return 0; }&#10;    if (cbHash != 32) { BCryptCloseAlgorithmProvider(hAlg, 0); return 0; }&#10;&#10;    // Create hash object&#10;    status = BCryptCreateHash(hAlg, &amp;hHash, NULL, 0, NULL, 0, 0);&#10;    if (!BCRYPT_SUCCESS(status)) { BCryptCloseAlgorithmProvider(hAlg, 0); return 0; }&#10;&#10;    for (int round = 0; round &lt; complexity; round++)&#10;    {&#10;        // RDRAND entropy&#10;        if (rdrand_supported())&#10;        {&#10;            uint32_t rndVal = 0;&#10;            if (rdrand32_retry(&amp;rndVal))&#10;            {&#10;                BCryptHashData(hHash, (PUCHAR)&amp;rndVal, sizeof(rndVal), 0);&#10;            }&#10;        }&#10;&#10;        collect_cpu_entropy(hHash);&#10;        collect_process_memory_entropy(hHash);&#10;        collect_perf_counter_entropy(hHash);&#10;        collect_disk_entropy(hHash);&#10;        collect_audio_entropy(hHash);&#10;        collect_battery_entropy(hHash);&#10;        collect_network_entropy(hHash);&#10;&#10;        // Finalize this round hash&#10;        status = BCryptFinishHash(hHash, hash, cbHash, 0);&#10;        if (!BCRYPT_SUCCESS(status))&#10;        {&#10;            const NTSTATUS destroyStatus = BCryptDestroyHash(hHash);&#10;            const NTSTATUS closeStatus = BCryptCloseAlgorithmProvider(hAlg, 0);&#10;            (void)destroyStatus;&#10;            (void)closeStatus;&#10;            return 0;&#10;        }&#10;&#10;        // Feed hash again for next round if more than 1 round&#10;        if (round + 1 &lt; complexity)&#10;        {&#10;            status = BCryptDestroyHash(hHash);&#10;            if (!BCRYPT_SUCCESS(status))&#10;            {&#10;                const NTSTATUS closeStatus = BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                (void)closeStatus;&#10;                return 0;&#10;            }&#10;            status = BCryptCreateHash(hAlg, &amp;hHash, NULL, 0, NULL, 0, 0);&#10;            if (!BCRYPT_SUCCESS(status))&#10;            {&#10;                const NTSTATUS closeStatus = BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                (void)closeStatus;&#10;                return 0;&#10;            }&#10;            const NTSTATUS hashStatus = BCryptHashData(hHash, hash, cbHash, 0);&#10;            if (!BCRYPT_SUCCESS(hashStatus)) {&#10;                const NTSTATUS destroyHashStatus = BCryptDestroyHash(hHash);&#10;                const NTSTATUS closeAlgStatus = BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                (void)destroyHashStatus;&#10;                (void)closeAlgStatus;&#10;                return 0;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Generate unique random bytes for the entire buffer&#10;    // First, copy the initial hash block&#10;    DWORD bytesRemaining = (DWORD)size;&#10;    DWORD offset = 0;&#10;&#10;    // Copy first block (up to 32 bytes)&#10;    DWORD bytesToCopy = (bytesRemaining &lt; cbHash) ? bytesRemaining : cbHash;&#10;    memcpy(buffer, hash, bytesToCopy);&#10;    bytesRemaining -= bytesToCopy;&#10;    offset += bytesToCopy;&#10;&#10;    // For larger buffers, we need to generate additional unique blocks&#10;    if (bytesRemaining &gt; 0) {&#10;        // Create new hash for additional blocks&#10;        status = BCryptDestroyHash(hHash);&#10;        if (!BCRYPT_SUCCESS(status)) {&#10;            BCryptCloseAlgorithmProvider(hAlg, 0);&#10;            return 0;&#10;        }&#10;&#10;        // Use counter mode to generate unique blocks&#10;        uint32_t counter = 1; // Start from 1 since we already used block 0&#10;&#10;        while (bytesRemaining &gt; 0) {&#10;            status = BCryptCreateHash(hAlg, &amp;hHash, NULL, 0, NULL, 0, 0);&#10;            if (!BCRYPT_SUCCESS(status)) {&#10;                BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                return 0;&#10;            }&#10;&#10;            // Hash the previous output + counter for chaining&#10;            status = BCryptHashData(hHash, hash, cbHash, 0);&#10;            if (!BCRYPT_SUCCESS(status)) {&#10;                BCryptDestroyHash(hHash);&#10;                BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                return 0;&#10;            }&#10;&#10;            status = BCryptHashData(hHash, (PUCHAR)&amp;counter, sizeof(counter), 0);&#10;            if (!BCRYPT_SUCCESS(status)) {&#10;                BCryptDestroyHash(hHash);&#10;                BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                return 0;&#10;            }&#10;&#10;            // Generate next block&#10;            status = BCryptFinishHash(hHash, hash, cbHash, 0);&#10;            if (!BCRYPT_SUCCESS(status)) {&#10;                BCryptDestroyHash(hHash);&#10;                BCryptCloseAlgorithmProvider(hAlg, 0);&#10;                return 0;&#10;            }&#10;&#10;            // Copy to output buffer&#10;            bytesToCopy = (bytesRemaining &lt; cbHash) ? bytesRemaining : cbHash;&#10;            memcpy(buffer + offset, hash, bytesToCopy);&#10;            bytesRemaining -= bytesToCopy;&#10;            offset += bytesToCopy;&#10;            counter++;&#10;&#10;            BCryptDestroyHash(hHash);&#10;        }&#10;    }&#10;&#10;    BCryptCloseAlgorithmProvider(hAlg, 0);&#10;    return 1;&#10;}&#10;&#10;// PUBLIC API&#10;&#10;// Returns 1 if RDRAND is supported, else 0&#10;__declspec(dllexport) int test_rng_available(void)&#10;{&#10;    return rdrand_supported() ? 1 : 0;&#10;}&#10;&#10;// Returns 1 if threading primitives initialized or initializes now&#10;__declspec(dllexport) int test_threading_available(void)&#10;{&#10;    return InterlockedCompareExchange(&amp;g_threadingInitialized, 0, 0) != 0 ? 1 : 0;&#10;}&#10;&#10;// Basic RNG, complexity 1&#10;__declspec(dllexport) int maxrng(unsigned char *buffer, const int size)&#10;{&#10;    if (!buffer || size &lt;= 0) return 0;&#10;    return collect_entropy(buffer, size, 1);&#10;}&#10;&#10;// Ultra RNG with complexity param, limits from 1 to 10&#10;__declspec(dllexport) int maxrng_ultra(unsigned char *buffer, const int size, int complexity)&#10;{&#10;    if (!buffer || size &lt;= 0) return 0;&#10;    if (complexity &lt; 1) complexity = 1;&#10;    if (complexity &gt; 10) complexity = 10;&#10;    return collect_entropy(buffer, size, complexity);&#10;}&#10;&#10;// Initializes threading primitives if not already done&#10;__declspec(dllexport) void maxrng_init(void)&#10;{&#10;    if (InterlockedCompareExchange(&amp;g_threadingInitialized, 1, 0) == 0) {&#10;        InitializeCriticalSection(&amp;g_rngLock);&#10;    }&#10;}&#10;&#10;// Thread-safe version, uses critical section lock&#10;__declspec(dllexport) int maxrng_threadsafe(unsigned char *buffer, const int size)&#10;{&#10;    if (!buffer || size &lt;= 0) return 0;&#10;    EnterCriticalSection(&amp;g_rngLock);&#10;    const int result = collect_entropy(buffer, size, 1);&#10;    LeaveCriticalSection(&amp;g_rngLock);&#10;    return result;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.h" />
              <option name="updatedContent" value="#ifndef PYCTOOLS_HRNG_H&#10;#define PYCTOOLS_HRNG_H&#10;&#10;#ifdef __cplusplus&#10;extern &quot;C&quot; {&#10;#endif&#10;&#10;/**&#10; * Checks if the CPU supports the RDRAND instruction&#10; * &#10; * @return 1 if supported, 0 if not&#10; */&#10;int has_rdrand(void);&#10;&#10;/**&#10; * Fills a buffer with random bytes using hardware RNG (RDRAND if available)&#10; * &#10; * @param buffer Pointer to buffer to fill with random bytes&#10; * @param size Size of the buffer in bytes&#10; * @return 1 on success, 0 on failure&#10; */&#10;__declspec(dllexport)&#10;int read_hwrng(unsigned char* buffer, int size);&#10;&#10;/**&#10; * Maximum security RNG that uses multiple entropy sources:&#10; * - Hardware RNG (RDRAND)&#10; * - CPU information and timings&#10; * - Audio input (microphone)&#10; * - Battery/power status&#10; * - Memory and process statistics&#10; * - Network statistics&#10; * - Performance counters&#10; * &#10; * The entropy is mixed using cryptographic algorithms.&#10; * &#10; * @param buffer Pointer to buffer to fill with random bytes&#10; * @param size Size of the buffer in bytes&#10; * @return 1 on success, 0 on failure&#10; */&#10;__declspec(dllexport)&#10;int MaxRNG(unsigned char* buffer, int size);&#10;&#10;#ifdef __cplusplus&#10;}&#10;#endif&#10;&#10;#endif // PYCTOOLS_HRNG_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.md" />
              <option name="originalContent" value="# Hardware Random Number Generator (hRng)&#10;&#10;The `/dev/urandom/` of Windows.&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hRng.c&lt;/summary&gt;&#10;&#10;## hRng.c&#10;&#10;Implements a hardware random number generator using the RDRAND instruction (if supported by the CPU).&#10;&#10;### Key Function&#10;- `int read_hwrng(unsigned char* buffer, int size)`&#10;    - Fills `buffer` with `size` random bytes from the hardware RNG.&#10;    - Returns 1 on success, 0 if RDRAND is not supported or fails.&#10;    - Exported for use by Python via ctypes.&#10;&#10;### Notes&#10;- Checks for RDRAND support using CPUID.&#10;- Used by `pyCTools.hwrng`.&#10;&lt;/details&gt;&#10;&#10;## Overview&#10;&#10;The Hardware Random Number Generator (hRng) is a high-security random number generation library designed for Windows systems. It provides cryptographically secure random numbers by combining multiple entropy sources with hardware-based random number generation when available.&#10;&#10;## Key Features&#10;&#10;- Hardware-accelerated random number generation using Intel RDRAND instruction (when available)&#10;- Multiple entropy sources for enhanced security:&#10;  - CPU-specific entropy (RDTSC, CPUID)&#10;  - System performance metrics (timing, memory usage, disk I/O)&#10;  - Audio data from microphone&#10;  - Battery and power status information&#10;  - Network statistics&#10;- Secure entropy mixing using SHA-256&#10;- Thread-safe operation&#10;- Self-testing capabilities&#10;- Fallback mechanisms when primary sources fail&#10;- Multiple security levels with extended entropy gathering&#10;&#10;## API Reference&#10;&#10;### Basic Functions&#10;&#10;#### `int has_rdrand()`&#10;Detects if the CPU supports the RDRAND instruction.&#10;&#10;**Returns:**&#10;- `1` if RDRAND is supported&#10;- `0` if RDRAND is not supported&#10;&#10;#### `int read_hwrng(unsigned char* buffer, const int size)`&#10;Fills a buffer with random data using hardware RNG (RDRAND) with retry logic.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int MaxRNG(unsigned char* buffer, const int size)`&#10;The primary RNG function that combines multiple entropy sources.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int MaxRNG_ThreadSafe(unsigned char* buffer, const int size)`&#10;Thread-safe wrapper for MaxRNG.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;### Advanced Functions&#10;&#10;#### `int MaxRNG_Extended(unsigned char* buffer, const int size, const int intensive_level)`&#10;Enhanced random number generation with configurable intensity level.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;- `intensive_level`: Level of entropy gathering intensity (1-5):&#10;  - `1`: Standard MaxRNG operation&#10;  - `2`: Additional CPU jitter entropy&#10;  - `3+`: Maximum entropy gathering from all available sources&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int RNG_SelfTest(void)`&#10;Self-diagnostic function to verify RNG functionality.&#10;&#10;**Returns:**&#10;- `1` if all tests pass&#10;- `0` if any test fails&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*MaxRNG_Func)(unsigned char*, int);&#10;typedef int (*RNG_SelfTest_Func)(void);&#10;&#10;int main() {&#10;    // Load the DLL&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    // Get function pointers&#10;    MaxRNG_Func MaxRNG = (MaxRNG_Func)GetProcAddress(hRngDll, &quot;MaxRNG&quot;);&#10;    RNG_SelfTest_Func RNG_SelfTest = (RNG_SelfTest_Func)GetProcAddress(hRngDll, &quot;RNG_SelfTest&quot;);&#10;    &#10;    if (!MaxRNG || !RNG_SelfTest) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Run self-test&#10;    if (!RNG_SelfTest()) {&#10;        printf(&quot;RNG self-test failed\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate random bytes&#10;    unsigned char buffer[32] = {0};&#10;    if (MaxRNG(buffer, sizeof(buffer))) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;        }&#10;        printf(&quot;\n&quot;);&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Thread-Safe Usage&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_ThreadSafe_Func)(unsigned char*, int);&#10;&#10;DWORD WINAPI ThreadFunc(LPVOID lpParam) {&#10;    MaxRNG_ThreadSafe_Func MaxRNG_ThreadSafe = (MaxRNG_ThreadSafe_Func)lpParam;&#10;    &#10;    unsigned char buffer[16] = {0};&#10;    int result = MaxRNG_ThreadSafe(buffer, sizeof(buffer));&#10;    &#10;    // Print thread ID and result&#10;    printf(&quot;Thread %lu: %s\n&quot;, GetCurrentThreadId(), &#10;           result ? &quot;Success&quot; : &quot;Failed&quot;);&#10;           &#10;    return 0;&#10;}&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_ThreadSafe_Func MaxRNG_ThreadSafe = &#10;        (MaxRNG_ThreadSafe_Func)GetProcAddress(hRngDll, &quot;MaxRNG_ThreadSafe&quot;);&#10;    &#10;    if (!MaxRNG_ThreadSafe) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Create multiple threads to test thread safety&#10;    HANDLE threads[5];&#10;    for (int i = 0; i &lt; 5; i++) {&#10;        threads[i] = CreateThread(NULL, 0, ThreadFunc, &#10;                                 (LPVOID)MaxRNG_ThreadSafe, 0, NULL);&#10;    }&#10;    &#10;    // Wait for all threads to complete&#10;    WaitForMultipleObjects(5, threads, TRUE, INFINITE);&#10;    &#10;    for (int i = 0; i &lt; 5; i++) {&#10;        CloseHandle(threads[i]);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Using MaxRNG_Extended for Maximum Security&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_Extended_Func)(unsigned char*, int, int);&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_Extended_Func MaxRNG_Extended = &#10;        (MaxRNG_Extended_Func)GetProcAddress(hRngDll, &quot;MaxRNG_Extended&quot;);&#10;    &#10;    if (!MaxRNG_Extended) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate high-security random bytes (intensity level 5)&#10;    unsigned char buffer[64] = {0};&#10;    printf(&quot;Generating high-entropy random bytes...\n&quot;);&#10;    &#10;    if (MaxRNG_Extended(buffer, sizeof(buffer), 5)) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;            if ((i + 1) % 16 == 0) printf(&quot;\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Entropy Sources&#10;&#10;The library collects entropy from multiple sources:&#10;&#10;1. **Hardware RNG (RDRAND)**&#10;   - Uses Intel's RDRAND instruction when available&#10;   - Implements retry logic for reliability&#10;&#10;2. **CPU-specific Sources**&#10;   - RDTSC (Read Time-Stamp Counter)&#10;   - CPUID information&#10;&#10;3. **System Performance Metrics**&#10;   - Process memory information&#10;   - CPU timing information&#10;   - Disk I/O statistics&#10;   - High-precision performance counters&#10;&#10;4. **Audio Data**&#10;   - Samples microphone input&#10;   - Falls back to timing data if no microphone is available&#10;&#10;5. **Battery/Power Information**&#10;   - Battery state and charge levels&#10;   - Power status information&#10;&#10;6. **Network Statistics**&#10;   - TCP/IP statistics&#10;   - Network adapter information&#10;&#10;### Entropy Mixing&#10;&#10;All entropy sources are securely combined using SHA-256 through the Windows BCrypt API to ensure:&#10;&#10;- Uniform distribution of random bits&#10;- High entropy density&#10;- Protection against predictability attacks&#10;&#10;### Security Considerations&#10;&#10;- The library securely zeroes memory containing sensitive data using SecureZeroMemory&#10;- Multiple fallback mechanisms ensure reliability when primary entropy sources fail&#10;- Thread synchronization protects against race conditions in multi-threaded environments&#10;- Self-test functionality verifies proper operation before use&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - winmm.lib&#10;  - bcrypt.lib&#10;  - iphlpapi.lib&#10;  - psapi.lib&#10;  - powrprof.lib&#10;&#10;### Linking with Your Application&#10;&#10;When compiling your application, make sure to include the appropriate header file and link against the hRng.dll library.&#10;&#10;#### Static Linking&#10;&#10;```c&#10;#pragma comment(lib, &quot;hRng.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;if (hRngDll) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```&#10;" />
              <option name="updatedContent" value="# Hardware Random Number Generator (hRng)&#10;&#10;The `/dev/urandom/` of Windows.&#10;&#10;&lt;details&gt;&#10;&lt;summary&gt;Outdated documentation for v1.0.0 - hRng.c&lt;/summary&gt;&#10;&#10;## hRng.c&#10;&#10;Implements a hardware random number generator using the RDRAND instruction (if supported by the CPU).&#10;&#10;### Key Function&#10;- `int read_hwrng(unsigned char* buffer, int size)`&#10;    - Fills `buffer` with `size` random bytes from the hardware RNG.&#10;    - Returns 1 on success, 0 if RDRAND is not supported or fails.&#10;    - Exported for use by Python via ctypes.&#10;&#10;### Notes&#10;- Checks for RDRAND support using CPUID.&#10;- Used by `pyCTools.hwrng`.&#10;&lt;/details&gt;&#10;&#10;## Overview&#10;&#10;The Hardware Random Number Generator (hRng) is a high-security random number generation library designed for Windows systems. It provides cryptographically secure random numbers by combining multiple entropy sources with hardware-based random number generation when available.&#10;&#10;## Key Features&#10;&#10;- Hardware-accelerated random number generation using Intel RDRAND instruction (when available)&#10;- Multiple entropy sources for enhanced security:&#10;  - CPU-specific entropy (RDTSC, CPUID)&#10;  - System performance metrics (timing, memory usage)&#10;  - Process memory information&#10;  - Disk space statistics&#10;  - Network adapter and TCP statistics&#10;  - Battery and power status information&#10;- Secure entropy mixing using SHA-256 via Windows BCrypt API&#10;- Thread-safe operation with proper synchronization&#10;- Configurable complexity levels for enhanced security&#10;- Fallback mechanisms when hardware RNG is unavailable&#10;&#10;## API Reference&#10;&#10;### Basic Functions&#10;&#10;#### `int test_rng_available(void)`&#10;Detects if the CPU supports the RDRAND instruction.&#10;&#10;**Returns:**&#10;- `1` if RDRAND is supported&#10;- `0` if RDRAND is not supported&#10;&#10;#### `int test_threading_available(void)`&#10;Checks if threading primitives are initialized.&#10;&#10;**Returns:**&#10;- `1` if threading primitives are initialized&#10;- `0` otherwise&#10;&#10;#### `int maxrng(unsigned char* buffer, const int size)`&#10;The primary RNG function that combines multiple entropy sources with basic complexity.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `void maxrng_init(void)`&#10;Initializes threading primitives for thread-safe operation.&#10;&#10;**Returns:**&#10;- None&#10;&#10;#### `int maxrng_threadsafe(unsigned char* buffer, const int size)`&#10;Thread-safe wrapper for the RNG function.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;### Advanced Functions&#10;&#10;#### `int maxrng_ultra(unsigned char* buffer, const int size, int complexity)`&#10;Enhanced random number generation with configurable complexity level.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;- `complexity`: Level of entropy gathering intensity (1-10):&#10;  - Higher values increase the number of entropy gathering rounds&#10;  - Values are automatically clamped between 1 and 10&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*MaxRNG_Func)(unsigned char*, int);&#10;typedef int (*RngAvailable_Func)(void);&#10;&#10;int main() {&#10;    // Load the DLL&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    // Get function pointers&#10;    MaxRNG_Func rng = (MaxRNG_Func)GetProcAddress(hRngDll, &quot;maxrng&quot;);&#10;    RngAvailable_Func rngAvailable = (RngAvailable_Func)GetProcAddress(hRngDll, &quot;test_rng_available&quot;);&#10;    &#10;    if (!rng || !rngAvailable) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Check if hardware RNG is available&#10;    printf(&quot;Hardware RNG available: %s\n&quot;, rngAvailable() ? &quot;Yes&quot; : &quot;No&quot;);&#10;    &#10;    // Generate random bytes&#10;    unsigned char buffer[32] = {0};&#10;    if (rng(buffer, sizeof(buffer))) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;        }&#10;        printf(&quot;\n&quot;);&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Thread-Safe Usage&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef void (*Init_Func)(void);&#10;typedef int (*ThreadSafe_RNG_Func)(unsigned char*, int);&#10;&#10;DWORD WINAPI ThreadFunc(LPVOID lpParam) {&#10;    ThreadSafe_RNG_Func rng = (ThreadSafe_RNG_Func)lpParam;&#10;    &#10;    unsigned char buffer[16] = {0};&#10;    int result = rng(buffer, sizeof(buffer));&#10;    &#10;    // Print thread ID and result&#10;    printf(&quot;Thread %lu: %s\n&quot;, GetCurrentThreadId(), &#10;           result ? &quot;Success&quot; : &quot;Failed&quot;);&#10;           &#10;    return 0;&#10;}&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    Init_Func init = (Init_Func)GetProcAddress(hRngDll, &quot;maxrng_init&quot;);&#10;    ThreadSafe_RNG_Func threadSafeRng = &#10;        (ThreadSafe_RNG_Func)GetProcAddress(hRngDll, &quot;maxrng_threadsafe&quot;);&#10;    &#10;    if (!init || !threadSafeRng) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Initialize threading primitives&#10;    init();&#10;    &#10;    // Create multiple threads to test thread safety&#10;    HANDLE threads[5];&#10;    for (int i = 0; i &lt; 5; i++) {&#10;        threads[i] = CreateThread(NULL, 0, ThreadFunc, &#10;                                 (LPVOID)threadSafeRng, 0, NULL);&#10;    }&#10;    &#10;    // Wait for all threads to complete&#10;    WaitForMultipleObjects(5, threads, TRUE, INFINITE);&#10;    &#10;    for (int i = 0; i &lt; 5; i++) {&#10;        CloseHandle(threads[i]);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Using Ultra Mode for Maximum Security&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_Ultra_Func)(unsigned char*, int, int);&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_Ultra_Func ultraRng = &#10;        (MaxRNG_Ultra_Func)GetProcAddress(hRngDll, &quot;maxrng_ultra&quot;);&#10;    &#10;    if (!ultraRng) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate high-security random bytes (complexity level 10)&#10;    unsigned char buffer[64] = {0};&#10;    printf(&quot;Generating high-entropy random bytes...\n&quot;);&#10;    &#10;    if (ultraRng(buffer, sizeof(buffer), 10)) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;            if ((i + 1) % 16 == 0) printf(&quot;\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Entropy Sources&#10;&#10;The library collects entropy from multiple sources:&#10;&#10;1. **Hardware RNG (RDRAND)**&#10;   - Uses Intel's RDRAND instruction when available&#10;   - Implements retry logic for reliability (up to 10 retries)&#10;&#10;2. **CPU-specific Sources**&#10;   - RDTSC (Read Time-Stamp Counter)&#10;   - CPUID information&#10;&#10;3. **System Performance Metrics**&#10;   - Process memory information via GetProcessMemoryInfo&#10;   - High-precision performance counters via QueryPerformanceCounter&#10;&#10;4. **Storage Information**&#10;   - Disk free space statistics via GetDiskFreeSpaceEx&#10;&#10;5. **Audio Timing**&#10;   - Timing-based entropy collection with sleep intervals&#10;   - Used as a fallback entropy source&#10;&#10;6. **Battery/Power Information**&#10;   - System power status via GetSystemPowerStatus&#10;&#10;7. **Network Statistics**&#10;   - TCP statistics via GetTcpStatistics&#10;   - Network adapter information via GetAdaptersInfo&#10;&#10;### Entropy Mixing&#10;&#10;All entropy sources are securely combined using SHA-256 through the Windows BCrypt API:&#10;&#10;- Multiple rounds of hashing based on the complexity parameter&#10;- Secure handling of hash state between rounds&#10;- Proper cleanup of cryptographic resources&#10;&#10;### Thread Safety&#10;&#10;- Uses Windows critical sections for thread synchronization&#10;- Initialization of threading primitives via maxrng_init()&#10;- Thread-safe API via maxrng_threadsafe()&#10;&#10;### Security Considerations&#10;&#10;- Multiple fallback mechanisms ensure reliability when hardware RNG is unavailable&#10;- Complexity parameter allows for trading off performance vs. security&#10;- Clean error handling with proper resource cleanup&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - bcrypt.lib&#10;  - winmm.lib&#10;  - iphlpapi.lib&#10;  - psapi.lib&#10;&#10;### Linking with Your Application&#10;&#10;When compiling your application, make sure to link against the required libraries:&#10;&#10;```c&#10;#pragma comment(lib, &quot;bcrypt.lib&quot;)&#10;#pragma comment(lib, &quot;winmm.lib&quot;)&#10;#pragma comment(lib, &quot;iphlpapi.lib&quot;)&#10;#pragma comment(lib, &quot;psapi.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;if (hRngDll) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/processInspect.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/processInspect.md" />
              <option name="updatedContent" value="# Process Inspection Module (processInspect)&#10;&#10;## Overview&#10;&#10;The Process Inspection Module provides powerful, low-level access to Windows process metrics and performance data. This library allows applications to monitor process resource usage with minimal overhead, supporting both instantaneous measurements and differential metrics over specified time periods.&#10;&#10;## Key Features&#10;&#10;- Low-overhead process monitoring&#10;- Memory usage metrics (working set, private bytes, pagefile usage)&#10;- Process resource tracking (handles, threads)&#10;- CPU utilization measurement&#10;- I/O operations monitoring (read/write)&#10;- Support for both snapshot and time-interval measurements&#10;- JSON-formatted output for easy integration&#10;- Customizable metrics selection&#10;&#10;## API Reference&#10;&#10;### Constants&#10;&#10;#### Metrics Flags&#10;&#10;The following constants are used to specify which metrics to collect:&#10;&#10;```c&#10;#define METRIC_WORKING_SET   0x01  // Process working set size&#10;#define METRIC_PRIVATE_BYTES 0x02  // Private memory usage&#10;#define METRIC_PAGEFILE      0x04  // Pagefile usage&#10;#define METRIC_HANDLES       0x08  // Handle count&#10;#define METRIC_THREADS       0x10  // Thread count&#10;#define METRIC_CPU_USAGE     0x20  // CPU usage percentage&#10;#define METRIC_IO            0x40  // I/O read/write operations&#10;#define METRIC_NET           0x80  // Network usage (when implemented)&#10;```&#10;&#10;### Functions&#10;&#10;#### `int get_metrics_json(DWORD pid, DWORD metrics, char *json_buf, size_t json_buflen)`&#10;&#10;Takes an instantaneous snapshot of the specified process metrics.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID to monitor&#10;- `metrics`: Bitwise combination of METRIC_* flags indicating which metrics to collect&#10;- `json_buf`: Output buffer where the JSON-formatted metrics will be written&#10;- `json_buflen`: Size of the output buffer&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure (invalid process, insufficient permissions, buffer too small)&#10;&#10;**JSON Output Format:**&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,&#10;  &quot;working_set_kb&quot;: 45678,&#10;  &quot;private_kb&quot;: 34567,&#10;  &quot;pagefile_kb&quot;: 23456,&#10;  &quot;handles&quot;: 345,&#10;  &quot;threads&quot;: 12,&#10;  &quot;cpu&quot;: 3.45,&#10;  &quot;io_read_kb&quot;: 1234,&#10;  &quot;io_write_kb&quot;: 5678&#10;}&#10;```&#10;&#10;#### `int start_metrics_collection(DWORD pid, DWORD metrics)`&#10;&#10;Begins collecting metrics for a process over a time period. Must be paired with a later call to `end_metrics_collection()`.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID to monitor&#10;- `metrics`: Bitwise combination of METRIC_* flags indicating which metrics to collect&#10;&#10;**Returns:**&#10;- `1` if collection successfully started&#10;- `0` on failure (invalid process, insufficient permissions)&#10;&#10;#### `int end_metrics_collection(DWORD pid, DWORD metrics, char *json_buf, size_t json_buflen)`&#10;&#10;Ends metrics collection and calculates differentials for the time period since `start_metrics_collection()` was called.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID (must match the one used in `start_metrics_collection()`)&#10;- `metrics`: Bitwise combination of METRIC_* flags (must match the ones used in `start_metrics_collection()`)&#10;- `json_buf`: Output buffer where the JSON-formatted metrics will be written&#10;- `json_buflen`: Size of the output buffer&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure (invalid process, metrics mismatch, insufficient permissions, buffer too small)&#10;&#10;**Notes:**&#10;- CPU and I/O metrics are reported as deltas between start and end collection&#10;- Memory metrics are instantaneous values at the time of call&#10;&#10;## Usage Examples&#10;&#10;### Taking a Snapshot of Process Metrics&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*GetMetricsJson_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;int main() {&#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    GetMetricsJson_Func GetMetricsJson = &#10;        (GetMetricsJson_Func)GetProcAddress(hModule, &quot;get_metrics_json&quot;);&#10;    &#10;    if (!GetMetricsJson) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = 1234; // Replace with actual PID&#10;    const DWORD metrics = METRIC_WORKING_SET | METRIC_PRIVATE_BYTES | &#10;                         METRIC_HANDLES | METRIC_CPU_USAGE;&#10;    &#10;    char json_buffer[1024] = {0};&#10;    &#10;    if (GetMetricsJson(pid, metrics, json_buffer, sizeof(json_buffer))) {&#10;        printf(&quot;Process metrics: %s\n&quot;, json_buffer);&#10;    } else {&#10;        printf(&quot;Failed to get process metrics\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Measuring Process Metrics Over Time&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*StartMetricsCollection_Func)(DWORD, DWORD);&#10;typedef int (*EndMetricsCollection_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;int main() {&#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    StartMetricsCollection_Func StartMetricsCollection = &#10;        (StartMetricsCollection_Func)GetProcAddress(hModule, &quot;start_metrics_collection&quot;);&#10;    &#10;    EndMetricsCollection_Func EndMetricsCollection = &#10;        (EndMetricsCollection_Func)GetProcAddress(hModule, &quot;end_metrics_collection&quot;);&#10;    &#10;    if (!StartMetricsCollection || !EndMetricsCollection) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = 1234; // Replace with actual PID&#10;    const DWORD metrics = METRIC_CPU_USAGE | METRIC_IO;&#10;    &#10;    if (StartMetricsCollection(pid, metrics)) {&#10;        printf(&quot;Started metrics collection. Monitoring for 5 seconds...\n&quot;);&#10;        &#10;        // Wait for a period to collect metrics&#10;        Sleep(5000);&#10;        &#10;        char json_buffer[1024] = {0};&#10;        if (EndMetricsCollection(pid, metrics, json_buffer, sizeof(json_buffer))) {&#10;            printf(&quot;Process metrics over 5 seconds: %s\n&quot;, json_buffer);&#10;        } else {&#10;            printf(&quot;Failed to end metrics collection\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to start metrics collection\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Complete Example with All Metrics&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*StartMetricsCollection_Func)(DWORD, DWORD);&#10;typedef int (*EndMetricsCollection_Func)(DWORD, DWORD, char*, size_t);&#10;typedef int (*GetMetricsJson_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;// Metrics flags&#10;#define METRIC_WORKING_SET   0x01&#10;#define METRIC_PRIVATE_BYTES 0x02&#10;#define METRIC_PAGEFILE      0x04&#10;#define METRIC_HANDLES       0x08&#10;#define METRIC_THREADS       0x10&#10;#define METRIC_CPU_USAGE     0x20&#10;#define METRIC_IO            0x40&#10;#define METRIC_NET           0x80&#10;&#10;int main(int argc, char* argv[]) {&#10;    if (argc &lt; 2) {&#10;        printf(&quot;Usage: %s &lt;PID&gt;\n&quot;, argv[0]);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = (DWORD)atoi(argv[1]);&#10;    &#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    StartMetricsCollection_Func StartMetricsCollection = &#10;        (StartMetricsCollection_Func)GetProcAddress(hModule, &quot;start_metrics_collection&quot;);&#10;    &#10;    EndMetricsCollection_Func EndMetricsCollection = &#10;        (EndMetricsCollection_Func)GetProcAddress(hModule, &quot;end_metrics_collection&quot;);&#10;    &#10;    GetMetricsJson_Func GetMetricsJson = &#10;        (GetMetricsJson_Func)GetProcAddress(hModule, &quot;get_metrics_json&quot;);&#10;    &#10;    if (!StartMetricsCollection || !EndMetricsCollection || !GetMetricsJson) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    // All available metrics&#10;    const DWORD all_metrics = METRIC_WORKING_SET | METRIC_PRIVATE_BYTES | &#10;                             METRIC_PAGEFILE | METRIC_HANDLES | METRIC_THREADS | &#10;                             METRIC_CPU_USAGE | METRIC_IO;&#10;    &#10;    // First, take an instant snapshot&#10;    char json_buffer[1024] = {0};&#10;    if (GetMetricsJson(pid, all_metrics, json_buffer, sizeof(json_buffer))) {&#10;        printf(&quot;Instant metrics snapshot:\n%s\n\n&quot;, json_buffer);&#10;    } else {&#10;        printf(&quot;Failed to get instant metrics\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    // Then measure over time&#10;    if (StartMetricsCollection(pid, all_metrics)) {&#10;        printf(&quot;Collecting metrics for 10 seconds...\n&quot;);&#10;        Sleep(10000);&#10;        &#10;        if (EndMetricsCollection(pid, all_metrics, json_buffer, sizeof(json_buffer))) {&#10;            printf(&quot;Metrics over 10 seconds:\n%s\n&quot;, json_buffer);&#10;        } else {&#10;            printf(&quot;Failed to end metrics collection\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to start metrics collection\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Process Metrics Explained&#10;&#10;#### Memory Metrics&#10;&#10;- **Working Set (METRIC_WORKING_SET)**: &#10;  The set of memory pages currently visible to the process in physical RAM. This includes shared and private pages.&#10;&#10;- **Private Bytes (METRIC_PRIVATE_BYTES)**:&#10;  Memory that cannot be shared with other processes. This represents the actual memory cost of the process.&#10;&#10;- **Pagefile Usage (METRIC_PAGEFILE)**:&#10;  The amount of the system page file that is being used by the process. This includes all memory that the process has touched, including pages that are in RAM.&#10;&#10;#### Resource Metrics&#10;&#10;- **Handles (METRIC_HANDLES)**:&#10;  The number of object handles in the process's handle table. This includes files, registry keys, events, etc.&#10;&#10;- **Threads (METRIC_THREADS)**:&#10;  The number of threads currently executing in the process.&#10;&#10;#### Performance Metrics&#10;&#10;- **CPU Usage (METRIC_CPU_USAGE)**:&#10;  Percentage of available CPU time that the process has used. When collected over time, this represents the average usage during that period.&#10;&#10;- **I/O Operations (METRIC_IO)**:&#10;  Total bytes read from and written to the disk by the process. When collected over time, this represents the bytes transferred during that period.&#10;&#10;### Implementation Details&#10;&#10;- The library uses Windows Performance Data Helper (PDH) and Process Status API (PSAPI) to collect metrics&#10;- Thread synchronization is implemented for metric collection over time&#10;- The implementation uses Windows-specific APIs and is optimized for minimal overhead&#10;- CPU usage calculation takes into account all cores/processors in the system&#10;- All memory metrics are reported in kilobytes (KB)&#10;&#10;### Known Limitations&#10;&#10;- Requires administrator privileges to monitor some processes&#10;- CPU usage metrics may not be 100% accurate for very short-lived processes&#10;- Network metrics are reserved for future implementation (METRIC_NET flag)&#10;- Only supports Windows operating systems&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - psapi.lib&#10;  - iphlpapi.lib&#10;&#10;### Linking with Your Application&#10;&#10;#### Static Linking&#10;&#10;```c&#10;#pragma comment(lib, &quot;processInspect.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;if (hModule) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```&#10;&#10;### Python Integration&#10;&#10;The library can be easily used from Python via ctypes:&#10;&#10;```python&#10;import ctypes&#10;from ctypes import c_int, c_ulong, c_char_p, c_size_t&#10;&#10;# Load the DLL&#10;process_inspect = ctypes.CDLL(&quot;processInspect.dll&quot;)&#10;&#10;# Define metrics constants&#10;METRIC_WORKING_SET = 0x01&#10;METRIC_PRIVATE_BYTES = 0x02&#10;METRIC_PAGEFILE = 0x04&#10;METRIC_HANDLES = 0x08&#10;METRIC_THREADS = 0x10&#10;METRIC_CPU_USAGE = 0x20&#10;METRIC_IO = 0x40&#10;METRIC_ALL = 0x7F&#10;&#10;# Define function prototypes&#10;get_metrics_json = process_inspect.get_metrics_json&#10;get_metrics_json.argtypes = [c_ulong, c_ulong, c_char_p, c_size_t]&#10;get_metrics_json.restype = c_int&#10;&#10;# Usage example&#10;def get_process_metrics(pid, metrics=METRIC_ALL):&#10;    buffer = ctypes.create_string_buffer(1024)&#10;    if get_metrics_json(pid, metrics, buffer, len(buffer)):&#10;        return buffer.value.decode('utf-8')&#10;    return None&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import json&#10;    &#10;    pid = 1234  # Replace with actual PID&#10;    metrics_json = get_process_metrics(pid)&#10;    if metrics_json:&#10;        metrics = json.loads(metrics_json)&#10;        print(f&quot;Process {pid} is using {metrics.get('working_set_kb', 0):,} KB of memory&quot;)&#10;        print(f&quot;CPU Usage: {metrics.get('cpu', 0):.2f}%&quot;)&#10;```&#10;&#10;## License and Attribution&#10;&#10;This Process Inspection Module is provided for monitoring and analyzing process performance in Windows environments.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_hrng.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_hrng.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;&#10;DLL_PATH = os.path.join(os.path.dirname(__file__), &quot;src&quot;, &quot;hRng.dll&quot;)&#10;&#10;hrng = ctypes.WinDLL(DLL_PATH)&#10;&#10;# Function prototypes&#10;hrng.MaxRNG.argtypes = [ctypes.c_void_p, ctypes.c_int]&#10;hrng.MaxRNG.restype = ctypes.c_int&#10;&#10;hrng.RNG_SelfTest.restype = ctypes.c_int&#10;&#10;def test_maxrng():&#10;    buf = (ctypes.c_ubyte * 32)()&#10;    result = hrng.MaxRNG(buf, 32)&#10;    print(&quot;MaxRNG result:&quot;, result)&#10;    print(&quot;Random bytes:&quot;, bytes(buf).hex())&#10;&#10;def test_selftest():&#10;    result = hrng.RNG_SelfTest()&#10;    print(&quot;RNG_SelfTest result:&quot;, result)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_selftest()&#10;    test_maxrng()&#10;&#10;" />
              <option name="updatedContent" value="oimport ctypes&#10;import os&#10;&#10;DLL_PATH = os.path.join(os.path.dirname(__file__), &quot;src&quot;, &quot;hRng.dll&quot;)&#10;&#10;hrng = ctypes.WinDLL(DLL_PATH)&#10;&#10;# Function prototypes&#10;hrng.MaxRNG.argtypes = [ctypes.c_void_p, ctypes.c_int]&#10;hrng.MaxRNG.restype = ctypes.c_int&#10;&#10;hrng.RNG_SelfTest.restype = ctypes.c_int&#10;&#10;def test_maxrng():&#10;    buf = (ctypes.c_ubyte * 32)()&#10;    result = hrng.MaxRNG(buf, 32)&#10;    print(&quot;MaxRNG result:&quot;, result)&#10;    print(&quot;Random bytes:&quot;, bytes(buf).hex())&#10;&#10;def test_selftest():&#10;    result = hrng.RNG_SelfTest()&#10;    print(&quot;RNG_SelfTest result:&quot;, result)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_selftest()&#10;    test_maxrng()&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>