<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/example/hwrng_example.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/hwrng_example.py" />
              <option name="originalContent" value="# Optional CLI usage&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;&#10;if __name__ == '__main__':&#10;    try:&#10;        rb = get_hardware_random_bytes(256)&#10;        print(&quot;Random bytes:&quot;, rb.hex())&#10;    except Exception as e:&#10;        print(&quot;Error:&quot;, e)&#10;" />
              <option name="updatedContent" value="from pyCTools.hwrng import (&#10;    get_hardware_random_bytes,&#10;    get_hardware_random_bytes_threadsafe,&#10;    get_hardware_random_bytes_extended,&#10;    hardware_rng_selftest,&#10;)&#10;&#10;if __name__ == '__main__':&#10;    print(&quot;RNG self-test:&quot;, &quot;PASS&quot; if hardware_rng_selftest() else &quot;FAIL&quot;)&#10;&#10;    try:&#10;        rb = get_hardware_random_bytes(32)&#10;        print(&quot;MaxRNG (32 bytes):&quot;, rb.hex())&#10;        rb2 = get_hardware_random_bytes_threadsafe(32)&#10;        print(&quot;MaxRNG_ThreadSafe (32 bytes):&quot;, rb2.hex())&#10;        rb3 = get_hardware_random_bytes_extended(32, intensive_level=3)&#10;        print(&quot;MaxRNG_Extended (32 bytes, level 3):&quot;, rb3.hex())&#10;    except Exception as e:&#10;        print(&quot;Error:&quot;, e)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/pyCTools/hwrng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/pyCTools/hwrng.md" />
              <option name="updatedContent" value="# Python Hardware Random Number Generator (hwrng)&#10;&#10;## Overview&#10;&#10;The `pyCTools.hwrng` module provides Python bindings to the high-security hardware random number generation capabilities of the `hRng` library. This module allows Python applications to access cryptographically secure random numbers generated from multiple entropy sources including hardware RNG instructions when available.&#10;&#10;## Features&#10;&#10;- Cryptographically secure random number generation&#10;- Thread-safe operation&#10;- Support for high-intensity entropy gathering&#10;- Self-test capabilities&#10;- Automatic architecture detection (x86/x64)&#10;- Simple Python API with proper error handling&#10;&#10;## Installation&#10;&#10;The `pyCTools` package includes precompiled binaries for both x86 and x64 Windows platforms. No additional installation steps are needed beyond installing the package:&#10;&#10;```bash&#10;pip install pyCTools&#10;```&#10;&#10;## API Reference&#10;&#10;### Functions&#10;&#10;#### `get_hardware_random_bytes(size: int) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the standard MaxRNG algorithm.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;&#10;# Generate 32 random bytes&#10;random_data = get_hardware_random_bytes(32)&#10;print(&quot;Random bytes:&quot;, random_data.hex())&#10;```&#10;&#10;#### `get_hardware_random_bytes_threadsafe(size: int) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the thread-safe version of MaxRNG. This function is safe to call from multiple threads simultaneously.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;import threading&#10;from pyCTools.hwrng import get_hardware_random_bytes_threadsafe&#10;&#10;def worker():&#10;    # Generate 16 random bytes in each thread&#10;    data = get_hardware_random_bytes_threadsafe(16)&#10;    print(f&quot;Thread {threading.current_thread().name}: {data.hex()}&quot;)&#10;&#10;# Create and start 5 threads&#10;threads = []&#10;for i in range(5):&#10;    t = threading.Thread(target=worker, name=f&quot;RNG-{i}&quot;)&#10;    threads.append(t)&#10;    t.start()&#10;&#10;# Wait for all threads to complete&#10;for t in threads:&#10;    t.join()&#10;```&#10;&#10;#### `get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes`&#10;&#10;Generates cryptographically secure random bytes using the extended MaxRNG algorithm with configurable entropy gathering intensity.&#10;&#10;**Parameters:**&#10;- `size` (int): Number of random bytes to generate (must be positive)&#10;- `intensive_level` (int, optional): Entropy gathering intensity level (must be &gt;= 1). Default is 2.&#10;  - Level 1: Standard MaxRNG operation&#10;  - Level 2: Additional CPU jitter entropy&#10;  - Level 3+: Maximum entropy gathering from all available sources&#10;&#10;**Returns:**&#10;- `bytes`: Generated random bytes&#10;&#10;**Raises:**&#10;- `ValueError`: If size is not positive or intensive_level is less than 1&#10;- `HardwareRNGError`: If the RNG operation fails&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes_extended&#10;&#10;# Generate 64 random bytes with maximum entropy gathering&#10;random_data = get_hardware_random_bytes_extended(64, intensive_level=5)&#10;print(&quot;High-security random bytes:&quot;, random_data.hex())&#10;```&#10;&#10;#### `hardware_rng_selftest() -&gt; bool`&#10;&#10;Runs the built-in self-test for the RNG to verify proper operation.&#10;&#10;**Returns:**&#10;- `bool`: True if the self-test passes, False otherwise&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import hardware_rng_selftest&#10;&#10;if hardware_rng_selftest():&#10;    print(&quot;RNG self-test passed&quot;)&#10;else:&#10;    print(&quot;RNG self-test failed&quot;)&#10;```&#10;&#10;### Exceptions&#10;&#10;#### `HardwareRNGError`&#10;&#10;Raised when a hardware RNG operation fails or when the DLL cannot be loaded.&#10;&#10;**Example:**&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes, HardwareRNGError&#10;&#10;try:&#10;    random_data = get_hardware_random_bytes(32)&#10;    print(&quot;Random bytes:&quot;, random_data.hex())&#10;except HardwareRNGError as e:&#10;    print(f&quot;RNG operation failed: {e}&quot;)&#10;```&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;&#10;# Generate a random 256-bit key (32 bytes)&#10;key = get_hardware_random_bytes(32)&#10;print(f&quot;Random 256-bit key: {key.hex()}&quot;)&#10;```&#10;&#10;### Using as a Source for cryptography Library&#10;&#10;```python&#10;from pyCTools.hwrng import get_hardware_random_bytes&#10;from cryptography.hazmat.primitives.asymmetric import rsa&#10;import os&#10;&#10;class HardwareRandomGenerator:&#10;    def __init__(self):&#10;        pass&#10;        &#10;    def read(self, size):&#10;        return get_hardware_random_bytes(size)&#10;&#10;# Use our hardware RNG as a source for RSA key generation&#10;os.environ[&quot;PYTHONHASHSEED&quot;] = &quot;0&quot;  # Fix seed for reproducible example&#10;rng = HardwareRandomGenerator()&#10;private_key = rsa.generate_private_key(&#10;    public_exponent=65537,&#10;    key_size=2048,&#10;    backend=default_backend(),&#10;    random_number_generator=rng&#10;)&#10;&#10;print(&quot;Generated RSA key with hardware entropy&quot;)&#10;```&#10;&#10;### High-Security Random Token Generation&#10;&#10;```python&#10;import base64&#10;from pyCTools.hwrng import get_hardware_random_bytes_extended&#10;&#10;def generate_secure_token(length=32):&#10;    &quot;&quot;&quot;Generate a URL-safe, base64 encoded token with maximum entropy.&quot;&quot;&quot;&#10;    random_bytes = get_hardware_random_bytes_extended(length, intensive_level=5)&#10;    return base64.urlsafe_b64encode(random_bytes).decode('utf-8')&#10;&#10;# Generate a secure session token&#10;session_token = generate_secure_token(48)&#10;print(f&quot;Secure session token: {session_token}&quot;)&#10;```&#10;&#10;### Thread Safety Demonstration&#10;&#10;```python&#10;import threading&#10;import time&#10;from pyCTools.hwrng import get_hardware_random_bytes_threadsafe&#10;&#10;def intensive_rng_task(thread_id):&#10;    &quot;&quot;&quot;Generate multiple random values in a thread.&quot;&quot;&quot;&#10;    for i in range(5):&#10;        data = get_hardware_random_bytes_threadsafe(16)&#10;        hex_data = data.hex()&#10;        print(f&quot;Thread {thread_id}, iteration {i}: {hex_data}&quot;)&#10;        time.sleep(0.01)  # Small delay to better visualize concurrent execution&#10;&#10;# Create and start 10 threads&#10;threads = []&#10;for i in range(10):&#10;    t = threading.Thread(target=intensive_rng_task, args=(i,))&#10;    threads.append(t)&#10;    t.start()&#10;&#10;# Wait for all threads to complete&#10;for t in threads:&#10;    t.join()&#10;```&#10;&#10;## Technical Details&#10;&#10;### DLL Loading&#10;&#10;The module automatically locates and loads the appropriate version (x86 or x64) of the `hRng` DLL from the distribution directory. The DLL is loaded only once when the module is first imported.&#10;&#10;### Error Handling&#10;&#10;All RNG operations include proper error checking. If an operation fails, a `HardwareRNGError` exception is raised with an informative error message.&#10;&#10;### Thread Safety&#10;&#10;The `get_hardware_random_bytes_threadsafe` function uses the thread-safe version of the RNG which employs proper synchronization mechanisms to ensure safe concurrent access from multiple threads.&#10;&#10;### Performance Considerations&#10;&#10;- The standard `get_hardware_random_bytes` function provides the best balance of security and performance for most applications.&#10;- The `get_hardware_random_bytes_extended` function with higher intensity levels will be slower but provides additional entropy gathering.&#10;- For applications requiring many random numbers in performance-sensitive contexts, consider generating larger batches less frequently.&#10;&#10;## Security Recommendations&#10;&#10;1. Use `get_hardware_random_bytes_extended` with a high intensity level (4 or 5) for generating cryptographic keys and other highly sensitive values.&#10;2. Use `get_hardware_random_bytes_threadsafe` in multi-threaded applications to ensure thread safety.&#10;3. Consider running `hardware_rng_selftest()` at application startup to verify RNG functionality.&#10;4. For cryptographic applications, combine this RNG with proper key derivation functions (KDFs) such as PBKDF2 or Argon2.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/pyCTools/hwrng.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/pyCTools/hwrng.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;hwrng.py&#10;&#10;Hardware Random Number Generator interface for Python using ctypes and the new hRng.dll.&#10;&quot;&quot;&quot;&#10;&#10;import ctypes&#10;import os&#10;import platform&#10;&#10;__all__ = [&#10;    &quot;get_hardware_random_bytes&quot;,&#10;    &quot;get_hardware_random_bytes_extended&quot;,&#10;    &quot;get_thread_safe_random_bytes&quot;,&#10;    &quot;hardware_rng_selftest&quot;,&#10;    &quot;is_thread_safe_available&quot;,&#10;    &quot;HardwareRNGError&quot;&#10;]&#10;&#10;&#10;class HardwareRNGError(RuntimeError):&#10;    &quot;&quot;&quot;Raised when hardware RNG fails or DLL cannot be loaded.&quot;&quot;&quot;&#10;    def __init__(self, message=&quot;Hardware RNG error occurred&quot;):&#10;        super().__init__(message)&#10;&#10;&#10;def _load_rng_functions():&#10;    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'&#10;    dll_name = f'hRng_{arch}.dll'&#10;    base_dir = os.path.dirname(__file__)&#10;    possible_dist_paths = [&#10;        os.path.join(base_dir, 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', '..', 'dist', arch, dll_name),&#10;    ]&#10;&#10;    dll_path = None&#10;    for path in possible_dist_paths:&#10;        abs_path = os.path.abspath(path)&#10;        if os.path.exists(abs_path):&#10;            dll_path = abs_path&#10;            break&#10;&#10;    if dll_path is None:&#10;        dll_path = os.path.abspath(possible_dist_paths[0])  # fallback for error message&#10;&#10;    dll = ctypes.CDLL(dll_path)&#10;&#10;    # Setup function signatures&#10;    MaxRNG = dll.MaxRNG&#10;    MaxRNG.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int]&#10;    MaxRNG.restype = ctypes.c_int&#10;&#10;    MaxRNG_Extended = dll.MaxRNG_Extended&#10;    MaxRNG_Extended.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int, ctypes.c_int]&#10;    MaxRNG_Extended.restype = ctypes.c_int&#10;&#10;    RNG_SelfTest = dll.RNG_SelfTest&#10;    RNG_SelfTest.argtypes = []&#10;    RNG_SelfTest.restype = ctypes.c_int&#10;&#10;    # Thread safety check function&#10;    IsRNGThreadSafe = dll.IsRNGThreadSafe&#10;    IsRNGThreadSafe.argtypes = []&#10;    IsRNGThreadSafe.restype = ctypes.c_int&#10;&#10;    return MaxRNG, MaxRNG_Extended, RNG_SelfTest, IsRNGThreadSafe&#10;&#10;&#10;# Load the functions only once&#10;_MaxRNG, _MaxRNG_Extended, _RNG_SelfTest, _IsRNGThreadSafe = _load_rng_functions()&#10;&#10;&#10;def get_hardware_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def get_thread_safe_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG with thread safety.&#10;&#10;    This function uses the thread-safe implementation of MaxRNG that properly&#10;    synchronizes access across multiple threads.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails or thread safety is not available.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    if not is_thread_safe_available():&#10;        raise HardwareRNGError(&quot;Thread-safe RNG implementation not available&quot;)&#10;&#10;    # Uses the same MaxRNG function which is internally thread-safe&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;Thread-safe MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def is_thread_safe_available() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if the thread-safe RNG implementation is available.&#10;&#10;    Returns:&#10;        bool: True if thread safety is available, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_IsRNGThreadSafe())&#10;&#10;&#10;# TODO Benchmark all with proper graphs and tests&#10;def get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve random bytes using MaxRNG_Extended.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;        intensive_level (int): Entropy gathering intensity (&gt;=1).&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size or intensive_level is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;    if intensive_level &lt; 1:&#10;        raise ValueError(&quot;intensive_level must be &gt;= 1&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG_Extended(buffer, size, intensive_level)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG_Extended failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def hardware_rng_selftest() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Run the RNG self-test.&#10;&#10;    Returns:&#10;        bool: True if self-test passes, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_RNG_SelfTest())&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;hwrng.py&#10;&#10;Hardware Random Number Generator interface for Python using ctypes and the new hRng.dll.&#10;&quot;&quot;&quot;&#10;&#10;import ctypes&#10;import os&#10;import platform&#10;import threading&#10;&#10;__all__ = [&#10;    &quot;get_hardware_random_bytes&quot;,&#10;    &quot;get_thread_safe_random_bytes&quot;,&#10;    &quot;get_hardware_random_bytes_extended&quot;,&#10;    &quot;hardware_rng_selftest&quot;,&#10;    &quot;is_thread_safe_available&quot;,&#10;    &quot;HardwareRNGError&quot;&#10;]&#10;&#10;&#10;class HardwareRNGError(RuntimeError):&#10;    &quot;&quot;&quot;Raised when hardware RNG fails or DLL cannot be loaded.&quot;&quot;&quot;&#10;    def __init__(self, message=&quot;Hardware RNG error occurred&quot;):&#10;        super().__init__(message)&#10;&#10;&#10;# Global lock for Python-level thread safety&#10;_py_lock = threading.Lock()&#10;&#10;def _load_rng_functions():&#10;    arch = 'x64' if platform.architecture()[0] == '64bit' else 'x86'&#10;    dll_name = f'hRng_{arch}.dll'&#10;    base_dir = os.path.dirname(__file__)&#10;    possible_dist_paths = [&#10;        os.path.join(base_dir, 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', 'dist', arch, dll_name),&#10;        os.path.join(base_dir, '..', '..', 'dist', arch, dll_name),&#10;    ]&#10;&#10;    dll_path = None&#10;    for path in possible_dist_paths:&#10;        abs_path = os.path.abspath(path)&#10;        if os.path.exists(abs_path):&#10;            dll_path = abs_path&#10;            break&#10;&#10;    if dll_path is None:&#10;        # Try looking for the DLL in the current directory as a fallback&#10;        current_dir = os.path.abspath(os.getcwd())&#10;        fallback_path = os.path.join(current_dir, dll_name)&#10;        if os.path.exists(fallback_path):&#10;            dll_path = fallback_path&#10;        else:&#10;            dll_path = os.path.abspath(possible_dist_paths[0])  # fallback for error message&#10;            raise HardwareRNGError(f&quot;Could not find {dll_name}. Searched in {', '.join(possible_dist_paths)}&quot;)&#10;&#10;    try:&#10;        dll = ctypes.CDLL(dll_path)&#10;    except Exception as e:&#10;        raise HardwareRNGError(f&quot;Failed to load {dll_path}: {str(e)}&quot;)&#10;&#10;    # Setup function signatures&#10;    MaxRNG = dll.MaxRNG&#10;    MaxRNG.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int]&#10;    MaxRNG.restype = ctypes.c_int&#10;&#10;    MaxRNG_Extended = dll.MaxRNG_Extended&#10;    MaxRNG_Extended.argtypes = [ctypes.POINTER(ctypes.c_ubyte), ctypes.c_int, ctypes.c_int]&#10;    MaxRNG_Extended.restype = ctypes.c_int&#10;&#10;    RNG_SelfTest = dll.RNG_SelfTest&#10;    RNG_SelfTest.argtypes = []&#10;    RNG_SelfTest.restype = ctypes.c_int&#10;&#10;    # Thread safety check function&#10;    IsRNGThreadSafe = dll.IsRNGThreadSafe&#10;    IsRNGThreadSafe.argtypes = []&#10;    IsRNGThreadSafe.restype = ctypes.c_int&#10;&#10;    return MaxRNG, MaxRNG_Extended, RNG_SelfTest, IsRNGThreadSafe&#10;&#10;&#10;# Load the functions only once in a thread-safe way&#10;try:&#10;    _MaxRNG, _MaxRNG_Extended, _RNG_SelfTest, _IsRNGThreadSafe = _load_rng_functions()&#10;except HardwareRNGError as e:&#10;    # Provide stubs for functions in case the DLL couldn't be loaded&#10;    def _error_stub(*args, **kwargs):&#10;        raise HardwareRNGError(&quot;RNG functions unavailable - DLL could not be loaded&quot;)&#10;    &#10;    _MaxRNG = _MaxRNG_Extended = _RNG_SelfTest = _IsRNGThreadSafe = _error_stub&#10;    print(f&quot;WARNING: Failed to load RNG DLL: {str(e)}&quot;)&#10;&#10;&#10;def get_hardware_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    # Add Python-level thread safety as a backup&#10;    with _py_lock:&#10;        buffer = (ctypes.c_ubyte * size)()&#10;        success = _MaxRNG(buffer, size)&#10;        if not success:&#10;            raise HardwareRNGError(&quot;MaxRNG failed.&quot;)&#10;        &#10;        # Make a copy to ensure buffer is fully processed before releasing the lock&#10;        return bytes(buffer)&#10;&#10;&#10;def get_thread_safe_random_bytes(size: int) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve cryptographically secure random bytes from MaxRNG with thread safety.&#10;&#10;    This function uses the thread-safe implementation of MaxRNG that properly&#10;    synchronizes access across multiple threads.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size is not positive.&#10;        HardwareRNGError: If the RNG fails or thread safety is not available.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;&#10;    if not is_thread_safe_available():&#10;        # Fall back to Python-level locking if C-level thread safety is not available&#10;        return get_hardware_random_bytes(size)&#10;&#10;    # Uses the same MaxRNG function which is internally thread-safe&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG(buffer, size)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;Thread-safe MaxRNG failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def is_thread_safe_available() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if the thread-safe RNG implementation is available.&#10;&#10;    Returns:&#10;        bool: True if thread safety is available, False otherwise.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return bool(_IsRNGThreadSafe())&#10;    except Exception:&#10;        return False&#10;&#10;&#10;# TODO Benchmark all with proper graphs and tests&#10;def get_hardware_random_bytes_extended(size: int, intensive_level: int = 2) -&gt; bytes:&#10;    &quot;&quot;&quot;&#10;    Retrieve random bytes using MaxRNG_Extended.&#10;&#10;    Args:&#10;        size (int): Number of random bytes to generate.&#10;        intensive_level (int): Entropy gathering intensity (&gt;=1).&#10;&#10;    Returns:&#10;        bytes: Random bytes.&#10;&#10;    Raises:&#10;        ValueError: If size or intensive_level is not positive.&#10;        HardwareRNGError: If the RNG fails.&#10;    &quot;&quot;&quot;&#10;    if size &lt;= 0:&#10;        raise ValueError(&quot;Size must be a positive integer&quot;)&#10;    if intensive_level &lt; 1:&#10;        raise ValueError(&quot;intensive_level must be &gt;= 1&quot;)&#10;&#10;    buffer = (ctypes.c_ubyte * size)()&#10;    success = _MaxRNG_Extended(buffer, size, intensive_level)&#10;    if not success:&#10;        raise HardwareRNGError(&quot;MaxRNG_Extended failed.&quot;)&#10;    return bytes(buffer)&#10;&#10;&#10;def hardware_rng_selftest() -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Run the RNG self-test.&#10;&#10;    Returns:&#10;        bool: True if self-test passes, False otherwise.&#10;    &quot;&quot;&quot;&#10;    return bool(_RNG_SelfTest())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/example/t.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/example/t.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Example demonstrating thread-safe random number generation using PyCTools hwrng module.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import threading&#10;from pyCTools.hwrng import (&#10;    get_hardware_random_bytes,&#10;    get_thread_safe_random_bytes,&#10;    is_thread_safe_available,&#10;    HardwareRNGError&#10;)&#10;&#10;&#10;def thread_safe_example():&#10;    &quot;&quot;&quot;&#10;    Demonstrates the usage of thread-safe RNG functionality.&#10;    Compares standard and thread-safe implementations under high contention.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Thread-Safe RNG Example&quot;)&#10;    print(&quot;-----------------------&quot;)&#10;&#10;    # Check if thread safety is available&#10;    thread_safe_available = is_thread_safe_available()&#10;    print(f&quot;Thread-safe RNG implementation available: {thread_safe_available}&quot;)&#10;&#10;    if not thread_safe_available:&#10;        print(&quot;WARNING: Thread-safe implementation not available. Test will use standard RNG.&quot;)&#10;&#10;    # Number of threads to create&#10;    num_threads = 20&#10;    iterations_per_thread = 30&#10;    bytes_per_request = 16&#10;&#10;    # Results storage&#10;    standard_failures = 0&#10;    threadsafe_failures = 0&#10;&#10;    # Function for thread to run&#10;    def worker_thread(thread_id, use_thread_safe, results_list):&#10;        method = &quot;thread_safe&quot; if use_thread_safe else &quot;standard&quot;&#10;        rng_func = get_thread_safe_random_bytes if use_thread_safe else get_hardware_random_bytes&#10;&#10;        for i_ in range(iterations_per_thread):&#10;            try:&#10;                start_time_ = time.time()&#10;                random_data = rng_func(bytes_per_request)&#10;                elapsed = time.time() - start_time_&#10;&#10;                results_list.append({&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'data': random_data.hex()[:8] + '...',  # Show first 4 bytes only&#10;                    'time': elapsed&#10;                })&#10;&#10;                # Add a tiny sleep to allow thread switching&#10;                time.sleep(0.001)&#10;&#10;            except HardwareRNGError as e:&#10;                results_list.append({&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'error': str(e)&#10;                })&#10;                if use_thread_safe:&#10;                    nonlocal threadsafe_failures&#10;                    threadsafe_failures += 1&#10;                else:&#10;                    nonlocal standard_failures&#10;                    standard_failures += 1&#10;                break&#10;&#10;    # Test standard implementation&#10;    print(&quot;\nRunning standard RNG with multiple threads...&quot;)&#10;    standard_results = []&#10;    standard_threads = []&#10;&#10;    start_time = time.time()&#10;    for i in range(num_threads):&#10;        t = threading.Thread(&#10;            target=worker_thread,&#10;            args=(i, False, standard_results)&#10;        )&#10;        standard_threads.append(t)&#10;        t.start()&#10;&#10;    for t in standard_threads:&#10;        t.join()&#10;&#10;    standard_time = time.time() - start_time&#10;&#10;    # Test thread-safe implementation if available&#10;    threadsafe_time = 0&#10;    threadsafe_results = []&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nRunning thread-safe RNG with multiple threads...&quot;)&#10;        threadsafe_threads = []&#10;&#10;        start_time = time.time()&#10;        for i in range(num_threads):&#10;            t = threading.Thread(&#10;                target=worker_thread,&#10;                args=(i, True, threadsafe_results)&#10;            )&#10;            threadsafe_threads.append(t)&#10;            t.start()&#10;&#10;        for t in threadsafe_threads:&#10;            t.join()&#10;&#10;        threadsafe_time = time.time() - start_time&#10;&#10;    # Print results summary&#10;    print(&quot;\nResults Summary:&quot;)&#10;    print(&quot;--------------&quot;)&#10;    print(f&quot;Standard RNG: {len(standard_results)} operations in {standard_time:.3f}s&quot;)&#10;    print(f&quot;  - Success rate: {(len(standard_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;    print(f&quot;  - Failures: {standard_failures}&quot;)&#10;    print(f&quot;  - Avg time per operation: {standard_time / len(standard_results):.6f}s&quot;)&#10;&#10;    if thread_safe_available:&#10;        print(f&quot;\nThread-safe RNG: {len(threadsafe_results)} operations in {threadsafe_time:.3f}s&quot;)&#10;        print(f&quot;  - Success rate: {(len(threadsafe_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;        print(f&quot;  - Failures: {threadsafe_failures}&quot;)&#10;        print(f&quot;  - Avg time per operation: {threadsafe_time / len(threadsafe_results):.6f}s&quot;)&#10;&#10;        # Performance comparison&#10;        if standard_time &gt; 0 and threadsafe_time &gt; 0:&#10;            relative_perf = standard_time / threadsafe_time&#10;            if relative_perf &gt; 1:&#10;                print(f&quot;\nThread-safe implementation is {relative_perf:.2f}x faster than standard&quot;)&#10;            else:&#10;                print(f&quot;\nStandard implementation is {1/relative_perf:.2f}x faster than thread-safe&quot;)&#10;&#10;    # Show a sample of random values from each&#10;    print(&quot;\nSample Standard RNG values:&quot;)&#10;    for i, result in enumerate(standard_results[:5]):&#10;        if 'error' in result:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;        else:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nSample Thread-safe RNG values:&quot;)&#10;        for i, result in enumerate(threadsafe_results[:5]):&#10;            if 'error' in result:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;            else:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    thread_safe_example()&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Example demonstrating thread-safe random number generation using PyCTools hwrng module.&#10;&quot;&quot;&quot;&#10;&#10;import time&#10;import threading&#10;from pyCTools.hwrng import (&#10;    get_hardware_random_bytes,&#10;    get_thread_safe_random_bytes,&#10;    is_thread_safe_available,&#10;    HardwareRNGError&#10;)&#10;&#10;&#10;def thread_safe_example():&#10;    &quot;&quot;&quot;&#10;    Demonstrates the usage of thread-safe RNG functionality.&#10;    Compares standard and thread-safe implementations under high contention.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Thread-Safe RNG Example&quot;)&#10;    print(&quot;-----------------------&quot;)&#10;&#10;    # Check if thread safety is available&#10;    thread_safe_available = is_thread_safe_available()&#10;    print(f&quot;Thread-safe RNG implementation available: {thread_safe_available}&quot;)&#10;&#10;    if not thread_safe_available:&#10;        print(&quot;WARNING: Thread-safe implementation not available. Test will use standard RNG.&quot;)&#10;&#10;    # Number of threads to create - reduce count to avoid overloading&#10;    num_threads = 10&#10;    iterations_per_thread = 10&#10;    bytes_per_request = 16&#10;&#10;    # Results storage&#10;    standard_failures = 0&#10;    threadsafe_failures = 0&#10;&#10;    # Function for thread to run with proper exception handling&#10;    def worker_thread(thread_id, use_thread_safe, results_list):&#10;        method = &quot;thread_safe&quot; if use_thread_safe else &quot;standard&quot;&#10;        rng_func = get_thread_safe_random_bytes if use_thread_safe else get_hardware_random_bytes&#10;&#10;        for i_ in range(iterations_per_thread):&#10;            try:&#10;                start_time_ = time.time()&#10;                random_data = rng_func(bytes_per_request)&#10;                elapsed = time.time() - start_time_&#10;                &#10;                # Store result safely&#10;                result_entry = {&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'data': random_data.hex()[:8] + '...',  # Show first 4 bytes only&#10;                    'time': elapsed&#10;                }&#10;                &#10;                # Use thread lock for updating shared data&#10;                with threading.Lock():&#10;                    results_list.append(result_entry)&#10;&#10;                # Add a tiny sleep to allow thread switching&#10;                time.sleep(0.005)  # Slightly longer sleep to reduce contention&#10;&#10;            except Exception as e:&#10;                error_entry = {&#10;                    'thread': thread_id,&#10;                    'iteration': i_,&#10;                    'method': method,&#10;                    'error': str(e)&#10;                }&#10;                &#10;                with threading.Lock():&#10;                    results_list.append(error_entry)&#10;                    if use_thread_safe:&#10;                        nonlocal threadsafe_failures&#10;                        threadsafe_failures += 1&#10;                    else:&#10;                        nonlocal standard_failures&#10;                        standard_failures += 1&#10;                &#10;                # Don't break - let thread continue trying other iterations&#10;                time.sleep(0.01)  # Sleep a bit after error&#10;&#10;    # Test standard implementation&#10;    print(&quot;\nRunning standard RNG with multiple threads...&quot;)&#10;    standard_results = []&#10;    standard_threads = []&#10;&#10;    start_time = time.time()&#10;    &#10;    # Create threads with proper error handling&#10;    try:&#10;        for i in range(num_threads):&#10;            t = threading.Thread(&#10;                target=worker_thread,&#10;                args=(i, False, standard_results),&#10;                name=f&quot;Std-Thread-{i}&quot;&#10;            )&#10;            standard_threads.append(t)&#10;            t.start()&#10;            # Brief sleep between thread starts&#10;            time.sleep(0.01)&#10;            &#10;        print(f&quot;Started {len(standard_threads)} standard threads&quot;)&#10;            &#10;        # Join with timeout to prevent hanging&#10;        for t in standard_threads:&#10;            t.join(timeout=10.0)  # 10 second timeout per thread&#10;            if t.is_alive():&#10;                print(f&quot;Warning: Thread {t.name} did not complete in time&quot;)&#10;                &#10;    except Exception as e:&#10;        print(f&quot;Error during standard thread execution: {str(e)}&quot;)&#10;&#10;    standard_time = time.time() - start_time&#10;    print(f&quot;Standard thread test completed in {standard_time:.2f} seconds&quot;)&#10;&#10;    # Test thread-safe implementation if available&#10;    threadsafe_time = 0&#10;    threadsafe_results = []&#10;&#10;    if thread_safe_available:&#10;        print(&quot;\nRunning thread-safe RNG with multiple threads...&quot;)&#10;        threadsafe_threads = []&#10;&#10;        start_time = time.time()&#10;        &#10;        try:&#10;            for i in range(num_threads):&#10;                t = threading.Thread(&#10;                    target=worker_thread,&#10;                    args=(i, True, threadsafe_results),&#10;                    name=f&quot;Safe-Thread-{i}&quot;&#10;                )&#10;                threadsafe_threads.append(t)&#10;                t.start()&#10;                # Brief sleep between thread starts&#10;                time.sleep(0.01)&#10;                &#10;            print(f&quot;Started {len(threadsafe_threads)} thread-safe threads&quot;)&#10;                &#10;            # Join with timeout to prevent hanging&#10;            for t in threadsafe_threads:&#10;                t.join(timeout=10.0)&#10;                if t.is_alive():&#10;                    print(f&quot;Warning: Thread {t.name} did not complete in time&quot;)&#10;                    &#10;        except Exception as e:&#10;            print(f&quot;Error during thread-safe thread execution: {str(e)}&quot;)&#10;&#10;        threadsafe_time = time.time() - start_time&#10;        print(f&quot;Thread-safe test completed in {threadsafe_time:.2f} seconds&quot;)&#10;&#10;    # Print results summary - only if we have any results&#10;    if standard_results:&#10;        print(&quot;\nResults Summary:&quot;)&#10;        print(&quot;--------------&quot;)&#10;        print(f&quot;Standard RNG: {len(standard_results)} operations in {standard_time:.3f}s&quot;)&#10;        print(f&quot;  - Success rate: {(len(standard_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;        print(f&quot;  - Failures: {standard_failures}&quot;)&#10;        if standard_results:&#10;            print(f&quot;  - Avg time per operation: {standard_time / max(len(standard_results), 1):.6f}s&quot;)&#10;&#10;        if thread_safe_available and threadsafe_results:&#10;            print(f&quot;\nThread-safe RNG: {len(threadsafe_results)} operations in {threadsafe_time:.3f}s&quot;)&#10;            print(f&quot;  - Success rate: {(len(threadsafe_results) / (num_threads * iterations_per_thread)) * 100:.1f}%&quot;)&#10;            print(f&quot;  - Failures: {threadsafe_failures}&quot;)&#10;            print(f&quot;  - Avg time per operation: {threadsafe_time / max(len(threadsafe_results), 1):.6f}s&quot;)&#10;&#10;            # Performance comparison&#10;            if standard_time &gt; 0 and threadsafe_time &gt; 0 and len(standard_results) &gt; 0 and len(threadsafe_results) &gt; 0:&#10;                relative_perf = standard_time / threadsafe_time&#10;                if relative_perf &gt; 1:&#10;                    print(f&quot;\nThread-safe implementation is {relative_perf:.2f}x faster than standard&quot;)&#10;                else:&#10;                    print(f&quot;\nStandard implementation is {1/relative_perf:.2f}x faster than thread-safe&quot;)&#10;    else:&#10;        print(&quot;\nNo results collected! Test failed to run properly.&quot;)&#10;&#10;    # Show a sample of random values from each&#10;    print(&quot;\nSample Standard RNG values:&quot;)&#10;    for i, result in enumerate(standard_results[:5]):&#10;        if 'error' in result:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;        else:&#10;            print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;    if thread_safe_available and threadsafe_results:&#10;        print(&quot;\nSample Thread-safe RNG values:&quot;)&#10;        for i, result in enumerate(threadsafe_results[:5]):&#10;            if 'error' in result:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - ERROR: {result['error']}&quot;)&#10;            else:&#10;                print(f&quot;  {i+1}. Thread {result['thread']} - {result['data']} ({result['time']:.6f}s)&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    thread_safe_example()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.c" />
              <option name="originalContent" value="#define WIN32_NO_STATUS&#10;#include &lt;windows.h&gt;     // Brings in winnt.h without NTSTATUS definitions&#10;#undef WIN32_NO_STATUS&#10;#include &lt;ntstatus.h&gt;    // Now pulls in the NTSTATUS codes without conflict&#10;&#10;#include &lt;stdint.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;immintrin.h&gt;   // For _rdrand32_step&#10;#include &lt;intrin.h&gt;      // For __cpuid&#10;#include &lt;mmsystem.h&gt;    // For waveIn functions&#10;#include &lt;iphlpapi.h&gt;    // For network stats&#10;#include &lt;psapi.h&gt;       // For GetProcessMemoryInfo&#10;#include &lt;powrprof.h&gt;    // For battery info&#10;&#10;#pragma comment(lib, &quot;winmm.lib&quot;)&#10;#pragma comment(lib, &quot;bcrypt.lib&quot;)&#10;#pragma comment(lib, &quot;iphlpapi.lib&quot;)&#10;#pragma comment(lib, &quot;psapi.lib&quot;)&#10;#pragma comment(lib, &quot;powrprof.lib&quot;)&#10;&#10;// Define DLL export macro for cleaner syntax&#10;#define HRNG_API __declspec(dllexport)&#10;&#10;// Global mutex for thread synchronization&#10;static HANDLE g_mutex = NULL;&#10;&#10;// Thread-safe mutex acquisition with timeout&#10;static int acquire_mutex(const unsigned int timeout_ms) {&#10;    if (!g_mutex) return 0;&#10;&#10;    const DWORD result = WaitForSingleObject(g_mutex, timeout_ms);&#10;    if (result == WAIT_OBJECT_0) {&#10;        return 1; // Successfully acquired&#10;    }&#10;    // Handle timeout or error&#10;    return 0;&#10;}&#10;&#10;// Thread-safe mutex release&#10;static void release_mutex(void) {&#10;    if (g_mutex) {&#10;        ReleaseMutex(g_mutex);&#10;    }&#10;}&#10;&#10;// Secure mixing function using SHA-256&#10;static int mix_entropy(unsigned char* buffer, unsigned char* new_data, const size_t data_size) {&#10;    BCRYPT_ALG_HANDLE hAlg = NULL;&#10;    BCRYPT_HASH_HANDLE hHash = NULL;&#10;    DWORD hashSize = 0, resultSize = 0;&#10;    NTSTATUS status = STATUS_SUCCESS;&#10;    int success = 0;&#10;    unsigned char* temp_buffer = NULL;&#10;&#10;    // Initialize algorithm provider&#10;    status = BCryptOpenAlgorithmProvider(&amp;hAlg, BCRYPT_SHA256_ALGORITHM, NULL, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Get hash object size&#10;    status = BCryptGetProperty(hAlg, BCRYPT_OBJECT_LENGTH, (PUCHAR)&amp;hashSize,&#10;                               sizeof(hashSize), &amp;resultSize, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Allocate memory for hash object&#10;    temp_buffer = (unsigned char*)HeapAlloc(GetProcessHeap(), 0, hashSize);&#10;    if (!temp_buffer) goto cleanup;&#10;&#10;    // Create hash object&#10;    status = BCryptCreateHash(hAlg, &amp;hHash, temp_buffer, hashSize, NULL, 0, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Hash existing buffer&#10;    status = BCryptHashData(hHash, buffer, 32, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Hash new data&#10;    status = BCryptHashData(hHash, new_data, (ULONG)data_size, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Finalize hash&#10;    status = BCryptFinishHash(hHash, buffer, 32, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    success = 1;&#10;&#10;cleanup:&#10;    if (hHash) BCryptDestroyHash(hHash);&#10;    if (hAlg) BCryptCloseAlgorithmProvider(hAlg, 0);&#10;    if (temp_buffer) HeapFree(GetProcessHeap(), 0, temp_buffer);&#10;&#10;    return success;&#10;}&#10;&#10;// Safely execute CPUID instruction (no SEH, just call)&#10;static int safe_cpuid(int cpuInfo[4], const int function_id) {&#10;    __cpuid(cpuInfo, function_id);&#10;    return 1;&#10;}&#10;&#10;// Check if CPU supports RDRAND instruction&#10;HRNG_API int has_rdrand() {&#10;    int info[4] = {0};&#10;    safe_cpuid(info, 1);&#10;    // Bit 30 of ECX indicates RDRAND support&#10;    return (info[2] &amp; (1 &lt;&lt; 30)) != 0;&#10;}&#10;&#10;// Fill buffer with hardware RNG bytes using RDRAND with retry logic&#10;HRNG_API int read_hwrng(unsigned char* buffer, const int size) {&#10;    if (!buffer || size &lt;= 0) {&#10;        return 0; // Invalid parameters&#10;    }&#10;&#10;    const int has_rdrand_support = has_rdrand();&#10;&#10;    // If RDRAND is not supported, fall back to BCryptGenRandom&#10;    if (!has_rdrand_support) {&#10;        const NTSTATUS status = BCryptGenRandom(NULL, buffer, size,&#10;                                         BCRYPT_USE_SYSTEM_PREFERRED_RNG);&#10;        return BCRYPT_SUCCESS(status) ? 1 : 0;&#10;    }&#10;&#10;    // Use a structured exception handling block for RDRAND operations&#10;    int i = 0;&#10;    uint32_t rnd;&#10;&#10;    while (i &lt; size) {&#10;        const int MAX_RETRIES = 10;&#10;        int success = 0;&#10;&#10;        // Try multiple times if RDRAND fails&#10;        for (int retry = 0; retry &lt; MAX_RETRIES &amp;&amp; !success; retry++) {&#10;            success = _rdrand32_step(&amp;rnd);&#10;            if (!success) Sleep(1); // Small delay between retries&#10;        }&#10;&#10;        if (!success) {&#10;            // Fall back to BCryptGenRandom if RDRAND keeps failing&#10;            const NTSTATUS status = BCryptGenRandom(NULL, buffer + i, size - i,&#10;                                             BCRYPT_USE_SYSTEM_PREFERRED_RNG);&#10;            return BCRYPT_SUCCESS(status) ? 1 : 0;&#10;        }&#10;&#10;        for (int j = 0; j &lt; 4 &amp;&amp; i &lt; size; ++j, ++i) {&#10;            buffer[i] = (rnd &gt;&gt; (j * 8)) &amp; 0xFF;&#10;        }&#10;    }&#10;&#10;    return 1;&#10;}&#10;&#10;// Get system performance info as entropy&#10;static int get_performance_entropy(unsigned char *buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    FILETIME idleTime, kernelTime, userTime;&#10;    MEMORYSTATUSEX memInfo;&#10;    memInfo.dwLength = sizeof(MEMORYSTATUSEX);&#10;&#10;    if (!GetSystemTimes(&amp;idleTime, &amp;kernelTime, &amp;userTime) ||&#10;        !GlobalMemoryStatusEx(&amp;memInfo)) {&#10;        return 0;&#10;    }&#10;&#10;    // Mix different timing and memory values&#10;    ULARGE_INTEGER idle, kernel, user, diskRead, diskWrite;&#10;    idle.LowPart = idleTime.dwLowDateTime;&#10;    idle.HighPart = idleTime.dwHighDateTime;&#10;    kernel.LowPart = kernelTime.dwLowDateTime;&#10;    kernel.HighPart = kernelTime.dwHighDateTime;&#10;    user.LowPart = userTime.dwLowDateTime;&#10;    user.HighPart = userTime.dwHighDateTime;&#10;&#10;    // Get disk I/O information&#10;    IO_COUNTERS ioCounters;&#10;    if (!GetProcessIoCounters(GetCurrentProcess(), &amp;ioCounters)) {&#10;        return 0;&#10;    }&#10;&#10;    diskRead.QuadPart = ioCounters.ReadTransferCount;&#10;    diskWrite.QuadPart = ioCounters.WriteTransferCount;&#10;&#10;    // Process memory information&#10;    PROCESS_MEMORY_COUNTERS pmc;&#10;    if (!GetProcessMemoryInfo(GetCurrentProcess(), &amp;pmc, sizeof(pmc))) {&#10;        return 0;&#10;    }&#10;&#10;    // Get high-precision timer&#10;    LARGE_INTEGER perfCounter, perfFreq;&#10;    QueryPerformanceCounter(&amp;perfCounter);&#10;    QueryPerformanceFrequency(&amp;perfFreq);&#10;&#10;    // Fill the buffer with collected entropy&#10;    memcpy(buffer, &amp;idle.QuadPart, 8);&#10;    memcpy(buffer + 8, &amp;perfCounter.QuadPart, 8);&#10;    memcpy(buffer + 16, &amp;kernel.QuadPart, 8);&#10;    memcpy(buffer + 24, &amp;user.QuadPart, 8);&#10;    memcpy(buffer + 32, &amp;memInfo.ullAvailPhys, 8);&#10;    memcpy(buffer + 40, &amp;memInfo.ullTotalPhys, 8);&#10;    memcpy(buffer + 48, &amp;diskRead.QuadPart, 8);&#10;    memcpy(buffer + 56, &amp;diskWrite.QuadPart, 8);&#10;&#10;    // Add process info&#10;    memcpy(buffer + 64, &amp;pmc.WorkingSetSize, 8);&#10;    memcpy(buffer + 72, &amp;pmc.PagefileUsage, 8);&#10;&#10;    return 1;&#10;}&#10;&#10;// Get audio data from microphone as entropy source&#10;static int get_audio_entropy(unsigned char* buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    HWAVEIN hWaveIn = NULL;&#10;    WAVEHDR waveHdr = {0};&#10;    WAVEFORMATEX wfx = {0};&#10;    int success = 0;&#10;    unsigned char* audioBuffer = NULL;&#10;&#10;    wfx.wFormatTag = WAVE_FORMAT_PCM;&#10;    wfx.nChannels = 1;&#10;    wfx.nSamplesPerSec = 8000;&#10;    wfx.wBitsPerSample = 8;&#10;    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;&#10;    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;&#10;&#10;    // Try to open any available audio device&#10;    MMRESULT result = waveInOpen(&amp;hWaveIn, WAVE_MAPPER, &amp;wfx, 0, 0, CALLBACK_NULL);&#10;    if (result != MMSYSERR_NOERROR) {&#10;        // No audio device available - fill with ticks instead&#10;        const DWORD ticks = GetTickCount();&#10;        for (size_t i = 0; i &lt; 128; i++) {&#10;            buffer[i] = (unsigned char)((ticks + i) &amp; 0xFF);&#10;        }&#10;        return 1; // Return success anyway&#10;    }&#10;&#10;    // Prepare wave buffer&#10;    audioBuffer = (unsigned char*)HeapAlloc(GetProcessHeap(), 0, 128);&#10;    if (!audioBuffer) {&#10;        waveInClose(hWaveIn);&#10;        return 0;&#10;    }&#10;&#10;    waveHdr.lpData = (LPSTR)audioBuffer;&#10;    waveHdr.dwBufferLength = (DWORD)128;&#10;&#10;    result = waveInPrepareHeader(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;    if (result != MMSYSERR_NOERROR) {&#10;        HeapFree(GetProcessHeap(), 0, audioBuffer);&#10;        waveInClose(hWaveIn);&#10;        return 0;&#10;    }&#10;&#10;    // Add the buffer to audio input&#10;    result = waveInAddBuffer(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;    if (result != MMSYSERR_NOERROR) {&#10;        waveInUnprepareHeader(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;        HeapFree(GetProcessHeap(), 0, audioBuffer);&#10;        waveInClose(hWaveIn);&#10;        return 0;&#10;    }&#10;&#10;    // Start recording&#10;    result = waveInStart(hWaveIn);&#10;    if (result != MMSYSERR_NOERROR) {&#10;        waveInUnprepareHeader(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;        HeapFree(GetProcessHeap(), 0, audioBuffer);&#10;        waveInClose(hWaveIn);&#10;        return 0;&#10;    }&#10;&#10;    // Wait for buffer to fill (with timeout)&#10;    const DWORD startTime = GetTickCount();&#10;    while (!(waveHdr.dwFlags &amp; WHDR_DONE)) {&#10;        Sleep(10);&#10;        if (GetTickCount() - startTime &gt; 500) break; // 500ms timeout&#10;    }&#10;&#10;    // Copy whatever data we got&#10;    memcpy(buffer, audioBuffer, 128);&#10;    success = 1;&#10;&#10;    // Cleanup&#10;    waveInStop(hWaveIn);&#10;    waveInUnprepareHeader(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;    waveInClose(hWaveIn);&#10;    HeapFree(GetProcessHeap(), 0, audioBuffer);&#10;&#10;    return success;&#10;}&#10;&#10;// Get battery/power information as entropy source&#10;static int get_battery_entropy(unsigned char* buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    SYSTEM_POWER_STATUS powerStatus;&#10;    if (!GetSystemPowerStatus(&amp;powerStatus)) {&#10;        return 0;&#10;    }&#10;&#10;    // Get detailed battery information if available&#10;    SYSTEM_BATTERY_STATE batteryState;&#10;    if (CallNtPowerInformation(SystemBatteryState, NULL, 0,&#10;                              &amp;batteryState, sizeof(batteryState)) == STATUS_SUCCESS) {&#10;        memcpy(buffer, &amp;batteryState, min(128, sizeof(batteryState)));&#10;    } else {&#10;        // Fall back to basic power information&#10;        memcpy(buffer, &amp;powerStatus, min(128, sizeof(powerStatus)));&#10;    }&#10;&#10;    return 1;&#10;}&#10;&#10;// Get network statistics as entropy&#10;static int get_network_entropy(unsigned char* buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    // Get adapter info&#10;    IP_ADAPTER_INFO adapterInfo[16];&#10;    ULONG bufLen = sizeof(adapterInfo);&#10;    const DWORD result = GetAdaptersInfo(adapterInfo, &amp;bufLen);&#10;&#10;    if (result != ERROR_SUCCESS) {&#10;        return 0;&#10;    }&#10;&#10;    // Get TCP statistics&#10;    MIB_TCPSTATS tcpStats;&#10;    if (GetTcpStatistics(&amp;tcpStats) != NO_ERROR) {&#10;        return 0;&#10;    }&#10;&#10;    // Fill buffer with network data&#10;    memcpy(buffer, &amp;tcpStats, min(128, sizeof(tcpStats)));&#10;&#10;    return 1;&#10;}&#10;&#10;// Get CPU-specific entropy using RDTSC and other hardware features&#10;static int get_cpu_entropy(unsigned char* buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    // Get cycles using RDTSC&#10;    unsigned __int64 cycles;&#10;&#10;    cycles = __rdtsc();&#10;    memcpy(buffer, &amp;cycles, sizeof(cycles));&#10;&#10;    // CPU information&#10;    int cpuInfo[4] = {0};&#10;    safe_cpuid(cpuInfo, 0);&#10;    memcpy(buffer + 8, cpuInfo, 16);&#10;&#10;    return 1;&#10;}&#10;&#10;// MaxRNG: Uses multiple entropy sources and mixes them together&#10;HRNG_API int MaxRNG(unsigned char* buffer, const int size) {&#10;    if (!buffer || size &lt;= 0) {&#10;        return 0;&#10;    }&#10;&#10;    // Thread safety: acquire mutex with 1000ms timeout&#10;    const int mutex_acquired = acquire_mutex(1000);&#10;    if (!mutex_acquired) {&#10;        // Failed to acquire mutex, cannot safely proceed&#10;        return 0;&#10;    }&#10;&#10;    // Allocate temporary buffers for entropy collection&#10;    unsigned char* temp_buffer = NULL;&#10;    const size_t TEMP_SIZE = 128;  // Minimum size for various entropy sources&#10;    int success = 0;&#10;&#10;    // Initialize the output buffer with initial entropy from system RNG&#10;    if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, buffer, size, BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    // Allocate temp buffer for entropy sources&#10;    temp_buffer = (unsigned char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, TEMP_SIZE);&#10;    if (!temp_buffer) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    do {&#10;        // Collect entropy from hardware RNG if available (RDRAND)&#10;        if (has_rdrand()) {&#10;            if (!read_hwrng(temp_buffer, (int)min(TEMP_SIZE, size))) {&#10;                // Fall back to BCryptGenRandom if RDRAND fails&#10;                if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, temp_buffer, (ULONG)min(TEMP_SIZE, size),&#10;                                                   BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;                    break;&#10;                }&#10;            }&#10;            // Mix hardware RNG entropy into buffer&#10;            if (!mix_entropy(buffer, temp_buffer, min(TEMP_SIZE, size))) break;&#10;        }&#10;&#10;        // Collect and mix CPU entropy&#10;        if (get_cpu_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Collect and mix performance/timing entropy&#10;        if (get_performance_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Collect and mix audio entropy (or timing data if no mic available)&#10;        if (get_audio_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Collect and mix battery/power entropy&#10;        if (get_battery_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Collect and mix network entropy&#10;        if (get_network_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Final mixing with high-precision timer&#10;        LARGE_INTEGER counter;&#10;        QueryPerformanceCounter(&amp;counter);&#10;        memcpy(temp_buffer, &amp;counter, sizeof(counter));&#10;        if (!mix_entropy(buffer, temp_buffer, sizeof(counter))) break;&#10;&#10;        success = 1;&#10;    } while (0); // Non-looping do-while to allow for breaks&#10;&#10;    // Securely clean up the temporary buffer&#10;    SecureZeroMemory(temp_buffer, TEMP_SIZE);&#10;    HeapFree(GetProcessHeap(), 0, temp_buffer);&#10;&#10;    // Release mutex before returning&#10;    release_mutex();&#10;&#10;    return success;&#10;}&#10;&#10;// Additional extended entropy gathering for MaxRNG&#10;HRNG_API int MaxRNG_Extended(unsigned char* buffer, const int size, const int intensive_level) {&#10;    if (!buffer || size &lt;= 0 || intensive_level &lt; 0) {&#10;        return 0;&#10;    }&#10;&#10;    // Thread safety: acquire mutex with 5000ms timeout (longer because this is intensive)&#10;    const int mutex_acquired = acquire_mutex(5000);&#10;    if (!mutex_acquired) {&#10;        // Failed to acquire mutex, cannot safely proceed&#10;        return 0;&#10;    }&#10;&#10;    unsigned char* temp_buffer = NULL;&#10;    const size_t TEMP_SIZE = 256;  // Larger temp buffer for extended entropy&#10;    int success = 0;&#10;    const int iterations = intensive_level &gt; 0 ? intensive_level : 1;&#10;&#10;    // First do a regular MaxRNG call - use internal version without mutex&#10;    // since we already have the mutex locked&#10;    if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, buffer, size, BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    // For higher security levels, perform multiple iterations of mixing&#10;    if (intensive_level &lt;= 1) {&#10;        release_mutex();&#10;        return 1; // Standard MaxRNG is enough for basic usage&#10;    }&#10;&#10;    // Allocate temp buffer for additional entropy passes&#10;    temp_buffer = (unsigned char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, TEMP_SIZE);&#10;    if (!temp_buffer) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    do {&#10;        // Additional entropy gathering based on intensity level&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            // Mix in more CPU jitter by performing intensive calculations&#10;            LARGE_INTEGER start, end;&#10;            QueryPerformanceCounter(&amp;start);&#10;&#10;            // CPU-intensive operation to generate timing differences&#10;            volatile double result = 1.0;&#10;            for (int j = 0; j &lt; 1000; j++) {&#10;                result *= 1.000001;&#10;            }&#10;&#10;            QueryPerformanceCounter(&amp;end);&#10;&#10;            // Mix in the timing results&#10;            memcpy(temp_buffer, &amp;start, sizeof(start));&#10;            memcpy(temp_buffer + sizeof(start), &amp;end, sizeof(end));&#10;            memcpy(temp_buffer + sizeof(start) + sizeof(end), (const void *)&amp;result, sizeof(result));&#10;            if (!mix_entropy(buffer, temp_buffer, sizeof(start) + sizeof(end) + sizeof(double))) {&#10;                break;&#10;            }&#10;&#10;            // Add a small sleep to allow system state to change&#10;            Sleep(1);&#10;&#10;            // For the highest intensity levels, gather more system state&#10;            if (intensive_level &gt;= 3) {&#10;                // Get multiple CPU info samples&#10;                for (int cpuid_leaf = 0; cpuid_leaf &lt; 4; cpuid_leaf++) {&#10;                    int cpu_info[4];&#10;                    safe_cpuid(cpu_info, cpuid_leaf);&#10;                    memcpy(temp_buffer + cpuid_leaf * 16, cpu_info, 16);&#10;                }&#10;&#10;                if (!mix_entropy(buffer, temp_buffer, 64)) {&#10;                    break;&#10;                }&#10;&#10;                // Gather disk I/O timing entropy&#10;                // ReSharper disable once CppLocalVariableMayBeConst&#10;                HANDLE hFile = CreateFile(&quot;NUL&quot;, GENERIC_WRITE,&#10;                                          FILE_SHARE_READ | FILE_SHARE_WRITE,&#10;                                          NULL, OPEN_EXISTING, 0, NULL);&#10;                if (hFile != INVALID_HANDLE_VALUE) {&#10;                    const char dummy[16] = {0};&#10;                    DWORD written = 0;&#10;&#10;                    QueryPerformanceCounter(&amp;start);&#10;                    WriteFile(hFile, dummy, sizeof(dummy), &amp;written, NULL);&#10;                    QueryPerformanceCounter(&amp;end);&#10;&#10;                    CloseHandle(hFile);&#10;&#10;                    memcpy(temp_buffer, &amp;start, sizeof(start));&#10;                    memcpy(temp_buffer + sizeof(start), &amp;end, sizeof(end));&#10;&#10;                    if (!mix_entropy(buffer, temp_buffer, sizeof(start) + sizeof(end))) {&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        success = 1;&#10;    } while (0); // Non-looping do-while to allow for breaks&#10;&#10;    SecureZeroMemory(temp_buffer, TEMP_SIZE);&#10;    HeapFree(GetProcessHeap(), 0, temp_buffer);&#10;&#10;    // Release mutex before returning&#10;    release_mutex();&#10;&#10;    return success;&#10;}&#10;&#10;// Self-test function to verify RNG functionality&#10;HRNG_API int RNG_SelfTest(void) {&#10;    // Thread safety: acquire mutex with 2000ms timeout&#10;    const int mutex_acquired = acquire_mutex(2000);&#10;    if (!mutex_acquired) {&#10;        // Failed to acquire mutex, cannot safely proceed&#10;        return 0;&#10;    }&#10;&#10;    unsigned char buffer1[32] = {0};&#10;    unsigned char buffer2[32] = {0};&#10;    int success = 0;&#10;&#10;    // Test hardware RNG if available&#10;    if (has_rdrand()) {&#10;        if (!read_hwrng(buffer1, sizeof(buffer1))) {&#10;            release_mutex();&#10;            return 0; // Hardware RNG failed&#10;        }&#10;&#10;        // Make sure we're not getting all zeros&#10;        int allZeros = 1;&#10;        for (int i = 0; i &lt; sizeof(buffer1); i++) {&#10;            if (buffer1[i] != 0) {&#10;                allZeros = 0;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (allZeros) {&#10;            release_mutex();&#10;            return 0; // Hardware RNG returned all zeros&#10;        }&#10;&#10;        // Test a second read to ensure different values&#10;        if (!read_hwrng(buffer2, sizeof(buffer2))) {&#10;            release_mutex();&#10;            return 0; // Second hardware RNG read failed&#10;        }&#10;&#10;        // Outputs should be different&#10;        if (memcmp(buffer1, buffer2, sizeof(buffer1)) == 0) {&#10;            release_mutex();&#10;            return 0; // Hardware RNG returned identical sequences&#10;        }&#10;    }&#10;&#10;    // Test MaxRNG&#10;    memset(buffer1, 0, sizeof(buffer1));&#10;    memset(buffer2, 0, sizeof(buffer2));&#10;&#10;    // Use BCryptGenRandom directly to avoid mutex deadlock&#10;    // since MaxRNG would try to acquire the same mutex&#10;    if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, buffer1, sizeof(buffer1),&#10;                                        BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, buffer2, sizeof(buffer2),&#10;                                        BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    // Outputs should be different&#10;    if (memcmp(buffer1, buffer2, sizeof(buffer1)) == 0) {&#10;        release_mutex();&#10;        return 0; // System RNG returned identical sequences&#10;    }&#10;&#10;    success = 1;&#10;    release_mutex();&#10;    return success;&#10;}&#10;&#10;// Thread-safe initialization check&#10;HRNG_API int IsRNGThreadSafe(void) {&#10;    return (g_mutex != NULL) ? 1 : 0;&#10;}&#10;&#10;// DLL main entry point - with thread safety initialization&#10;// ReSharper disable once CppParameterMayBeConst&#10;BOOL WINAPI DllMain(HINSTANCE hinstDLL, const DWORD fdwReason) {&#10;    switch (fdwReason) {&#10;        case DLL_PROCESS_ATTACH:&#10;            // Disable thread notifications for better performance&#10;            DisableThreadLibraryCalls(hinstDLL);&#10;&#10;            // Create mutex for thread synchronization&#10;            g_mutex = CreateMutex(NULL, FALSE, &quot;hRngMutex&quot;);&#10;            if (g_mutex == NULL) {&#10;                // Failed to create mutex - critical error&#10;                return FALSE;&#10;            }&#10;            break;&#10;&#10;        case DLL_PROCESS_DETACH:&#10;            // Clean up the mutex when the DLL is unloaded&#10;            if (g_mutex) {&#10;                CloseHandle(g_mutex);&#10;                g_mutex = NULL;&#10;            }&#10;            break;&#10;        default: break;&#10;    }&#10;&#10;    return TRUE;&#10;}&#10;" />
              <option name="updatedContent" value="#define WIN32_NO_STATUS&#10;#include &lt;windows.h&gt;     // Brings in winnt.h without NTSTATUS definitions&#10;#undef WIN32_NO_STATUS&#10;#include &lt;ntstatus.h&gt;    // Now pulls in the NTSTATUS codes without conflict&#10;&#10;#include &lt;stdint.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;string.h&gt;&#10;#include &lt;immintrin.h&gt;   // For _rdrand32_step&#10;#include &lt;intrin.h&gt;      // For __cpuid&#10;#include &lt;mmsystem.h&gt;    // For waveIn functions&#10;#include &lt;iphlpapi.h&gt;    // For network stats&#10;#include &lt;psapi.h&gt;       // For GetProcessMemoryInfo&#10;#include &lt;powrprof.h&gt;    // For battery info&#10;&#10;#pragma comment(lib, &quot;winmm.lib&quot;)&#10;#pragma comment(lib, &quot;bcrypt.lib&quot;)&#10;#pragma comment(lib, &quot;iphlpapi.lib&quot;)&#10;#pragma comment(lib, &quot;psapi.lib&quot;)&#10;#pragma comment(lib, &quot;powrprof.lib&quot;)&#10;&#10;// Define DLL export macro for cleaner syntax&#10;#define HRNG_API __declspec(dllexport)&#10;&#10;// Global mutex for thread synchronization&#10;static HANDLE g_mutex = NULL;&#10;&#10;// Thread-safe mutex acquisition with timeout&#10;static int acquire_mutex(const unsigned int timeout_ms) {&#10;    if (!g_mutex) {&#10;        // Initialize mutex if it doesn't exist yet (for safety)&#10;        g_mutex = CreateMutex(NULL, FALSE, &quot;hRngMutex&quot;);&#10;        if (!g_mutex) return 0;&#10;    }&#10;&#10;    const DWORD result = WaitForSingleObject(g_mutex, timeout_ms);&#10;    if (result == WAIT_OBJECT_0) {&#10;        return 1; // Successfully acquired&#10;    }&#10;    // Handle timeout or error&#10;    return 0;&#10;}&#10;&#10;// Thread-safe mutex release&#10;static void release_mutex(void) {&#10;    if (g_mutex) {&#10;        ReleaseMutex(g_mutex);&#10;    }&#10;}&#10;&#10;// Secure mixing function using SHA-256&#10;static int mix_entropy(unsigned char* buffer, unsigned char* new_data, const size_t data_size) {&#10;    BCRYPT_ALG_HANDLE hAlg = NULL;&#10;    BCRYPT_HASH_HANDLE hHash = NULL;&#10;    DWORD hashSize = 0, resultSize = 0;&#10;    NTSTATUS status = STATUS_SUCCESS;&#10;    int success = 0;&#10;    unsigned char* temp_buffer = NULL;&#10;&#10;    // Initialize algorithm provider&#10;    status = BCryptOpenAlgorithmProvider(&amp;hAlg, BCRYPT_SHA256_ALGORITHM, NULL, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Get hash object size&#10;    status = BCryptGetProperty(hAlg, BCRYPT_OBJECT_LENGTH, (PUCHAR)&amp;hashSize,&#10;                               sizeof(hashSize), &amp;resultSize, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Allocate memory for hash object&#10;    temp_buffer = (unsigned char*)HeapAlloc(GetProcessHeap(), 0, hashSize);&#10;    if (!temp_buffer) goto cleanup;&#10;&#10;    // Create hash object&#10;    status = BCryptCreateHash(hAlg, &amp;hHash, temp_buffer, hashSize, NULL, 0, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Hash existing buffer&#10;    status = BCryptHashData(hHash, buffer, 32, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Hash new data&#10;    status = BCryptHashData(hHash, new_data, (ULONG)data_size, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    // Finalize hash&#10;    status = BCryptFinishHash(hHash, buffer, 32, 0);&#10;    if (!BCRYPT_SUCCESS(status)) goto cleanup;&#10;&#10;    success = 1;&#10;&#10;cleanup:&#10;    if (hHash) BCryptDestroyHash(hHash);&#10;    if (hAlg) BCryptCloseAlgorithmProvider(hAlg, 0);&#10;    if (temp_buffer) HeapFree(GetProcessHeap(), 0, temp_buffer);&#10;&#10;    return success;&#10;}&#10;&#10;// Safely execute CPUID instruction (no SEH, just call)&#10;static int safe_cpuid(int cpuInfo[4], const int function_id) {&#10;    __cpuid(cpuInfo, function_id);&#10;    return 1;&#10;}&#10;&#10;// Check if CPU supports RDRAND instruction&#10;HRNG_API int has_rdrand() {&#10;    int info[4] = {0};&#10;    safe_cpuid(info, 1);&#10;    // Bit 30 of ECX indicates RDRAND support&#10;    return (info[2] &amp; (1 &lt;&lt; 30)) != 0;&#10;}&#10;&#10;// Fill buffer with hardware RNG bytes using RDRAND with retry logic&#10;HRNG_API int read_hwrng(unsigned char* buffer, const int size) {&#10;    if (!buffer || size &lt;= 0) {&#10;        return 0; // Invalid parameters&#10;    }&#10;&#10;    const int has_rdrand_support = has_rdrand();&#10;&#10;    // If RDRAND is not supported, fall back to BCryptGenRandom&#10;    if (!has_rdrand_support) {&#10;        const NTSTATUS status = BCryptGenRandom(NULL, buffer, size,&#10;                                         BCRYPT_USE_SYSTEM_PREFERRED_RNG);&#10;        return BCRYPT_SUCCESS(status) ? 1 : 0;&#10;    }&#10;&#10;    // Use a structured exception handling block for RDRAND operations&#10;    int i = 0;&#10;    uint32_t rnd;&#10;&#10;    while (i &lt; size) {&#10;        const int MAX_RETRIES = 10;&#10;        int success = 0;&#10;&#10;        // Try multiple times if RDRAND fails&#10;        for (int retry = 0; retry &lt; MAX_RETRIES &amp;&amp; !success; retry++) {&#10;            success = _rdrand32_step(&amp;rnd);&#10;            if (!success) Sleep(1); // Small delay between retries&#10;        }&#10;&#10;        if (!success) {&#10;            // Fall back to BCryptGenRandom if RDRAND keeps failing&#10;            const NTSTATUS status = BCryptGenRandom(NULL, buffer + i, size - i,&#10;                                             BCRYPT_USE_SYSTEM_PREFERRED_RNG);&#10;            return BCRYPT_SUCCESS(status) ? 1 : 0;&#10;        }&#10;&#10;        for (int j = 0; j &lt; 4 &amp;&amp; i &lt; size; ++j, ++i) {&#10;            buffer[i] = (rnd &gt;&gt; (j * 8)) &amp; 0xFF;&#10;        }&#10;    }&#10;&#10;    return 1;&#10;}&#10;&#10;// Get system performance info as entropy&#10;static int get_performance_entropy(unsigned char *buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    FILETIME idleTime, kernelTime, userTime;&#10;    MEMORYSTATUSEX memInfo;&#10;    memInfo.dwLength = sizeof(MEMORYSTATUSEX);&#10;&#10;    if (!GetSystemTimes(&amp;idleTime, &amp;kernelTime, &amp;userTime) ||&#10;        !GlobalMemoryStatusEx(&amp;memInfo)) {&#10;        return 0;&#10;    }&#10;&#10;    // Mix different timing and memory values&#10;    ULARGE_INTEGER idle, kernel, user, diskRead, diskWrite;&#10;    idle.LowPart = idleTime.dwLowDateTime;&#10;    idle.HighPart = idleTime.dwHighDateTime;&#10;    kernel.LowPart = kernelTime.dwLowDateTime;&#10;    kernel.HighPart = kernelTime.dwHighDateTime;&#10;    user.LowPart = userTime.dwLowDateTime;&#10;    user.HighPart = userTime.dwHighDateTime;&#10;&#10;    // Get disk I/O information&#10;    IO_COUNTERS ioCounters;&#10;    if (!GetProcessIoCounters(GetCurrentProcess(), &amp;ioCounters)) {&#10;        return 0;&#10;    }&#10;&#10;    diskRead.QuadPart = ioCounters.ReadTransferCount;&#10;    diskWrite.QuadPart = ioCounters.WriteTransferCount;&#10;&#10;    // Process memory information&#10;    PROCESS_MEMORY_COUNTERS pmc;&#10;    if (!GetProcessMemoryInfo(GetCurrentProcess(), &amp;pmc, sizeof(pmc))) {&#10;        return 0;&#10;    }&#10;&#10;    // Get high-precision timer&#10;    LARGE_INTEGER perfCounter, perfFreq;&#10;    QueryPerformanceCounter(&amp;perfCounter);&#10;    QueryPerformanceFrequency(&amp;perfFreq);&#10;&#10;    // Fill the buffer with collected entropy&#10;    memcpy(buffer, &amp;idle.QuadPart, 8);&#10;    memcpy(buffer + 8, &amp;perfCounter.QuadPart, 8);&#10;    memcpy(buffer + 16, &amp;kernel.QuadPart, 8);&#10;    memcpy(buffer + 24, &amp;user.QuadPart, 8);&#10;    memcpy(buffer + 32, &amp;memInfo.ullAvailPhys, 8);&#10;    memcpy(buffer + 40, &amp;memInfo.ullTotalPhys, 8);&#10;    memcpy(buffer + 48, &amp;diskRead.QuadPart, 8);&#10;    memcpy(buffer + 56, &amp;diskWrite.QuadPart, 8);&#10;&#10;    // Add process info&#10;    memcpy(buffer + 64, &amp;pmc.WorkingSetSize, 8);&#10;    memcpy(buffer + 72, &amp;pmc.PagefileUsage, 8);&#10;&#10;    return 1;&#10;}&#10;&#10;// Get audio data from microphone as entropy source&#10;static int get_audio_entropy(unsigned char* buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    HWAVEIN hWaveIn = NULL;&#10;    WAVEHDR waveHdr = {0};&#10;    WAVEFORMATEX wfx = {0};&#10;    int success = 0;&#10;    unsigned char* audioBuffer = NULL;&#10;&#10;    wfx.wFormatTag = WAVE_FORMAT_PCM;&#10;    wfx.nChannels = 1;&#10;    wfx.nSamplesPerSec = 8000;&#10;    wfx.wBitsPerSample = 8;&#10;    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;&#10;    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;&#10;&#10;    // Try to open any available audio device&#10;    MMRESULT result = waveInOpen(&amp;hWaveIn, WAVE_MAPPER, &amp;wfx, 0, 0, CALLBACK_NULL);&#10;    if (result != MMSYSERR_NOERROR) {&#10;        // No audio device available - fill with ticks instead&#10;        const DWORD ticks = GetTickCount();&#10;        for (size_t i = 0; i &lt; 128; i++) {&#10;            buffer[i] = (unsigned char)((ticks + i) &amp; 0xFF);&#10;        }&#10;        return 1; // Return success anyway&#10;    }&#10;&#10;    // Prepare wave buffer&#10;    audioBuffer = (unsigned char*)HeapAlloc(GetProcessHeap(), 0, 128);&#10;    if (!audioBuffer) {&#10;        waveInClose(hWaveIn);&#10;        return 0;&#10;    }&#10;&#10;    waveHdr.lpData = (LPSTR)audioBuffer;&#10;    waveHdr.dwBufferLength = (DWORD)128;&#10;&#10;    result = waveInPrepareHeader(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;    if (result != MMSYSERR_NOERROR) {&#10;        HeapFree(GetProcessHeap(), 0, audioBuffer);&#10;        waveInClose(hWaveIn);&#10;        return 0;&#10;    }&#10;&#10;    // Add the buffer to audio input&#10;    result = waveInAddBuffer(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;    if (result != MMSYSERR_NOERROR) {&#10;        waveInUnprepareHeader(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;        HeapFree(GetProcessHeap(), 0, audioBuffer);&#10;        waveInClose(hWaveIn);&#10;        return 0;&#10;    }&#10;&#10;    // Start recording&#10;    result = waveInStart(hWaveIn);&#10;    if (result != MMSYSERR_NOERROR) {&#10;        waveInUnprepareHeader(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;        HeapFree(GetProcessHeap(), 0, audioBuffer);&#10;        waveInClose(hWaveIn);&#10;        return 0;&#10;    }&#10;&#10;    // Wait for buffer to fill (with timeout)&#10;    const DWORD startTime = GetTickCount();&#10;    while (!(waveHdr.dwFlags &amp; WHDR_DONE)) {&#10;        Sleep(10);&#10;        if (GetTickCount() - startTime &gt; 500) break; // 500ms timeout&#10;    }&#10;&#10;    // Copy whatever data we got&#10;    memcpy(buffer, audioBuffer, 128);&#10;    success = 1;&#10;&#10;    // Cleanup&#10;    waveInStop(hWaveIn);&#10;    waveInUnprepareHeader(hWaveIn, &amp;waveHdr, sizeof(WAVEHDR));&#10;    waveInClose(hWaveIn);&#10;    HeapFree(GetProcessHeap(), 0, audioBuffer);&#10;&#10;    return success;&#10;}&#10;&#10;// Get battery/power information as entropy source&#10;static int get_battery_entropy(unsigned char* buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    SYSTEM_POWER_STATUS powerStatus;&#10;    if (!GetSystemPowerStatus(&amp;powerStatus)) {&#10;        return 0;&#10;    }&#10;&#10;    // Get detailed battery information if available&#10;    SYSTEM_BATTERY_STATE batteryState;&#10;    if (CallNtPowerInformation(SystemBatteryState, NULL, 0,&#10;                              &amp;batteryState, sizeof(batteryState)) == STATUS_SUCCESS) {&#10;        memcpy(buffer, &amp;batteryState, min(128, sizeof(batteryState)));&#10;    } else {&#10;        // Fall back to basic power information&#10;        memcpy(buffer, &amp;powerStatus, min(128, sizeof(powerStatus)));&#10;    }&#10;&#10;    return 1;&#10;}&#10;&#10;// Get network statistics as entropy&#10;static int get_network_entropy(unsigned char* buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    // Get adapter info&#10;    IP_ADAPTER_INFO adapterInfo[16];&#10;    ULONG bufLen = sizeof(adapterInfo);&#10;    const DWORD result = GetAdaptersInfo(adapterInfo, &amp;bufLen);&#10;&#10;    if (result != ERROR_SUCCESS) {&#10;        return 0;&#10;    }&#10;&#10;    // Get TCP statistics&#10;    MIB_TCPSTATS tcpStats;&#10;    if (GetTcpStatistics(&amp;tcpStats) != NO_ERROR) {&#10;        return 0;&#10;    }&#10;&#10;    // Fill buffer with network data&#10;    memcpy(buffer, &amp;tcpStats, min(128, sizeof(tcpStats)));&#10;&#10;    return 1;&#10;}&#10;&#10;// Get CPU-specific entropy using RDTSC and other hardware features&#10;static int get_cpu_entropy(unsigned char* buffer) {&#10;    if (!buffer) return 0;&#10;&#10;    // Get cycles using RDTSC&#10;    unsigned __int64 cycles;&#10;&#10;    cycles = __rdtsc();&#10;    memcpy(buffer, &amp;cycles, sizeof(cycles));&#10;&#10;    // CPU information&#10;    int cpuInfo[4] = {0};&#10;    safe_cpuid(cpuInfo, 0);&#10;    memcpy(buffer + 8, cpuInfo, 16);&#10;&#10;    return 1;&#10;}&#10;&#10;// MaxRNG: Uses multiple entropy sources and mixes them together&#10;HRNG_API int MaxRNG(unsigned char* buffer, const int size) {&#10;    if (!buffer || size &lt;= 0) {&#10;        return 0;&#10;    }&#10;&#10;    // Thread safety: acquire mutex with shorter timeout to prevent deadlock&#10;    const int mutex_acquired = acquire_mutex(500);&#10;    if (!mutex_acquired) {&#10;        // If we can't acquire mutex, use BCryptGenRandom directly as fallback&#10;        return BCRYPT_SUCCESS(BCryptGenRandom(NULL, buffer, size, BCRYPT_USE_SYSTEM_PREFERRED_RNG)) ? 1 : 0;&#10;    }&#10;&#10;    // Allocate temporary buffers for entropy collection&#10;    unsigned char* temp_buffer = NULL;&#10;    const size_t TEMP_SIZE = 128;  // Minimum size for various entropy sources&#10;    int success = 0;&#10;&#10;    // Initialize the output buffer with initial entropy from system RNG&#10;    if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, buffer, size, BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    // Allocate temp buffer for entropy sources&#10;    temp_buffer = (unsigned char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, TEMP_SIZE);&#10;    if (!temp_buffer) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    do {&#10;        // Collect entropy from hardware RNG if available (RDRAND)&#10;        if (has_rdrand()) {&#10;            if (!read_hwrng(temp_buffer, (int)min(TEMP_SIZE, size))) {&#10;                // Fall back to BCryptGenRandom if RDRAND fails&#10;                if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, temp_buffer, (ULONG)min(TEMP_SIZE, size),&#10;                                                   BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;                    break;&#10;                }&#10;            }&#10;            // Mix hardware RNG entropy into buffer&#10;            if (!mix_entropy(buffer, temp_buffer, min(TEMP_SIZE, size))) break;&#10;        }&#10;&#10;        // Collect and mix CPU entropy&#10;        if (get_cpu_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Collect and mix performance/timing entropy&#10;        if (get_performance_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Collect and mix audio entropy (or timing data if no mic available)&#10;        if (get_audio_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Collect and mix battery/power entropy&#10;        if (get_battery_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Collect and mix network entropy&#10;        if (get_network_entropy(temp_buffer)) {&#10;            if (!mix_entropy(buffer, temp_buffer, TEMP_SIZE)) break;&#10;        }&#10;&#10;        // Final mixing with high-precision timer&#10;        LARGE_INTEGER counter;&#10;        QueryPerformanceCounter(&amp;counter);&#10;        memcpy(temp_buffer, &amp;counter, sizeof(counter));&#10;        if (!mix_entropy(buffer, temp_buffer, sizeof(counter))) break;&#10;&#10;        success = 1;&#10;    } while (0); // Non-looping do-while to allow for breaks&#10;&#10;    // Securely clean up the temporary buffer&#10;    SecureZeroMemory(temp_buffer, TEMP_SIZE);&#10;    HeapFree(GetProcessHeap(), 0, temp_buffer);&#10;&#10;    // Release mutex before returning&#10;    release_mutex();&#10;&#10;    return success;&#10;}&#10;&#10;// Additional extended entropy gathering for MaxRNG&#10;HRNG_API int MaxRNG_Extended(unsigned char* buffer, const int size, const int intensive_level) {&#10;    if (!buffer || size &lt;= 0 || intensive_level &lt; 0) {&#10;        return 0;&#10;    }&#10;&#10;    // Thread safety: acquire mutex with 5000ms timeout (longer because this is intensive)&#10;    const int mutex_acquired = acquire_mutex(5000);&#10;    if (!mutex_acquired) {&#10;        // Failed to acquire mutex, cannot safely proceed&#10;        return 0;&#10;    }&#10;&#10;    unsigned char* temp_buffer = NULL;&#10;    const size_t TEMP_SIZE = 256;  // Larger temp buffer for extended entropy&#10;    int success = 0;&#10;    const int iterations = intensive_level &gt; 0 ? intensive_level : 1;&#10;&#10;    // First do a regular MaxRNG call - use internal version without mutex&#10;    // since we already have the mutex locked&#10;    if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, buffer, size, BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    // For higher security levels, perform multiple iterations of mixing&#10;    if (intensive_level &lt;= 1) {&#10;        release_mutex();&#10;        return 1; // Standard MaxRNG is enough for basic usage&#10;    }&#10;&#10;    // Allocate temp buffer for additional entropy passes&#10;    temp_buffer = (unsigned char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, TEMP_SIZE);&#10;    if (!temp_buffer) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    do {&#10;        // Additional entropy gathering based on intensity level&#10;        for (int i = 0; i &lt; iterations; i++) {&#10;            // Mix in more CPU jitter by performing intensive calculations&#10;            LARGE_INTEGER start, end;&#10;            QueryPerformanceCounter(&amp;start);&#10;&#10;            // CPU-intensive operation to generate timing differences&#10;            volatile double result = 1.0;&#10;            for (int j = 0; j &lt; 1000; j++) {&#10;                result *= 1.000001;&#10;            }&#10;&#10;            QueryPerformanceCounter(&amp;end);&#10;&#10;            // Mix in the timing results&#10;            memcpy(temp_buffer, &amp;start, sizeof(start));&#10;            memcpy(temp_buffer + sizeof(start), &amp;end, sizeof(end));&#10;            memcpy(temp_buffer + sizeof(start) + sizeof(end), (const void *)&amp;result, sizeof(result));&#10;            if (!mix_entropy(buffer, temp_buffer, sizeof(start) + sizeof(end) + sizeof(double))) {&#10;                break;&#10;            }&#10;&#10;            // Add a small sleep to allow system state to change&#10;            Sleep(1);&#10;&#10;            // For the highest intensity levels, gather more system state&#10;            if (intensive_level &gt;= 3) {&#10;                // Get multiple CPU info samples&#10;                for (int cpuid_leaf = 0; cpuid_leaf &lt; 4; cpuid_leaf++) {&#10;                    int cpu_info[4];&#10;                    safe_cpuid(cpu_info, cpuid_leaf);&#10;                    memcpy(temp_buffer + cpuid_leaf * 16, cpu_info, 16);&#10;                }&#10;&#10;                if (!mix_entropy(buffer, temp_buffer, 64)) {&#10;                    break;&#10;                }&#10;&#10;                // Gather disk I/O timing entropy&#10;                // ReSharper disable once CppLocalVariableMayBeConst&#10;                HANDLE hFile = CreateFile(&quot;NUL&quot;, GENERIC_WRITE,&#10;                                          FILE_SHARE_READ | FILE_SHARE_WRITE,&#10;                                          NULL, OPEN_EXISTING, 0, NULL);&#10;                if (hFile != INVALID_HANDLE_VALUE) {&#10;                    const char dummy[16] = {0};&#10;                    DWORD written = 0;&#10;&#10;                    QueryPerformanceCounter(&amp;start);&#10;                    WriteFile(hFile, dummy, sizeof(dummy), &amp;written, NULL);&#10;                    QueryPerformanceCounter(&amp;end);&#10;&#10;                    CloseHandle(hFile);&#10;&#10;                    memcpy(temp_buffer, &amp;start, sizeof(start));&#10;                    memcpy(temp_buffer + sizeof(start), &amp;end, sizeof(end));&#10;&#10;                    if (!mix_entropy(buffer, temp_buffer, sizeof(start) + sizeof(end))) {&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        success = 1;&#10;    } while (0); // Non-looping do-while to allow for breaks&#10;&#10;    SecureZeroMemory(temp_buffer, TEMP_SIZE);&#10;    HeapFree(GetProcessHeap(), 0, temp_buffer);&#10;&#10;    // Release mutex before returning&#10;    release_mutex();&#10;&#10;    return success;&#10;}&#10;&#10;// Self-test function to verify RNG functionality&#10;HRNG_API int RNG_SelfTest(void) {&#10;    // Thread safety: acquire mutex with 2000ms timeout&#10;    const int mutex_acquired = acquire_mutex(2000);&#10;    if (!mutex_acquired) {&#10;        // Failed to acquire mutex, cannot safely proceed&#10;        return 0;&#10;    }&#10;&#10;    unsigned char buffer1[32] = {0};&#10;    unsigned char buffer2[32] = {0};&#10;    int success = 0;&#10;&#10;    // Test hardware RNG if available&#10;    if (has_rdrand()) {&#10;        if (!read_hwrng(buffer1, sizeof(buffer1))) {&#10;            release_mutex();&#10;            return 0; // Hardware RNG failed&#10;        }&#10;&#10;        // Make sure we're not getting all zeros&#10;        int allZeros = 1;&#10;        for (int i = 0; i &lt; sizeof(buffer1); i++) {&#10;            if (buffer1[i] != 0) {&#10;                allZeros = 0;&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (allZeros) {&#10;            release_mutex();&#10;            return 0; // Hardware RNG returned all zeros&#10;        }&#10;&#10;        // Test a second read to ensure different values&#10;        if (!read_hwrng(buffer2, sizeof(buffer2))) {&#10;            release_mutex();&#10;            return 0; // Second hardware RNG read failed&#10;        }&#10;&#10;        // Outputs should be different&#10;        if (memcmp(buffer1, buffer2, sizeof(buffer1)) == 0) {&#10;            release_mutex();&#10;            return 0; // Hardware RNG returned identical sequences&#10;        }&#10;    }&#10;&#10;    // Test MaxRNG&#10;    memset(buffer1, 0, sizeof(buffer1));&#10;    memset(buffer2, 0, sizeof(buffer2));&#10;&#10;    // Use BCryptGenRandom directly to avoid mutex deadlock&#10;    // since MaxRNG would try to acquire the same mutex&#10;    if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, buffer1, sizeof(buffer1),&#10;                                        BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    if (!BCRYPT_SUCCESS(BCryptGenRandom(NULL, buffer2, sizeof(buffer2),&#10;                                        BCRYPT_USE_SYSTEM_PREFERRED_RNG))) {&#10;        release_mutex();&#10;        return 0;&#10;    }&#10;&#10;    // Outputs should be different&#10;    if (memcmp(buffer1, buffer2, sizeof(buffer1)) == 0) {&#10;        release_mutex();&#10;        return 0; // System RNG returned identical sequences&#10;    }&#10;&#10;    success = 1;&#10;    release_mutex();&#10;    return success;&#10;}&#10;&#10;// Thread-safe initialization check&#10;HRNG_API int IsRNGThreadSafe(void) {&#10;    return (g_mutex != NULL) ? 1 : 0;&#10;}&#10;&#10;// DLL main entry point - with thread safety initialization&#10;// ReSharper disable once CppParameterMayBeConst&#10;BOOL WINAPI DllMain(HINSTANCE hinstDLL, const DWORD fdwReason, LPVOID lpvReserved) {&#10;    switch (fdwReason) {&#10;        case DLL_PROCESS_ATTACH:&#10;            // Disable thread notifications for better performance&#10;            DisableThreadLibraryCalls(hinstDLL);&#10;&#10;            // Create mutex for thread synchronization&#10;            g_mutex = CreateMutex(NULL, FALSE, &quot;hRngMutex&quot;);&#10;            // Note: We continue even if mutex creation fails, as functions have fallbacks&#10;            break;&#10;&#10;        case DLL_PROCESS_DETACH:&#10;            // Clean up the mutex when the DLL is unloaded&#10;            if (g_mutex) {&#10;                CloseHandle(g_mutex);&#10;                g_mutex = NULL;&#10;            }&#10;            break;&#10;        default: break;&#10;    }&#10;&#10;    return TRUE;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.h" />
              <option name="updatedContent" value="#ifndef PYCTOOLS_HRNG_H&#10;#define PYCTOOLS_HRNG_H&#10;&#10;#ifdef __cplusplus&#10;extern &quot;C&quot; {&#10;#endif&#10;&#10;/**&#10; * Checks if the CPU supports the RDRAND instruction&#10; * &#10; * @return 1 if supported, 0 if not&#10; */&#10;int has_rdrand(void);&#10;&#10;/**&#10; * Fills a buffer with random bytes using hardware RNG (RDRAND if available)&#10; * &#10; * @param buffer Pointer to buffer to fill with random bytes&#10; * @param size Size of the buffer in bytes&#10; * @return 1 on success, 0 on failure&#10; */&#10;__declspec(dllexport)&#10;int read_hwrng(unsigned char* buffer, int size);&#10;&#10;/**&#10; * Maximum security RNG that uses multiple entropy sources:&#10; * - Hardware RNG (RDRAND)&#10; * - CPU information and timings&#10; * - Audio input (microphone)&#10; * - Battery/power status&#10; * - Memory and process statistics&#10; * - Network statistics&#10; * - Performance counters&#10; * &#10; * The entropy is mixed using cryptographic algorithms.&#10; * &#10; * @param buffer Pointer to buffer to fill with random bytes&#10; * @param size Size of the buffer in bytes&#10; * @return 1 on success, 0 on failure&#10; */&#10;__declspec(dllexport)&#10;int MaxRNG(unsigned char* buffer, int size);&#10;&#10;#ifdef __cplusplus&#10;}&#10;#endif&#10;&#10;#endif // PYCTOOLS_HRNG_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hRng.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hRng.md" />
              <option name="updatedContent" value="# Hardware Random Number Generator (hRng)&#10;&#10;## Overview&#10;&#10;The Hardware Random Number Generator (hRng) is a high-security random number generation library designed for Windows systems. It provides cryptographically secure random numbers by combining multiple entropy sources with hardware-based random number generation when available.&#10;&#10;## Key Features&#10;&#10;- Hardware-accelerated random number generation using Intel RDRAND instruction (when available)&#10;- Multiple entropy sources for enhanced security:&#10;  - CPU-specific entropy (RDTSC, CPUID)&#10;  - System performance metrics (timing, memory usage, disk I/O)&#10;  - Audio data from microphone&#10;  - Battery and power status information&#10;  - Network statistics&#10;- Secure entropy mixing using SHA-256&#10;- Thread-safe operation&#10;- Self-testing capabilities&#10;- Fallback mechanisms when primary sources fail&#10;- Multiple security levels with extended entropy gathering&#10;&#10;## API Reference&#10;&#10;### Basic Functions&#10;&#10;#### `int has_rdrand()`&#10;Detects if the CPU supports the RDRAND instruction.&#10;&#10;**Returns:**&#10;- `1` if RDRAND is supported&#10;- `0` if RDRAND is not supported&#10;&#10;#### `int read_hwrng(unsigned char* buffer, const int size)`&#10;Fills a buffer with random data using hardware RNG (RDRAND) with retry logic.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int MaxRNG(unsigned char* buffer, const int size)`&#10;The primary RNG function that combines multiple entropy sources.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int MaxRNG_ThreadSafe(unsigned char* buffer, const int size)`&#10;Thread-safe wrapper for MaxRNG.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;### Advanced Functions&#10;&#10;#### `int MaxRNG_Extended(unsigned char* buffer, const int size, const int intensive_level)`&#10;Enhanced random number generation with configurable intensity level.&#10;&#10;**Parameters:**&#10;- `buffer`: Pointer to the buffer to fill with random bytes&#10;- `size`: Number of bytes to generate&#10;- `intensive_level`: Level of entropy gathering intensity (1-5):&#10;  - `1`: Standard MaxRNG operation&#10;  - `2`: Additional CPU jitter entropy&#10;  - `3+`: Maximum entropy gathering from all available sources&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure&#10;&#10;#### `int RNG_SelfTest(void)`&#10;Self-diagnostic function to verify RNG functionality.&#10;&#10;**Returns:**&#10;- `1` if all tests pass&#10;- `0` if any test fails&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*MaxRNG_Func)(unsigned char*, int);&#10;typedef int (*RNG_SelfTest_Func)(void);&#10;&#10;int main() {&#10;    // Load the DLL&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    // Get function pointers&#10;    MaxRNG_Func MaxRNG = (MaxRNG_Func)GetProcAddress(hRngDll, &quot;MaxRNG&quot;);&#10;    RNG_SelfTest_Func RNG_SelfTest = (RNG_SelfTest_Func)GetProcAddress(hRngDll, &quot;RNG_SelfTest&quot;);&#10;    &#10;    if (!MaxRNG || !RNG_SelfTest) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Run self-test&#10;    if (!RNG_SelfTest()) {&#10;        printf(&quot;RNG self-test failed\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate random bytes&#10;    unsigned char buffer[32] = {0};&#10;    if (MaxRNG(buffer, sizeof(buffer))) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;        }&#10;        printf(&quot;\n&quot;);&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Thread-Safe Usage&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_ThreadSafe_Func)(unsigned char*, int);&#10;&#10;DWORD WINAPI ThreadFunc(LPVOID lpParam) {&#10;    MaxRNG_ThreadSafe_Func MaxRNG_ThreadSafe = (MaxRNG_ThreadSafe_Func)lpParam;&#10;    &#10;    unsigned char buffer[16] = {0};&#10;    int result = MaxRNG_ThreadSafe(buffer, sizeof(buffer));&#10;    &#10;    // Print thread ID and result&#10;    printf(&quot;Thread %lu: %s\n&quot;, GetCurrentThreadId(), &#10;           result ? &quot;Success&quot; : &quot;Failed&quot;);&#10;           &#10;    return 0;&#10;}&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_ThreadSafe_Func MaxRNG_ThreadSafe = &#10;        (MaxRNG_ThreadSafe_Func)GetProcAddress(hRngDll, &quot;MaxRNG_ThreadSafe&quot;);&#10;    &#10;    if (!MaxRNG_ThreadSafe) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Create multiple threads to test thread safety&#10;    HANDLE threads[5];&#10;    for (int i = 0; i &lt; 5; i++) {&#10;        threads[i] = CreateThread(NULL, 0, ThreadFunc, &#10;                                 (LPVOID)MaxRNG_ThreadSafe, 0, NULL);&#10;    }&#10;    &#10;    // Wait for all threads to complete&#10;    WaitForMultipleObjects(5, threads, TRUE, INFINITE);&#10;    &#10;    for (int i = 0; i &lt; 5; i++) {&#10;        CloseHandle(threads[i]);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Using MaxRNG_Extended for Maximum Security&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;#include &lt;windows.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*MaxRNG_Extended_Func)(unsigned char*, int, int);&#10;&#10;int main() {&#10;    HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;    if (!hRngDll) {&#10;        printf(&quot;Failed to load hRng.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    MaxRNG_Extended_Func MaxRNG_Extended = &#10;        (MaxRNG_Extended_Func)GetProcAddress(hRngDll, &quot;MaxRNG_Extended&quot;);&#10;    &#10;    if (!MaxRNG_Extended) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hRngDll);&#10;        return 1;&#10;    }&#10;    &#10;    // Generate high-security random bytes (intensity level 5)&#10;    unsigned char buffer[64] = {0};&#10;    printf(&quot;Generating high-entropy random bytes...\n&quot;);&#10;    &#10;    if (MaxRNG_Extended(buffer, sizeof(buffer), 5)) {&#10;        printf(&quot;Random bytes generated successfully:\n&quot;);&#10;        for (int i = 0; i &lt; sizeof(buffer); i++) {&#10;            printf(&quot;%02X &quot;, buffer[i]);&#10;            if ((i + 1) % 16 == 0) printf(&quot;\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to generate random bytes\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hRngDll);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Entropy Sources&#10;&#10;The library collects entropy from multiple sources:&#10;&#10;1. **Hardware RNG (RDRAND)**&#10;   - Uses Intel's RDRAND instruction when available&#10;   - Implements retry logic for reliability&#10;&#10;2. **CPU-specific Sources**&#10;   - RDTSC (Read Time-Stamp Counter)&#10;   - CPUID information&#10;&#10;3. **System Performance Metrics**&#10;   - Process memory information&#10;   - CPU timing information&#10;   - Disk I/O statistics&#10;   - High-precision performance counters&#10;&#10;4. **Audio Data**&#10;   - Samples microphone input&#10;   - Falls back to timing data if no microphone is available&#10;&#10;5. **Battery/Power Information**&#10;   - Battery state and charge levels&#10;   - Power status information&#10;&#10;6. **Network Statistics**&#10;   - TCP/IP statistics&#10;   - Network adapter information&#10;&#10;### Entropy Mixing&#10;&#10;All entropy sources are securely combined using SHA-256 through the Windows BCrypt API to ensure:&#10;&#10;- Uniform distribution of random bits&#10;- High entropy density&#10;- Protection against predictability attacks&#10;&#10;### Security Considerations&#10;&#10;- The library securely zeroes memory containing sensitive data using SecureZeroMemory&#10;- Multiple fallback mechanisms ensure reliability when primary entropy sources fail&#10;- Thread synchronization protects against race conditions in multi-threaded environments&#10;- Self-test functionality verifies proper operation before use&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - winmm.lib&#10;  - bcrypt.lib&#10;  - iphlpapi.lib&#10;  - psapi.lib&#10;  - powrprof.lib&#10;&#10;### Linking with Your Application&#10;&#10;When compiling your application, make sure to include the appropriate header file and link against the hRng.dll library.&#10;&#10;#### Static Linking&#10;&#10;```c&#10;#pragma comment(lib, &quot;hRng.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hRngDll = LoadLibrary(&quot;hRng.dll&quot;);&#10;if (hRngDll) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```&#10;&#10;## License and Attribution&#10;&#10;This Hardware Random Number Generator library is provided for secure random number generation in Windows environments.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/processInspect.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/processInspect.md" />
              <option name="updatedContent" value="# Process Inspection Module (processInspect)&#10;&#10;## Overview&#10;&#10;The Process Inspection Module provides powerful, low-level access to Windows process metrics and performance data. This library allows applications to monitor process resource usage with minimal overhead, supporting both instantaneous measurements and differential metrics over specified time periods.&#10;&#10;## Key Features&#10;&#10;- Low-overhead process monitoring&#10;- Memory usage metrics (working set, private bytes, pagefile usage)&#10;- Process resource tracking (handles, threads)&#10;- CPU utilization measurement&#10;- I/O operations monitoring (read/write)&#10;- Support for both snapshot and time-interval measurements&#10;- JSON-formatted output for easy integration&#10;- Customizable metrics selection&#10;&#10;## API Reference&#10;&#10;### Constants&#10;&#10;#### Metrics Flags&#10;&#10;The following constants are used to specify which metrics to collect:&#10;&#10;```c&#10;#define METRIC_WORKING_SET   0x01  // Process working set size&#10;#define METRIC_PRIVATE_BYTES 0x02  // Private memory usage&#10;#define METRIC_PAGEFILE      0x04  // Pagefile usage&#10;#define METRIC_HANDLES       0x08  // Handle count&#10;#define METRIC_THREADS       0x10  // Thread count&#10;#define METRIC_CPU_USAGE     0x20  // CPU usage percentage&#10;#define METRIC_IO            0x40  // I/O read/write operations&#10;#define METRIC_NET           0x80  // Network usage (when implemented)&#10;```&#10;&#10;### Functions&#10;&#10;#### `int get_metrics_json(DWORD pid, DWORD metrics, char *json_buf, size_t json_buflen)`&#10;&#10;Takes an instantaneous snapshot of the specified process metrics.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID to monitor&#10;- `metrics`: Bitwise combination of METRIC_* flags indicating which metrics to collect&#10;- `json_buf`: Output buffer where the JSON-formatted metrics will be written&#10;- `json_buflen`: Size of the output buffer&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure (invalid process, insufficient permissions, buffer too small)&#10;&#10;**JSON Output Format:**&#10;```json&#10;{&#10;  &quot;pid&quot;: 1234,&#10;  &quot;working_set_kb&quot;: 45678,&#10;  &quot;private_kb&quot;: 34567,&#10;  &quot;pagefile_kb&quot;: 23456,&#10;  &quot;handles&quot;: 345,&#10;  &quot;threads&quot;: 12,&#10;  &quot;cpu&quot;: 3.45,&#10;  &quot;io_read_kb&quot;: 1234,&#10;  &quot;io_write_kb&quot;: 5678&#10;}&#10;```&#10;&#10;#### `int start_metrics_collection(DWORD pid, DWORD metrics)`&#10;&#10;Begins collecting metrics for a process over a time period. Must be paired with a later call to `end_metrics_collection()`.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID to monitor&#10;- `metrics`: Bitwise combination of METRIC_* flags indicating which metrics to collect&#10;&#10;**Returns:**&#10;- `1` if collection successfully started&#10;- `0` on failure (invalid process, insufficient permissions)&#10;&#10;#### `int end_metrics_collection(DWORD pid, DWORD metrics, char *json_buf, size_t json_buflen)`&#10;&#10;Ends metrics collection and calculates differentials for the time period since `start_metrics_collection()` was called.&#10;&#10;**Parameters:**&#10;- `pid`: Process ID (must match the one used in `start_metrics_collection()`)&#10;- `metrics`: Bitwise combination of METRIC_* flags (must match the ones used in `start_metrics_collection()`)&#10;- `json_buf`: Output buffer where the JSON-formatted metrics will be written&#10;- `json_buflen`: Size of the output buffer&#10;&#10;**Returns:**&#10;- `1` on success&#10;- `0` on failure (invalid process, metrics mismatch, insufficient permissions, buffer too small)&#10;&#10;**Notes:**&#10;- CPU and I/O metrics are reported as deltas between start and end collection&#10;- Memory metrics are instantaneous values at the time of call&#10;&#10;## Usage Examples&#10;&#10;### Taking a Snapshot of Process Metrics&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL function&#10;typedef int (*GetMetricsJson_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;int main() {&#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    GetMetricsJson_Func GetMetricsJson = &#10;        (GetMetricsJson_Func)GetProcAddress(hModule, &quot;get_metrics_json&quot;);&#10;    &#10;    if (!GetMetricsJson) {&#10;        printf(&quot;Failed to get function address\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = 1234; // Replace with actual PID&#10;    const DWORD metrics = METRIC_WORKING_SET | METRIC_PRIVATE_BYTES | &#10;                         METRIC_HANDLES | METRIC_CPU_USAGE;&#10;    &#10;    char json_buffer[1024] = {0};&#10;    &#10;    if (GetMetricsJson(pid, metrics, json_buffer, sizeof(json_buffer))) {&#10;        printf(&quot;Process metrics: %s\n&quot;, json_buffer);&#10;    } else {&#10;        printf(&quot;Failed to get process metrics\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Measuring Process Metrics Over Time&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*StartMetricsCollection_Func)(DWORD, DWORD);&#10;typedef int (*EndMetricsCollection_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;int main() {&#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    StartMetricsCollection_Func StartMetricsCollection = &#10;        (StartMetricsCollection_Func)GetProcAddress(hModule, &quot;start_metrics_collection&quot;);&#10;    &#10;    EndMetricsCollection_Func EndMetricsCollection = &#10;        (EndMetricsCollection_Func)GetProcAddress(hModule, &quot;end_metrics_collection&quot;);&#10;    &#10;    if (!StartMetricsCollection || !EndMetricsCollection) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = 1234; // Replace with actual PID&#10;    const DWORD metrics = METRIC_CPU_USAGE | METRIC_IO;&#10;    &#10;    if (StartMetricsCollection(pid, metrics)) {&#10;        printf(&quot;Started metrics collection. Monitoring for 5 seconds...\n&quot;);&#10;        &#10;        // Wait for a period to collect metrics&#10;        Sleep(5000);&#10;        &#10;        char json_buffer[1024] = {0};&#10;        if (EndMetricsCollection(pid, metrics, json_buffer, sizeof(json_buffer))) {&#10;            printf(&quot;Process metrics over 5 seconds: %s\n&quot;, json_buffer);&#10;        } else {&#10;            printf(&quot;Failed to end metrics collection\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to start metrics collection\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Complete Example with All Metrics&#10;&#10;```c&#10;#include &lt;windows.h&gt;&#10;#include &lt;stdio.h&gt;&#10;&#10;// Import the DLL functions&#10;typedef int (*StartMetricsCollection_Func)(DWORD, DWORD);&#10;typedef int (*EndMetricsCollection_Func)(DWORD, DWORD, char*, size_t);&#10;typedef int (*GetMetricsJson_Func)(DWORD, DWORD, char*, size_t);&#10;&#10;// Metrics flags&#10;#define METRIC_WORKING_SET   0x01&#10;#define METRIC_PRIVATE_BYTES 0x02&#10;#define METRIC_PAGEFILE      0x04&#10;#define METRIC_HANDLES       0x08&#10;#define METRIC_THREADS       0x10&#10;#define METRIC_CPU_USAGE     0x20&#10;#define METRIC_IO            0x40&#10;#define METRIC_NET           0x80&#10;&#10;int main(int argc, char* argv[]) {&#10;    if (argc &lt; 2) {&#10;        printf(&quot;Usage: %s &lt;PID&gt;\n&quot;, argv[0]);&#10;        return 1;&#10;    }&#10;    &#10;    const DWORD pid = (DWORD)atoi(argv[1]);&#10;    &#10;    HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;    if (!hModule) {&#10;        printf(&quot;Failed to load processInspect.dll\n&quot;);&#10;        return 1;&#10;    }&#10;    &#10;    StartMetricsCollection_Func StartMetricsCollection = &#10;        (StartMetricsCollection_Func)GetProcAddress(hModule, &quot;start_metrics_collection&quot;);&#10;    &#10;    EndMetricsCollection_Func EndMetricsCollection = &#10;        (EndMetricsCollection_Func)GetProcAddress(hModule, &quot;end_metrics_collection&quot;);&#10;    &#10;    GetMetricsJson_Func GetMetricsJson = &#10;        (GetMetricsJson_Func)GetProcAddress(hModule, &quot;get_metrics_json&quot;);&#10;    &#10;    if (!StartMetricsCollection || !EndMetricsCollection || !GetMetricsJson) {&#10;        printf(&quot;Failed to get function addresses\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    // All available metrics&#10;    const DWORD all_metrics = METRIC_WORKING_SET | METRIC_PRIVATE_BYTES | &#10;                             METRIC_PAGEFILE | METRIC_HANDLES | METRIC_THREADS | &#10;                             METRIC_CPU_USAGE | METRIC_IO;&#10;    &#10;    // First, take an instant snapshot&#10;    char json_buffer[1024] = {0};&#10;    if (GetMetricsJson(pid, all_metrics, json_buffer, sizeof(json_buffer))) {&#10;        printf(&quot;Instant metrics snapshot:\n%s\n\n&quot;, json_buffer);&#10;    } else {&#10;        printf(&quot;Failed to get instant metrics\n&quot;);&#10;        FreeLibrary(hModule);&#10;        return 1;&#10;    }&#10;    &#10;    // Then measure over time&#10;    if (StartMetricsCollection(pid, all_metrics)) {&#10;        printf(&quot;Collecting metrics for 10 seconds...\n&quot;);&#10;        Sleep(10000);&#10;        &#10;        if (EndMetricsCollection(pid, all_metrics, json_buffer, sizeof(json_buffer))) {&#10;            printf(&quot;Metrics over 10 seconds:\n%s\n&quot;, json_buffer);&#10;        } else {&#10;            printf(&quot;Failed to end metrics collection\n&quot;);&#10;        }&#10;    } else {&#10;        printf(&quot;Failed to start metrics collection\n&quot;);&#10;    }&#10;    &#10;    FreeLibrary(hModule);&#10;    return 0;&#10;}&#10;```&#10;&#10;## Technical Details&#10;&#10;### Process Metrics Explained&#10;&#10;#### Memory Metrics&#10;&#10;- **Working Set (METRIC_WORKING_SET)**: &#10;  The set of memory pages currently visible to the process in physical RAM. This includes shared and private pages.&#10;&#10;- **Private Bytes (METRIC_PRIVATE_BYTES)**:&#10;  Memory that cannot be shared with other processes. This represents the actual memory cost of the process.&#10;&#10;- **Pagefile Usage (METRIC_PAGEFILE)**:&#10;  The amount of the system page file that is being used by the process. This includes all memory that the process has touched, including pages that are in RAM.&#10;&#10;#### Resource Metrics&#10;&#10;- **Handles (METRIC_HANDLES)**:&#10;  The number of object handles in the process's handle table. This includes files, registry keys, events, etc.&#10;&#10;- **Threads (METRIC_THREADS)**:&#10;  The number of threads currently executing in the process.&#10;&#10;#### Performance Metrics&#10;&#10;- **CPU Usage (METRIC_CPU_USAGE)**:&#10;  Percentage of available CPU time that the process has used. When collected over time, this represents the average usage during that period.&#10;&#10;- **I/O Operations (METRIC_IO)**:&#10;  Total bytes read from and written to the disk by the process. When collected over time, this represents the bytes transferred during that period.&#10;&#10;### Implementation Details&#10;&#10;- The library uses Windows Performance Data Helper (PDH) and Process Status API (PSAPI) to collect metrics&#10;- Thread synchronization is implemented for metric collection over time&#10;- The implementation uses Windows-specific APIs and is optimized for minimal overhead&#10;- CPU usage calculation takes into account all cores/processors in the system&#10;- All memory metrics are reported in kilobytes (KB)&#10;&#10;### Known Limitations&#10;&#10;- Requires administrator privileges to monitor some processes&#10;- CPU usage metrics may not be 100% accurate for very short-lived processes&#10;- Network metrics are reserved for future implementation (METRIC_NET flag)&#10;- Only supports Windows operating systems&#10;&#10;## Building and Integration&#10;&#10;### Requirements&#10;&#10;- Windows operating system (Windows 7 or later)&#10;- Visual Studio or compatible C compiler&#10;- Required Windows libraries:&#10;  - psapi.lib&#10;  - iphlpapi.lib&#10;&#10;### Linking with Your Application&#10;&#10;#### Static Linking&#10;&#10;```c&#10;#pragma comment(lib, &quot;processInspect.lib&quot;)&#10;```&#10;&#10;#### Dynamic Loading&#10;&#10;```c&#10;HMODULE hModule = LoadLibrary(&quot;processInspect.dll&quot;);&#10;if (hModule) {&#10;    // Get function pointers using GetProcAddress&#10;    // ...&#10;}&#10;```&#10;&#10;### Python Integration&#10;&#10;The library can be easily used from Python via ctypes:&#10;&#10;```python&#10;import ctypes&#10;from ctypes import c_int, c_ulong, c_char_p, c_size_t&#10;&#10;# Load the DLL&#10;process_inspect = ctypes.CDLL(&quot;processInspect.dll&quot;)&#10;&#10;# Define metrics constants&#10;METRIC_WORKING_SET = 0x01&#10;METRIC_PRIVATE_BYTES = 0x02&#10;METRIC_PAGEFILE = 0x04&#10;METRIC_HANDLES = 0x08&#10;METRIC_THREADS = 0x10&#10;METRIC_CPU_USAGE = 0x20&#10;METRIC_IO = 0x40&#10;METRIC_ALL = 0x7F&#10;&#10;# Define function prototypes&#10;get_metrics_json = process_inspect.get_metrics_json&#10;get_metrics_json.argtypes = [c_ulong, c_ulong, c_char_p, c_size_t]&#10;get_metrics_json.restype = c_int&#10;&#10;# Usage example&#10;def get_process_metrics(pid, metrics=METRIC_ALL):&#10;    buffer = ctypes.create_string_buffer(1024)&#10;    if get_metrics_json(pid, metrics, buffer, len(buffer)):&#10;        return buffer.value.decode('utf-8')&#10;    return None&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import json&#10;    &#10;    pid = 1234  # Replace with actual PID&#10;    metrics_json = get_process_metrics(pid)&#10;    if metrics_json:&#10;        metrics = json.loads(metrics_json)&#10;        print(f&quot;Process {pid} is using {metrics.get('working_set_kb', 0):,} KB of memory&quot;)&#10;        print(f&quot;CPU Usage: {metrics.get('cpu', 0):.2f}%&quot;)&#10;```&#10;&#10;## License and Attribution&#10;&#10;This Process Inspection Module is provided for monitoring and analyzing process performance in Windows environments.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_hrng.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_hrng.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;&#10;DLL_PATH = os.path.join(os.path.dirname(__file__), &quot;src&quot;, &quot;hRng.dll&quot;)&#10;&#10;hrng = ctypes.WinDLL(DLL_PATH)&#10;&#10;# Function prototypes&#10;hrng.MaxRNG.argtypes = [ctypes.c_void_p, ctypes.c_int]&#10;hrng.MaxRNG.restype = ctypes.c_int&#10;&#10;hrng.RNG_SelfTest.restype = ctypes.c_int&#10;&#10;def test_maxrng():&#10;    buf = (ctypes.c_ubyte * 32)()&#10;    result = hrng.MaxRNG(buf, 32)&#10;    print(&quot;MaxRNG result:&quot;, result)&#10;    print(&quot;Random bytes:&quot;, bytes(buf).hex())&#10;&#10;def test_selftest():&#10;    result = hrng.RNG_SelfTest()&#10;    print(&quot;RNG_SelfTest result:&quot;, result)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_selftest()&#10;    test_maxrng()&#10;&#10;" />
              <option name="updatedContent" value="oimport ctypes&#10;import os&#10;&#10;DLL_PATH = os.path.join(os.path.dirname(__file__), &quot;src&quot;, &quot;hRng.dll&quot;)&#10;&#10;hrng = ctypes.WinDLL(DLL_PATH)&#10;&#10;# Function prototypes&#10;hrng.MaxRNG.argtypes = [ctypes.c_void_p, ctypes.c_int]&#10;hrng.MaxRNG.restype = ctypes.c_int&#10;&#10;hrng.RNG_SelfTest.restype = ctypes.c_int&#10;&#10;def test_maxrng():&#10;    buf = (ctypes.c_ubyte * 32)()&#10;    result = hrng.MaxRNG(buf, 32)&#10;    print(&quot;MaxRNG result:&quot;, result)&#10;    print(&quot;Random bytes:&quot;, bytes(buf).hex())&#10;&#10;def test_selftest():&#10;    result = hrng.RNG_SelfTest()&#10;    print(&quot;RNG_SelfTest result:&quot;, result)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    test_selftest()&#10;    test_maxrng()&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>